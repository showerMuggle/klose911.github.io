#+TITLE: 列表
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: data_type.html   
#+HTML_LINK_HOME: elisp.html
#+OPTIONS: num:nil timestamp:nil ^:nil

* cons cell 

  如果从概念上来说，cons cell 其实非常简单的，就是两个有顺序的元素。第一个叫 CAR，第二个就 CDR
  #+BEGIN_EXAMPLE
    CAR 和 CDR 名字来自于 Lisp。它最初在IBM 704机器上的实现。在这种机器有一种取址模式，使人可以访问一个存储地址中的“地址（address）”部分和“减量（decrement）”部分

    CAR 指令用于取出地址部分，表示(Contents of Address part of Register)，CDR 指令用于取出地址的减量部分(Contents of the Decrement part of Register)
  #+END_EXAMPLE
  cons cell 也就是 construction of cells
  + _car_ 函数：取得 cons cell 的 CAR 部分
  + _cdr_ 取得cons cell 的 CDR 部分

  #+BEGIN_EXAMPLE
    cons cell 如此简单，但是它却能衍生出许多高级的数据结构，比如链表，树，关联表等等
  #+END_EXAMPLE

  cons cell 的读入语法是用 _._ 分开两个部分，比如：

  #+BEGIN_SRC lisp 
  '(1 . 2)                                ; => (1 . 2)
  '(?a . 1)                               ; => (97 . 1)
  '(1 . "a")                              ; => (1 . "a")
  '(1 . nil)                              ; => (1)
  '(nil . nil)                            ; => (nil)
  #+END_SRC

  #+BEGIN_EXAMPLE
    注意到前面的表达式中都有一个 ' 号，这是什么意思呢？其实理解了 eval-last-sexp 的作用就能明白了

    eval-last-sexp 其实包含了两个步骤，一是读入前一个 S-表达式，二是对读入的 S-表达式求值

    如果读入的 S-表达式是一个 cons cell 的话，求值时会把这个 cons cell 的第一个元素作为一个函数来调用。而事实上，前面这些例子的第一个元素都不是一个函数，这样就会产生一个错误 invalid-function

    之所以前面没有遇到这个问题，那是因为前面数字和字符串是一类特殊的 S-表达式，它们求值后和求值前是不变，称为自求值表达式（self-evaluating form）
  #+END_EXAMPLE
  _'_ 号其实是一个特殊的函数 _quote_ ，它的作用是将它的参数返回而不作求值

  #+BEGIN_EXAMPLE
  '(1 . 2) 等价于 (quote (1 . 2))
  #+END_EXAMPLE

  为了证明 cons cell 的读入语法确实就是它的输出形式，可以看下面这个语句：

  #+BEGIN_SRC lisp 
  (read "(1 . 2)")                        ; => (1 . 2)
  #+END_SRC

* 列表
  列表包括了 cons cell。但是列表中有一个特殊的元素： *空表* _nil_ 

  #+BEGIN_SRC lisp 
  nil                                     ; => nil
  '()                                     ; => nil
  #+END_SRC

  空表不是一个 cons cell，因为它没有 CAR 和 CDR 两个部分，事实上空表里没有任何内容。但是为了编程的方便，可以认为 nil 的 CAR 和 CDR 都是 nil：

  #+BEGIN_SRC lisp 
  (car nil)                               ; => nil
  (cdr nil)                               ; => nil
  #+END_SRC

  按列表最后一个 cons cell 的 _CDR 部分_ 的类型分，可以把列表分为三类：
  1. 如果它是 nil 的话，这个列表也称为 _真列表_ 
  2. 如果既不是 nil 也不是一个 cons cell，则这个列表称为 _点列表_
  3. 它指向列表中之前的一个 cons cell，则称为 _环形列表_  

  #+BEGIN_SRC lisp 
  '(1 2 3)                                  ; => (1 2 3)
  '(1 2 . 3)                                ; => (1 2 . 3)
  '(1 . #1=(2 3 . #1#))                     ; => (1 2 3 . #1)
  #+END_SRC

  #+BEGIN_EXAMPLE
    可以看出前两种列表的读入语法和输出形式都是相同的，而环形列表的读入语法是很古怪的，输出形式不能作为环形列表的读入形式
  #+END_EXAMPLE

  如果把真列表最后一个 cons cell 的 nil 省略不写，也就是 (1 . nil) 简写成 (1)，把 ( obj1 . ( obj2 . list)) 简写成 (obj1 obj2 . list)，那么列表最后可以写成一个用括号括起的元素列表：

  #+BEGIN_SRC lisp 
  '(1 . (2 . (3 . nil)))                  ; => (1 2 3)
  #+END_SRC

  #+BEGIN_EXAMPLE
    尽管这样写是清爽多了，但是，看一个列表时还是在脑子里反映的前面的形式，这样在和复杂的 cons cell 打交道时就不会搞不清楚这个 cons cell 的 CDR 是一个列表呢，还是一个元素或者是嵌套的列表 
  #+END_EXAMPLE

* 测试
  测试一个对象是否是 cons cell 用 _consp_ ，是否是列表用 _listp_ 

  #+BEGIN_SRC lisp 
  (consp '(1 . 2))                        ; => t
  (consp '(1 . (2 . nil)))                ; => t
  (consp nil)                             ; => nil
  (listp '(1 . 2))                        ; => t
  (listp '(1 . (2 . nil)))                ; => t
  (listp nil)                             ; => t
  #+END_SRC

  #+BEGIN_EXAMPLE
    没有内建的方法测试一个列表是不是一个真列表

    通常如果一个函数需要一个真列表作为参数，都是在运行时发出错误，而不是进行参数检查，因为检查一个列表是真列表的代价比较高
  #+END_EXAMPLE

  测试一个对象是否是 nil 用 _null_ 函数。只有当对象是空表时，null 才返回空值 

* 构造
  生成一个 cons cell 可以用 _cons_ 函数。比如：

  #+BEGIN_SRC lisp 
  (cons 1 2)                              ; => (1 . 2)
  (cons 1 '())                            ; => (1)
  #+END_SRC

  这也是在 _列表_ 前面 *增加* _元素_ 的方法。比如：

  #+BEGIN_SRC lisp 
  (setq foo '(a b))                       ; => (a b)
  (cons 'x foo)                           ; => (x a b)
  #+END_SRC

  #+BEGIN_EXAMPLE
    注意：例子的 foo 值并没有改变，返回的是一个新建的列表
  #+END_EXAMPLE

  一个宏 _push_ 可以加入元素的同时改变列表的值：

  #+BEGIN_SRC lisp 
  (push 'x foo)                           ; => (x a b)
  foo                                     ; => (x a b)
  #+END_SRC

  生成一个列表的函数是 _list_ 。比如： 

  #+BEGIN_SRC lisp 
  (list 1 2 3)                            ; => (1 2 3)
  #+END_SRC

  #+BEGIN_EXAMPLE
    可能这时有一个疑惑，前面产生一个列表，常用 quote（也就是 ' 符号）这个函数，它和这个 cons 和 list 函数有什么区别呢？
  #+END_EXAMPLE
  其实区别是很明显的：
  + quote 是把参数直接返回不进行求值
  + list 和 cons 是对参数求值后再生成一个列表或者 cons cell

  #+BEGIN_SRC lisp 
  '((+ 1 2) 3)                            ; => ((+ 1 2) 3)
  (list (+ 1 2) 3)                        ; => (3 3)
  #+END_SRC

  #+BEGIN_EXAMPLE
    前一个生成的列表的 CAR 部分是 (+ 1 2) 这个列表，而后一个是先对 (+ 1 2) 求值得到 3 后再生成列表
  #+END_EXAMPLE

  前面提到在列表前端增加元素的方法是用 cons，在列表后端增加元素的函数是用 _append_ 。比如：

  #+BEGIN_SRC lisp 
  (append '(a b) '(c))                    ; => (a b c)
  #+END_SRC

  append 的功能可以认为它是把第一个参数最后一个列表的 nil 换成第二个参数
  #+BEGIN_SRC lisp 
  比如前面这个例子，第一个参数写成 cons cell 表示方式是(a . (b . nil))，把这个 nil 替换成 (c) 就成了 (a . (b . (c)))
  #+END_SRC

  对于多个参数的情况也是一样的，依次把下一个参数替换新列表最后一个 nil 就是最后的结果了：

  #+BEGIN_SRC lisp 
  (append '(a b) '(c) '(d))               ; => (a b c d)
  #+END_SRC

  一般来说 append 的参数都要是列表，但是最后一个参数可以不是一个列表，这也不违背前面说的，因为 cons cell 的 CDR 部分本来就可以是任何对象：

  #+BEGIN_SRC lisp 
  (append '(a b) 'c)                      ; => (a b . c)
  #+END_SRC
  这样得到的结果就不再是一个真列表了，如果再进行 append 操作就会产生一个错误

  #+BEGIN_EXAMPLE
    如果写过 c 的链表类型，可能就知道如果链表只保留一个指针，那么链表只能在一端增加元素

    elisp 的列表类型也是类似的，用 cons 在列表前增加元素比用 append 要快得多
  #+END_EXAMPLE

  append 的参数不限于列表，还可以是 _字符串_ 或者 _向量_ 。前面字符串里已经提到可以把一个字符串转换成一个字符列表，同样可能把向量转换成一个列表：

  #+BEGIN_SRC lisp 
  (append [a b] "cd" nil)                 ; => (a b 99 100)
  #+END_SRC

* 数组
  通过使用 elisp 提供的函数，事实上是可以把列表当 _数组_ 来用。依惯例，用 car 来访问列表的第一个元素， _cadr_ 来访问第二个元素，再往后就没有这样的函数了，可以用 _nth_ 函数来访问：

  #+BEGIN_SRC lisp 
  (nth 3 '(0 1 2 3 4 5))                  ; => 3
  #+END_SRC

  获得列表一个区间的函数有 nthcdr、last 和 butlast。 nthcdr 和 last 比较类似，它们都是返回列表后端的列表。 _nthcdr_ 函数返回 *第 n 个元素后* 的列表：

  #+BEGIN_SRC lisp 
  (nthcdr 2 '(0 1 2 3 4 5))               ; => (2 3 4 5)
  #+END_SRC

  _last_ 函数返回 *倒数 n 个* 长度的列表：
  #+BEGIN_SRC lisp 
  (last '(0 1 2 3 4 5) 2)                 ; => (4 5)
  #+END_SRC

  _butlast_ 和前两个函数不同，返回的 *除了倒数 n 个元素* 的列表：
  #+BEGIN_SRC lisp 
  (butlast '(0 1 2 3 4 5) 2)              ; => (0 1 2 3)
  #+END_SRC

  #+BEGIN_EXAMPLE
    使用前面这几个函数访问列表是没有问题了。但是链表这种数据结构是不适合随机访问的，代价比较高

    如果代码中频繁使用这样的函数或者对一个很长的列表使用这样的函数，就应该考虑是不是应该用数组来实现
  #+END_EXAMPLE

* 修改
  #+BEGIN_EXAMPLE
    直到现在为止，用到的函数都不会修改一个已有的变量。这是函数式编程的一个特点

    只用这些函数编写的代码是很容易调试的，因为不用去考虑一个变量在执行一个代码后就改变了，不用考虑变量的引用情况等等

    然而有时候这么做代码会比较繁琐，效率可能也比较差
  #+END_EXAMPLE

  _setcar_ 和 _setcdr_ 可以修改一个 cons cell 的 CAR 部分和 CDR 部分：

  #+BEGIN_SRC lisp 
  (setq foo '(a b c))                     ; => (a b c)
  (setcar foo 'x)                         ; => x
  foo                                     ; => (x b c)
  (setcdr foo '(y z))                     ; => (y z)
  foo                                     ; => (x y z)
  #+END_SRC

  #+BEGIN_EXAMPLE
    好像很简单是吧，下面代码运行后 foo 是什么东西呢？

    (setq foo '(a b c))                     ; => (a b c)
    (setcdr foo foo)
  #+END_EXAMPLE

  使用 setcar 和 nthcdr 的组合就可以实现像数组那样直接修改列表：
  #+BEGIN_SRC lisp 
  (setq foo '(1 2 3))                     ; => (1 2 3)
  (setcar foo 'a)                         ; => a
  (setcar (cdr foo) 'b)                   ; => b
  (setcar (nthcdr 2 foo) 'c)              ; => c
  foo                                     ; => (a b c)
  #+END_SRC

* 堆栈
  前面提到过可以用 push 向列表头端增加元素，在结合 _pop_ 宏，列表就可以做为一个堆栈了：
  #+BEGIN_SRC lisp 
  (setq foo nil)                          ; => nil
  (push 'a foo)                           ; => (a)
  (push 'b foo)                           ; => (b a)
  (pop foo)                               ; => b
  foo                                     ; => (a)
  #+END_SRC

* 排序
  #+BEGIN_EXAMPLE
    如果一直用 push 往列表里添加元素有一个问题：这样得到的列表和加入的顺序是相反的
  #+END_EXAMPLE

  如果需要得到一个反向的列表。 _reverse_ 函数可以做到这一点：
  #+BEGIN_SRC lisp 
  (setq foo '(a b c))                     ; => (a b c)
  (reverse foo)                           ; => (c b a)
  #+END_SRC

  #+BEGIN_EXAMPLE
    需要注意的是使用 reverse 后 foo 值并没有改变
  #+END_EXAMPLE
  函数 nreverse 也能和前面的 reverse 一样返回一个逆序的列表，他们的差别就在于它是一个有破坏性的函数，也就是说它会修改它的参数：

  #+BEGIN_SRC lisp 
  (nreverse foo)                          ; => (c b a)
  foo                                     ; => (a)
  #+END_SRC

  #+BEGIN_EXAMPLE
    为什么现在 foo 指向的是列表的末端呢？

    如果实现过链表就知道，逆序操作是可以在原链表上进行的，这样原来头部指针会变成链表的尾端。列表也是（应该是，我也没有看过实现）这个原理

    使用 nreverse 的唯一的好处是速度快，省资源。所以如果只是想得到逆序后的列表就放心用 nreverse，否则还是用 reverse 的好
  #+END_EXAMPLE

  elisp 还有一些是具有 *破坏性* 的函数。最常用的就是 _sort_ 函数：
  #+BEGIN_SRC lisp 
  (setq foo '(3 2 4 1 5))                 ; => (3 2 4 1 5)
  (sort foo '<)                           ; => (1 2 3 4 5)
  foo                                     ; => (3 4 5)
  #+END_SRC

  #+BEGIN_EXAMPLE
    这一点请一定要记住， sort 函数上很容易犯错！！！　

    那如果既要保留原列表，又要进行 sort 操作怎么办呢？

    可以使用 copy-sequence 函数：这个函数只对列表进行复制，返回的列表的元素还是原列表里的元素，不会拷贝列表的元素
  #+END_EXAMPLE

  + _nconc_ 和 append 功能相似，但是它会修改除最后一个参数以外的所有的参数
  + _nbutlast_ 和 butlast 功能相似，也会修改参数

  #+BEGIN_EXAMPLE
    这些函数都是在效率优先时才使用。总而言之，以 n 开头的函数都要慎用
  #+END_EXAMPLE

* 集合

* 关联表

* 树

* 遍历

* 其他

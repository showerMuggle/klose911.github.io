#+TITLE: Persistent Volume
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../../css/main.css" />
#+HTML_LINK_UP: volume.html
#+HTML_LINK_HOME: storage.html
#+OPTIONS: num:nil timestamp:nil ^:nil

接下来介绍 Kubernetes 中 PersistentVolume 的当前状态

#+begin_example
  建议先熟悉 Volume
#+end_example
* 介绍
  #+begin_example
    对于管理计算资源来说，管理存储资源明显是另一个问题
  #+end_example

  _PersistentVolume_ 子系统为用户和管理员提供了一个 API，该 API 将如何提供存储的细节抽象了出来。为此，引入两个新的 API 资源： _PersistentVolume_  和 _PersistentVolumeClaim_ ：
  + PersistentVolume _PV_ 是由 *管理员设置的存储* ，它是群集的一部分：
    + 就像节点是集群中的资源一样，PV 也是集群中的资源
    + PV 是 Volume 之类的卷插件，但具有独立于使用 PV 的 Pod 的生命周期
    + 此 API 对象包含存储实现的细节，即 NFS、iSCSI 或特定于云供应商的存储系统
  + PersistentVolumeClaim _PVC_ 是 *用户存储的请求* 。它与 Pod 相似：
    + Pod 消耗节点资源，PVC 消耗 PV 资源
    + Pod 可以请求特定级别的资源（CPU 和内存）。PVC 可以请求特定的大小和访问模式
      #+begin_example
	例如，可以以读/写一次或 只读多次模式挂载
      #+end_example

    虽然 PersistentVolumeClaims 允许用户使用抽象存储资源，但用户需要具有不同性质（例如性能）的 PersistentVolume 来解决不同的问题
  #+begin_example
    集群管理员需要能够提供各种各样的 PersistentVolume，这些PersistentVolume 的大小和访问模式可以各有不同，但不需要向用户公开实现这些卷的细节

    对于这些需求，StorageClass 资源可以实现
  #+end_example
* 生命周期
  PV 属于集群中的资源。PVC 是对这些资源的请求，也作为对资源的请求的检查。 PV 和 PVC 之间的相互作用遵循这样的生命周期：
** 配置
   有两种方式来配置 PV： _静态_ 或 _动态_ 
*** 静态
    集群管理员创建一些 PV。它们带有可供群集用户使用的实际存储的细节。它们存在于 Kubernetes API 中，可用于消费
*** 动态
    根据 StorageClasses，当管理员创建的静态 PV 都不匹配用户的 PersistentVolumeClaim 时，集群可能会尝试动态地为 PVC 创建卷 
** 绑定
   1. 在 _动态_ 配置的情况下，用户创建或已经创建了具有特定存储量的 PersistentVolumeClaim 以及某些访问模式
   2. _master_ 中的 _控制环路_ *监视* 新的 _PVC_ ，寻找匹配的 PV（如果可能），并将它们 *绑定* 在一起：
      + 如果为新的 PVC 动态调配 PV，则该环路将始终将该 PV *绑定* 到 PVC
      + 否则，用户总会得到他们所请求的存储，但是容量可能超出要求的数量
   3. 一旦 PV 和 PVC 绑定后，PersistentVolumeClaim 绑定是 *排他性* 的，不管它们是如何绑定的。 PVC 跟 PV 绑定是 _一对一_ 的映射 

   #+begin_example
     如果没有匹配的卷，声明将无限期地保持未绑定状态
   #+end_example

   随着匹配卷的可用，声明将被绑定

   #+begin_example
     例如，配置了许多 50Gi PV的集群将不会匹配请求 100Gi 的PVC

     将100Gi PV 添加到群集时，可以绑定 PVC
   #+end_example
** PVC 保护
   PVC _保护_ 的目的是确保由 pod *正在使用的 PVC 不会从系统中移除* ，因为如果被移除的话可能会导致数据丢失。

   #+begin_example
     注意：当 pod 状态为 Pending 并且 pod 已经分配给节点或 pod 为 Running 状态时，PVC 处于活动状态
   #+end_example

   当启用PVC 保护 功能时，如果用户删除了一个 pod 正在使用的 PVC，则该 PVC 不会被立即删除
   #+begin_example
     PVC 的删除将被推迟，直到 PVC 不再被任何 pod 使用
   #+end_example

   可以看到，当 PVC 的状态为 _Teminatiing_ 时，PVC 受到保护，Finalizers 列表中包含 _kubernetes.io/pvc-protection_ ：

   #+begin_src sh 
     $ kubectl described pvc hostpath
     Name:          hostpath
     Namespace:     default
     StorageClass:  example-hostpath
     Status:        Terminating
     Volume:        
     Labels:        <none>
     Annotations:   volume.beta.kubernetes.io/storage-class=example-hostpath
     volume.beta.kubernetes.io/storage-provisioner=example.com/hostpath
     Finalizers:    [kubernetes.io/pvc-protection]
     ...
   #+end_src
** 回收
   用户用完 volume 后，可以从允许回收资源的 API 中删除 PVC 对象。PersistentVolume 的 _回收策略_ 告诉集群在 _存储卷声明_ *释放* 后应如何处理该卷。目前，volume 的处理策略有 _保留_ 、 _回收_ 或 _删除_
*** 保留
    保留回收策略允许手动回收资源
    #+begin_example
      当 PersistentVolumeClaim 被删除时，PersistentVolume 仍然存在，volume 被视为“已释放”

      但是由于前一个声明人的数据仍然存在，所以还不能马上进行其他声明
    #+end_example

    管理员可以通过以下步骤手动回收卷：
    1. 删除 PersistentVolume。在删除 PV 后，外部基础架构中的关联存储资产仍然存在
       #+begin_example
	 如 AWS EBS、GCE PD、Azure Disk 或 Cinder 卷
       #+end_example
    2. 手动清理相关存储资产上的数据
    3. 手动删除关联的存储资产，或者如果要重新使用相同的存储资产，请使用存储资产定义创建新的 PersistentVolume 
*** 回收
    如果存储卷插件支持，回收策略会在 volume上执行基本擦除 _rm -rf / thevolume/*_ ，可被再次声明使用。但是，管理员可以使用如此处所述的 Kubernetes controller manager 命令行参数来配置 _自定义回收站 pod 模板_ 。自定义回收站 pod 模板必须 *包含* _volumes_ ，如下面的示例所示：

    #+begin_example
      apiVersion: v1
      kind: Pod
      metadata:
	name: pv-recycler
	namespace: default
      spec:
	restartPolicy: Never
	volumes:
	- name: vol
	  hostPath:
	    path: /any/path/it/will/be/replaced
	containers:
	- name: pv-recycler
	  image: "k8s.gcr.io/busybox"
	  command: ["/bin/sh", "-c", "test -e /scrub && rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  && test -z \"$(ls -A /scrub)\" || exit 1"]
	  volumeMounts:
	  - name: vol
	    mountPath: /scrub
    #+end_example

    #+begin_example
      volumes 部分的自定义回收站模块中指定的特定路径将被替换为正在回收的卷的特定路径
    #+end_example
    
*** 删除
    对于支持删除回收策略的卷插件，删除操作将从 Kubernetes 中删除 PersistentVolume 对象，并删除外部基础架构中的关联存储资产

    #+begin_example
      如 AWS EBS、GCE PD、Azure Disk 或 Cinder 卷
    #+end_example

    动态配置的卷继承其 StorageClass，默认为 Delete

    #+begin_example
      管理员应该根据用户的期望来配置 StorageClass，否则就必须要在 PV 创建后进行编辑或修补
    #+end_example

** 扩展PVC 
   #+begin_example
     Kubernetes 1.8 增加了对扩展持久化存储卷的 Alpha 支持
   #+end_example
   以下持久化卷支持扩展持久化卷声明：
   + gcePersistentDisk
   + awsElasticBlockStore
   + Cinder
   + glusterfs
   + rbd
   #+begin_example
     管理员可以通过将 ExpandPersistentVolumes 特性门设置为true来允许扩展持久卷声明

     管理员还应该启用PersistentVolumeClaimResize 准入控制插件来执行对可调整大小的卷的其他验证
   #+end_example

   一旦 PersistentVolumeClaimResize 准入插件已打开，将只允许其 _allowVolumeExpansion_ 字段设置为 _true_ 的存储类进行大小调整

   #+begin_example
     kind: StorageClass
     apiVersion: storage.k8s.io/v1
     metadata:
       name: gluster-vol-default
     provisioner: kubernetes.io/glusterfs
     parameters:
       resturl: "http://192.168.10.100:8080"
       restuser: ""
       secretNamespace: ""
       secretName: ""
     allowVolumeExpansion: true
   #+end_example

   一旦功能门和前述准入插件打开后，用户就可以通过简单地编辑声明以请求更大的 PersistentVolumeClaim 卷。这反过来将触发 PersistentVolume 后端的卷扩展

   #+begin_example
     在任何情况下都不会创建新的 PersistentVolume 来满足声明

     Kubernetes 将尝试调整现有 volume 来满足声明的要求
   #+end_example

   对于扩展包含文件系统的卷，只有在 ReadWrite 模式下使用 PersistentVolumeClaim 启动新的 Pod 时，才会执行文件系统调整大小

   #+begin_example
     换句话说，如果正在扩展的卷在 pod 或部署中使用，则需要删除并重新创建要进行文件系统调整大小的pod
   #+end_example


   文件系统调整大小仅适用于以下文件系统类型：
   + XFS
   + Ext3、Ext4

   #+begin_example
     注意：扩展 EBS 卷是一个耗时的操作

     另外，每6个小时有一个修改卷的配额
   #+end_example

* 持久化卷类型


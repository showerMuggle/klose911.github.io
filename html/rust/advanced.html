<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>高阶内容</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="pattern.html"> UP </a>
 |
 <a accesskey="H" href="rust.html"> HOME </a>
</div><div id="content">
<h1 class="title">高阶内容</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org73d5c15">不安全 Rust</a>
<ul>
<li><a href="#orgd68e828">不安全的超级力量</a></li>
<li><a href="#org6ae519e">解引用裸指针</a></li>
<li><a href="#org39816da">调用不安全函数或方法</a>
<ul>
<li><a href="#orga94d504">创建不安全代码的安全抽象</a></li>
<li><a href="#org2c1a5b4">使用 extern 函数调用外部代码</a>
<ul>
<li><a href="#orge6cf4c6">从其它语言调用 Rust 函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge7a5d9c">访问或修改可变静态变量</a></li>
<li><a href="#org4ef2018">实现不安全 trait</a></li>
<li><a href="#org2f45392">何时使用不安全代码</a></li>
</ul>
</li>
</ul>
</div>
</div>
<pre class="example">
  现在已经学习了 Rust 编程语言中最常用的部分。接下来的功能在一些非常特定的场景下很有用处

  虽然很少会碰到它们，这会确保了解 Rust 提供的所有功能

</pre>
<p>
本章将涉及如下内容：
</p>
<ul class="org-ul">
<li>不安全 Rust：用于当需要舍弃 Rust 的某些保证并负责手动维持这些保证</li>
<li>高级 trait：与 trait 相关的关联类型，默认类型参数，完全限定语法，超父trait和 newtype 模式</li>
<li>高级类型：关于 newtype 模式的更多内容，类型别名，never 类型和动态大小类型</li>
<li>高级函数和闭包：函数指针和返回闭包</li>
<li>宏：定义在编译时定义更多代码的方式</li>
</ul>
<div id="outline-container-org73d5c15" class="outline-2">
<h2 id="org73d5c15">不安全 Rust</h2>
<div class="outline-text-2" id="text-org73d5c15">
<p>
目前为止讨论过的代码都有 Rust 在编译时会强制执行的内存安全保证。然而，Rust 还隐藏有第二种语言，它不会强制执行这类内存安全保证：这被称为 <span class="underline">不安全 Rust</span> 。它与常规 Rust 代码无异，但是会提供额外的超级力量
</p>
<ul class="org-ul">
<li>不安全 Rust 之所以存在，是因为静态分析本质上是保守的</li>
</ul>
<pre class="example">
    当编译器尝试确定一段代码是否支持某个保证时，拒绝一些有效的程序比接受无效程序要好一些

    这必然意味着有时代码可能是合法的，但是 Rust 不这么认为！

    在这种情况下，可以使用不安全代码告诉编译器，“相信我，我知道我在干什么。”

    这么做的缺点就是你只能靠自己了：如果不安全代码出错了，比如解引用空指针，可能会导致不安全的内存使用
</pre>
<ul class="org-ul">
<li>另一个 Rust 存在不安全一面的原因是：底层计算机硬件固有的不安全性</li>
</ul>
<pre class="example">
如果 Rust 不允许进行不安全操作，那么有些任务则根本完成不了

Rust 需要能够进行像直接与操作系统交互，甚至于编写自己的操作系统这样的底层系统编程！
</pre>

<p>
先看看不安全 Rust 能做什么，和怎么做
</p>
</div>
<div id="outline-container-orgd68e828" class="outline-3">
<h3 id="orgd68e828">不安全的超级力量</h3>
<div class="outline-text-3" id="text-orgd68e828">
<p>
可以通过 <span class="underline">unsafe</span> 关键字来切换到不安全 Rust，接着可以开启一个新的存放不安全代码的块。这里有几类可以在不安全 Rust 中进行而不能用于安全 Rust 的操作，它们称之为 “不安全的超级力量。” 这些超级力量是：
</p>
<ol class="org-ol">
<li>解引用裸指针</li>
<li>调用不安全的函数或方法</li>
<li>访问或修改可变静态变量</li>
<li>实现不安全 trait</li>
</ol>

<p>
有一点很重要，unsafe 并不会关闭 <span class="underline">借用检查器</span> 或禁用任何 <span class="underline">其他 Rust 安全检查</span> ：如果在不安全代码中使用引用，它仍会被检查
</p>

<pre class="example">
unsafe 关键字只是提供了那几个不会被编译器检查内存安全的功能

仍然能在不安全块中获得某种程度的安全
</pre>

<p>
再者，unsafe 不意味着块中的代码就一定是危险的或者必然导致内存安全问题：其意图在于作为程序员将会确保 unsafe 块中的代码以有效的方式访问内存
</p>
<pre class="example">
     人是会犯错误的，错误总会发生

     不过通过要求这类操作必须位于标记为 unsafe 的块中，就能够知道任何与内存安全相关的错误必定位于 unsafe 块内

     保持 unsafe 块尽可能小，如此当之后调查内存 bug 时就会感谢你自己了
</pre>
<p>
为了尽可能隔离不安全代码，将 <span class="underline">不安全代码</span> <b>封装</b> 进一个 <span class="underline">安全的抽象</span> 并 <b>提供</b> <span class="underline">安全 API</span> 是一个好主意
</p>

<pre class="example">
     标准库的一部分被实现为在被评审过的不安全代码之上的安全抽象

     这个技术防止了 unsafe 泄露到所有你或者用户希望使用由 unsafe 代码实现的功能的地方，因为使用其安全抽象是安全的
</pre>

<p>
接下来按顺序依次介绍上述几个超级力量，同时会看到一些提供不安全代码的安全接口的抽象
</p>
</div>
</div>
<div id="outline-container-org6ae519e" class="outline-3">
<h3 id="org6ae519e">解引用裸指针</h3>
<div class="outline-text-3" id="text-org6ae519e">
<pre class="example">
   回到前面的 “悬垂引用” 部分，那里提到了编译器会确保引用总是有效的
</pre>
<p>
不安全 Rust 有两个被称为 <span class="underline">裸指针</span> 的类似于引用的新类型。和引用一样，裸指针是 <span class="underline">可变</span> 或 <span class="underline">不可变</span> 的，分别写作 <span class="underline">*const T</span> 和 <span class="underline">*mut T</span> 
</p>
<ul class="org-ul">
<li>这里的 <span class="underline">星号</span> 不是解引用运算符；它是 <b>类型名称</b> 的一部分</li>
<li>在裸指针的上下文中，不可变意味着 <span class="underline">指针解引用</span> 之后 <b>不能直接</b> <span class="underline">赋值</span></li>
</ul>

<p>
与引用和智能指针的区别在于，记住裸指针：
</p>
<ul class="org-ul">
<li>允许忽略借用规则，可以同时拥有不可变和可变的指针，或多个指向相同位置的可变指针</li>
<li>不保证指向有效的内存</li>
<li>允许为空</li>
<li>不能实现任何自动清理功能</li>
</ul>

<pre class="example">
   通过去掉 Rust 强加的保证，可以放弃安全保证以换取性能或使用另一个语言或硬件接口的能力，此时 Rust 的保证并不适用
</pre>
<p>
下面展示了如何从引用同时创建不可变和可变裸指针：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">let</span> <span style="color: #00ffff;">mut</span> <span style="color: #eedd82;">num</span> = 5;

<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">r1</span> = &amp;num <span style="color: #00ffff;">as</span> *<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">i32</span>;
<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">r2</span> = &amp;<span style="color: #00ffff;">mut</span> num <span style="color: #00ffff;">as</span> *<span style="color: #00ffff;">mut</span> <span style="color: #98fb98;">i32</span>;
</pre>
</div>

<p>
注意：这里没有引入 unsafe 关键字。可以在 <span class="underline">安全代码</span> 中 <b>创建</b> 裸指针，只是 <b>不能</b> 在 <span class="underline">不安全块之外</span> <b>解引用</b> 裸指针
</p>

<pre class="example">
     这里使用 as 将不可变和可变引用强转为对应的裸指针类型

     因为直接从保证安全的引用来创建他们，可以知道这些特定的裸指针是有效，但是不能对任何裸指针做出如此假设

</pre>
<p>
接下来创建一个不能确定其有效性的裸指针，下面展示了如何创建一个指向任意内存地址的裸指针
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">let</span> <span style="color: #eedd82;">address</span> = 0x012345usize;
<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">r</span> = address <span style="color: #00ffff;">as</span> *<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">i32</span>;
</pre>
</div>

<pre class="example">
     尝试使用任意内存是未定义行为：此地址可能有数据也可能没有，编译器可能会优化掉这个内存访问，或者程序可能会出现段错误

     通常没有好的理由编写这样的代码，不过却是可行的
</pre>

<p>
对裸指针使用解引用运算符 *，这需要一个 unsafe 块：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">let</span> <span style="color: #00ffff;">mut</span> <span style="color: #eedd82;">num</span> = 5;

<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">r1</span> = &amp;num <span style="color: #00ffff;">as</span> *<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">i32</span>;
<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">r2</span> = &amp;<span style="color: #00ffff;">mut</span> num <span style="color: #00ffff;">as</span> *<span style="color: #00ffff;">mut</span> <span style="color: #98fb98;">i32</span>;

<span style="color: #ffc0cb; font-weight: bold;">unsafe</span> {
    <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"r1 is: </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, *r1);
    <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"r2 is: </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, *r2);
}
</pre>
</div>

<pre class="example">
     创建一个指针不会造成任何危险；只有当访问其指向的值时才有可能遇到无效的值
</pre>
<p>
示例创建了同时指向相同内存位置 num 的裸指针 *const i32 和 *mut i32
</p>
<ul class="org-ul">
<li>如果尝试创建 num 的不可变和可变引用，这将无法编译因为 Rust 的所有权规则不允许拥有可变引用的同时拥有不可变引用</li>
<li>通过裸指针，就能够同时创建同一地址的可变指针和不可变指针</li>
<li>若通过 <span class="underline">可变指针</span> <b>修改</b> 数据，则可能造成 <span class="underline">数据竞争</span></li>
</ul>

<pre class="example">
     既然存在这么多的危险，为何还要使用裸指针呢？

     一个主要的应用场景便是调用 C 代码接口

     另一个场景是构建借用检查器无法理解的安全抽象
</pre>
</div>
</div>
<div id="outline-container-org39816da" class="outline-3">
<h3 id="org39816da">调用不安全函数或方法</h3>
<div class="outline-text-3" id="text-org39816da">
<p>
不安全函数和方法与常规函数方法十分类似，除了其开头有一个额外的 <span class="underline">unsafe</span> 
</p>

<pre class="example">
     在此上下文中，关键字unsafe表示该函数具有调用时需要满足的要求，而 Rust 不会保证满足这些要求

     通过在 unsafe 块中调用不安全函数，表明已经阅读过此函数的文档并对其是否满足函数自身的契约负责
</pre>

<p>
如下是一个没有做任何操作的不安全函数 dangerous 的例子：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #ffc0cb; font-weight: bold;">unsafe</span> <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">dangerous</span>() {}

<span style="color: #ffc0cb; font-weight: bold;">unsafe</span> {
    dangerous();
}
</pre>
</div>

<p>
必须在一个单独的 unsafe 块中调用 dangerous 函数。如果尝试不使用 unsafe 块调用 dangerous，则会得到一个错误：
</p>
<div class="org-src-container">
<pre class="src src-sh">error[E0133]: call to unsafe <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">requires</span> unsafe <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">or</span> block
 --&gt;
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe <span style="color: #00ffff;">function</span>
</pre>
</div>

<pre class="example">
     通过将 dangerous 调用插入 unsafe 块中，就向 Rust 保证了已经阅读过函数的文档，理解如何正确使用，并验证过其满足函数的契约
</pre>
<p>
不安全函数体也是有效的 unsafe 块，所以在不安全函数中进行另一个不安全操作时无需新增额外的 unsafe 块
</p>
</div>
<div id="outline-container-orga94d504" class="outline-4">
<h4 id="orga94d504">创建不安全代码的安全抽象</h4>
<div class="outline-text-4" id="text-orga94d504">
<p>
仅仅因为函数包含不安全代码并不意味着整个函数都需要标记为不安全的。事实上，将不安全代码封装进安全函数是一个常见的抽象。作为一个例子，标准库中的函数，split_at_mut，它需要一些不安全代码，这个安全函数定义于可变 slice 之上：它获取一个 slice 并从给定的索引参数开始将其分为两个 slice。split_at_mut 的用法：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">let</span> <span style="color: #00ffff;">mut</span> <span style="color: #eedd82;">v</span> = <span style="color: #7fffd4;">vec!</span>[1, 2, 3, 4, 5, 6];

<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">r</span> = &amp;<span style="color: #00ffff;">mut</span> v[..];

<span style="color: #00ffff;">let</span> (a, b) = r.split_at_mut(3);

<span style="color: #7fffd4;">assert_eq!</span>(a, &amp;<span style="color: #00ffff;">mut</span> [1, 2, 3]);
<span style="color: #7fffd4;">assert_eq!</span>(b, &amp;<span style="color: #00ffff;">mut</span> [4, 5, 6]);
</pre>
</div>

<p>
这个函数无法只通过安全 Rust 实现。一个尝试可能看起来像示例，然而它不能编译。出于简单考虑，将 split_at_mut 实现为函数而不是方法，并只处理 i32 值而非泛型 T 的 slice：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">split_at_mut</span>(<span style="color: #eedd82;">slice</span>: &amp;<span style="color: #00ffff;">mut</span> [<span style="color: #98fb98;">i32</span>], <span style="color: #eedd82;">mid</span>: <span style="color: #98fb98;">usize</span>) -&gt; (&amp;<span style="color: #00ffff;">mut</span> [<span style="color: #98fb98;">i32</span>], &amp;<span style="color: #00ffff;">mut</span> [<span style="color: #98fb98;">i32</span>]) {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">len</span> = slice.len();

    <span style="color: #7fffd4;">assert!</span>(mid &lt;= len);

    (&amp;<span style="color: #00ffff;">mut</span> slice[..mid],
     &amp;<span style="color: #00ffff;">mut</span> slice[mid..])
}
</pre>
</div>

<ol class="org-ol">
<li>此函数首先获取 slice 的长度</li>
<li>通过检查参数是否小于或等于这个长度来断言参数所给定的索引位于 slice 当中：该断言意味着如果传入的索引比要分割的 slice 的索引更大，此函数在尝试使用这个索引前 panic</li>
<li>在一个元组中返回两个可变的 slice：一个从原始 slice 的开头直到 mid 索引，另一个从 mid 直到原 slice 的结尾</li>
</ol>

<p>
如果尝试编译的，会得到一个错误：
</p>

<div class="org-src-container">
<pre class="src src-sh">error[E0499]: cannot borrow <span style="color: #fa8072;">`*slice`</span> as mutable more than once at a time
 --&gt;
  |
6 |     (&amp;mut slice[..mid],
  |           ----- first mutable borrow occurs here
7 |      &amp;mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
8 | }
  | - first borrow ends here
</pre>
</div>

<p>
Rust 的借用检查器不能理解要借用这个 slice 的两个不同部分：它只知道我们借用了同一个 slice 两次
</p>

<pre class="example">
      本质上借用 slice 的不同部分是可以的，因为结果两个 slice 不会重叠，不过 Rust 还没有智能到能够理解这些

      当我们知道某些事是可以的而 Rust 不知道的时候，就是触及不安全代码的时候了
</pre>
<p>
下面展示了如何使用 unsafe 块，裸指针和一些不安全函数调用来实现 split_at_mut：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::slice;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">split_at_mut</span>(<span style="color: #eedd82;">slice</span>: &amp;<span style="color: #00ffff;">mut</span> [<span style="color: #98fb98;">i32</span>], <span style="color: #eedd82;">mid</span>: <span style="color: #98fb98;">usize</span>) -&gt; (&amp;<span style="color: #00ffff;">mut</span> [<span style="color: #98fb98;">i32</span>], &amp;<span style="color: #00ffff;">mut</span> [<span style="color: #98fb98;">i32</span>]) {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">len</span> = slice.len();
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">ptr</span> = slice.as_mut_ptr();

    <span style="color: #7fffd4;">assert!</span>(mid &lt;= len);

    <span style="color: #ffc0cb; font-weight: bold;">unsafe</span> {
        (<span style="color: #7fffd4;">slice</span>::from_raw_parts_mut(ptr, mid),
         <span style="color: #7fffd4;">slice</span>::from_raw_parts_mut(ptr.offset(mid <span style="color: #00ffff;">as</span> <span style="color: #98fb98;">isize</span>), len - mid))
    }
}
</pre>
</div>

<p>
slice 是一个指向一些数据的指针，并带有该 slice 的长度。可以使用 len 方法获取 slice 的长度，使用 <span class="underline">as_mut_ptr</span> 方法访问 <b>slice 的裸指针</b> 
</p>

<pre class="example">
    在这个例子中，因为有一个 i32 值的可变 slice，as_mut_ptr 返回一个 *mut i32 类型的裸指针，储存在 ptr 变量中
</pre>
<p>
保持索引 mid 位于 slice 中的断言。接着是不安全代码： <span class="underline">slice::from_raw_parts_mut</span>  函数获取一个裸指针和一个长度来 <b>创建</b> 一个 slice：
</p>
<ul class="org-ul">
<li>使用此函数从 ptr 中创建了一个有 mid 个项的 slice</li>
<li>在 ptr 上调用 offset 方法并使用 mid 作为参数来获取一个从 mid 开始的裸指针，使用这个裸指针并以 mid 之后项的数量为长度创建一个 slice</li>
</ul>

<pre class="example">
slice::from_raw_parts_mut 函数是不安全的因为它获取一个裸指针，并必须确信这个指针是有效的

裸指针上的 offset 方法也是不安全的，因为其必须确信此地址偏移量也是有效的指针

因此必须将 slice::from_raw_parts_mut 和 offset 放入 unsafe 块中以便能调用它们

通过观察代码，和增加 mid 必然小于等于 len 的断言，可以说 unsafe 块中所有的裸指针将是有效的 slice 中数据的指针。这是一个可以接受的 unsafe 的恰当用法
</pre>

<p>
注意：无需将 split_at_mut 函数的结果标记为 unsafe，并可以在安全 Rust 中调用此函数。因为创建了一个不安全代码的安全抽象，其代码以一种安全的方式使用了 unsafe 代码，其只从这个函数访问的数据中创建了有效的指针
</p>

<p>
与此相对，下面示例中的 slice::from_raw_parts_mut 在使用 slice 时很有可能会崩溃。这段代码获取任意内存地址并创建了一个长为一万的 slice：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::slice;

<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">address</span> = 0x01234usize;
<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">r</span> = address <span style="color: #00ffff;">as</span> *<span style="color: #00ffff;">mut</span> <span style="color: #98fb98;">i32</span>;

<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">slice</span>: &amp;[<span style="color: #98fb98;">i32</span>] = <span style="color: #ffc0cb; font-weight: bold;">unsafe</span> {
    <span style="color: #7fffd4;">slice</span>::from_raw_parts_mut(r, 10000)
};
</pre>
</div>

<p>
并不拥有这个任意地址的内存，也不能保证这段代码创建的 slice 包含有效的 i32 值。试图使用臆测为有效的 slice 会导致未定义的行为
</p>
</div>
</div>
<div id="outline-container-org2c1a5b4" class="outline-4">
<h4 id="org2c1a5b4">使用 extern 函数调用外部代码</h4>
<div class="outline-text-4" id="text-org2c1a5b4">
<p>
有时 Rust 代码可能需要与其他语言编写的代码交互。为此 Rust 有一个关键字 <span class="underline">extern</span> ，有助于创建和使用外部函数接口。外部函数接口是一个编程语言用以定义函数的方式，其允许不同（外部）编程语言调用这些函数。下面示例展示了如何集成 C 标准库中的 abs 函数：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">extern</span> <span style="color: #ffa07a;">"C"</span> {
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">abs</span>(<span style="color: #eedd82;">input</span>: <span style="color: #98fb98;">i32</span>) -&gt; <span style="color: #98fb98;">i32</span>;
}

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #ffc0cb; font-weight: bold;">unsafe</span> {
        <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"Absolute value of -3 according to C: </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, abs(-3));
    }
}
</pre>
</div>

<pre class="example">
extern 块中声明的函数在 Rust 代码中总是不安全的

因为其他语言不会强制执行 Rust 的规则且 Rust 无法检查它们，所以确保其安全是程序员的责任
</pre>

<p>
在 extern "C" 块中，列出了希望能够调用的另一个语言中的外部函数的签名和名称
</p>

<pre class="example">
"C" 部分定义了外部函数所使用的 应用程序接口(application binary interface，ABI) 

ABI 定义了如何在汇编语言层面调用此函数，"C" ABI 是最常见的，并遵循 C 编程语言的 ABI
</pre>
</div>

<div id="outline-container-orge6cf4c6" class="outline-5">
<h5 id="orge6cf4c6">从其它语言调用 Rust 函数</h5>
<div class="outline-text-5" id="text-orge6cf4c6">
<p>
也可以使用 extern 来创建一个允许其他语言调用 Rust 函数的接口。不同于 extern 块，就在 fn 关键字之前增加 extern 关键字并指定所用到的 ABI。还需增加 <span class="underline">#[no_mangle]</span> 注解来告诉 Rust 编译器不要 mangle 此函数的名称
</p>

<pre class="example">
Mangling 发生于当编译器将指定的函数名修改为不同的名称时，这会增加用于其他编译过程的额外信息，不过会使其名称更难以阅读

每一个编程语言的编译器都会以稍微不同的方式 mangle 函数名，所以为了使 Rust 函数能在其他语言中指定，必须禁用 Rust 编译器的 name mangling
</pre>

<p>
在如下的例子中，一旦其编译为动态库并从 C 语言中链接，call_from_c 函数就能够在 C 代码中访问：
</p>


<div class="org-src-container">
<pre class="src src-rust"><span style="color: #7fffd4;">#[no_mangle]</span>
<span style="color: #00ffff;">pub</span> <span style="color: #00ffff;">extern</span> <span style="color: #ffa07a;">"C"</span> <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">call_from_c</span>() {
    <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"Just called a Rust function from C!"</span>);
}
</pre>
</div>
<p>
注意：extern 的使用无需 unsafe
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orge7a5d9c" class="outline-3">
<h3 id="orge7a5d9c">访问或修改可变静态变量</h3>
<div class="outline-text-3" id="text-orge7a5d9c">
<pre class="example">
     目前为止都尽量避免讨论 全局变量，Rust 确实支持他们，不过这对于 Rust 的所有权规则来说是有问题的

     如果有两个线程访问相同的可变全局变量，则可能会造成数据竞争
</pre>
<p>
全局变量在 Rust 中被称为 <span class="underline">静态</span> (static)变量。下面展示了一个拥有字符串 slice 值的静态变量的声明和应用：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">static</span> <span style="color: #eedd82;">HELLO_WORLD</span>: &amp;<span style="color: #98fb98;">str</span> = <span style="color: #ffa07a;">"Hello, world!"</span>;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"name is: </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, <span style="color: #98fb98;">HELLO_WORLD</span>);
}
</pre>
</div>

<p>
static 变量类似于开头讨论的常量。通常静态变量的名称采用 SCREAMING_SNAKE_CASE 写法，并 <b>必须</b> 标注 <span class="underline">变量的类型</span> ，在这个例子中是 &amp;'static str：
</p>
<ul class="org-ul">
<li>静态变量只能储存拥有 <span class="underline">'static</span> <b>生命周期的引用</b> ，这意味着 Rust 编译器可以自己计算出其生命周期而无需显式标注</li>
<li>访问 <span class="underline">不可变</span> 静态变量是 <b>安全</b> 的</li>
</ul>

<p>
常量与不可变静态变量可能看起来很类似，不过一个微妙的区别是：
</p>
<ul class="org-ul">
<li><span class="underline">静态变量</span> 中的值有一个 <b>固定的内存地址</b> ，使用这个值总是会访问相同的地址</li>
<li><span class="underline">常量</span> 则允许在任何被用到的时候 <b>复制</b> 其 <span class="underline">数据</span></li>
</ul>

<p>
常量与静态变量的另一个区别在于 <span class="underline">静态变量</span> 可以是 <b>可变</b> 的。 <span class="underline">访问</span> 和 <span class="underline">修改</span> <b>可变</b> <span class="underline">静态变量</span> 都是 <b>不安全</b> 的。下面展示了如何声明、访问和修改名为 COUNTER 的可变静态变量：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">static</span> <span style="color: #00ffff;">mut</span> <span style="color: #eedd82;">COUNTER</span>: <span style="color: #98fb98;">u32</span> = 0;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">add_to_count</span>(<span style="color: #eedd82;">inc</span>: <span style="color: #98fb98;">u32</span>) {
    <span style="color: #ffc0cb; font-weight: bold;">unsafe</span> {
        <span style="color: #98fb98;">COUNTER</span> += inc;
    }
}

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    add_to_count(3);

    <span style="color: #ffc0cb; font-weight: bold;">unsafe</span> {
        <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"COUNTER: </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, <span style="color: #98fb98;">COUNTER</span>);
    }
}
</pre>
</div>

<p>
就像常规变量一样，使用 mut 关键来指定可变性。任何读写 COUNTER 的代码都必须位于 unsafe 块中。这段代码可以编译并如期打印出 COUNTER: 3，因为这是单线程的。拥有多个线程访问 COUNTER 则可能导致数据竞争
</p>

<pre class="example">
     拥有可以全局访问的可变数据，难以保证不存在数据竞争，这就是为何 Rust 认为可变静态变量是不安全的

     任何可能的情况，请优先使用并发技术和线程安全智能指针，这样编译器就能检测不同线程间的数据访问是否是安全的
</pre>
</div>
</div>

<div id="outline-container-org4ef2018" class="outline-3">
<h3 id="org4ef2018">实现不安全 trait</h3>
<div class="outline-text-3" id="text-org4ef2018">
<p>
最后一个只能用在 unsafe 中的操作是实现不安全 trait。当至少有一个方法中包含编译器不能验证的不变量时 trait 是不安全的。可以在 trait 之前增加 unsafe 关键字将 trait 声明为 unsafe，同时 trait 的实现也必须标记为 unsafe：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #ffc0cb; font-weight: bold;">unsafe</span> <span style="color: #00ffff;">trait</span> <span style="color: #98fb98;">Foo</span> {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">methods go here</span>
}

<span style="color: #ffc0cb; font-weight: bold;">unsafe</span> <span style="color: #00ffff;">impl</span> <span style="color: #98fb98;">Foo</span> <span style="color: #00ffff;">for</span> <span style="color: #98fb98;">i32</span> {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">method implementations go here</span>
}
</pre>
</div>

<p>
通过 unsafe impl，将保证编译器所不能验证的不变量
</p>

<pre class="example">
作为一个例子，回忆“使用 Sync 和 Send trait 的可扩展并发” 部分中的 Sync 和 Send 标记 trait，编译器会自动为完全由 Send 和 Sync 类型组成的类型自动实现他们

如果实现了一个包含一些不是 Send 或 Sync 的类型，比如裸指针，并希望将此类型标记为 Send 或 Sync，则必须使用 unsafe

Rust 不能验证我们的类型保证可以安全的跨线程发送或在多线程键访问，所以需要我们自己进行检查并通过 unsafe 表明
</pre>
</div>
</div>

<div id="outline-container-org2f45392" class="outline-3">
<h3 id="org2f45392">何时使用不安全代码</h3>
<div class="outline-text-3" id="text-org2f45392">
<p>
使用 unsafe 来进行这四个操作（超级力量）之一是没有问题的，甚至是不需要深思熟虑的
</p>

<pre class="example">
     不过使用 unsafe 代码正确也实属不易，因为编译器不能帮助保证内存安全

     当有理由使用 unsafe 代码时，是可以这么做的，通过使用显式的 unsafe 标注使得在出现错误时易于追踪问题的源头
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>

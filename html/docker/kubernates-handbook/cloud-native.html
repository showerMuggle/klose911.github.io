<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>云原生</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="kubernates-handbook.html"> UP </a>
 |
 <a accesskey="H" href="kubernates-handbook.html"> HOME </a>
</div><div id="content">
<h1 class="title">云原生</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb0c5e4b">定义</a>
<ul>
<li><a href="#org30bf855">Pivotal 最初的定义</a></li>
<li><a href="#orgcc996ed">CNCF 最初的定义</a></li>
<li><a href="#org30ad03c">重定义</a></li>
<li><a href="#orgf56259d">总结</a></li>
</ul>
</li>
<li><a href="#orgab434c0">设计哲学</a>
<ul>
<li><a href="#orga433cfe">设计理念</a></li>
<li><a href="#org221bb00">什么不是云原生基础设施？</a></li>
<li><a href="#org92912ff">云原生应用程序</a>
<ul>
<li><a href="#org40ff504">微服务</a></li>
<li><a href="#orgc5a255a">健康报告</a></li>
<li><a href="#orgdd5aba7">遥测数据</a></li>
<li><a href="#org5d86ed9">弹性</a>
<ul>
<li><a href="#org6f64113">为失败设计</a></li>
<li><a href="#orge9c0593">优雅降级</a></li>
</ul>
</li>
<li><a href="#orga7add2a">声明式，非反应式</a>
<ul>
<li><a href="#org61cd47b">Serverless</a></li>
</ul>
</li>
<li><a href="#org4e1eb8c">如何影响基础设施？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgba67276">Kubernetes 的诞生</a>
<ul>
<li><a href="#org5ff9510">Borg、Omega 和 Kubernetes</a></li>
</ul>
</li>
<li><a href="#org1a80b38">Kubernetes概览</a>
<ul>
<li><a href="#org4798cb4">发展历史</a>
<ul>
<li><a href="#org5a1bbc6">云计算介绍</a></li>
<li><a href="#org66f6d03">微服务介绍</a></li>
<li><a href="#org458b05c">云原生概念介绍</a></li>
</ul>
</li>
<li><a href="#orgebf84f0">Kubernetes与云原生的关系</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgb0c5e4b" class="outline-2">
<h2 id="orgb0c5e4b">定义</h2>
<div class="outline-text-2" id="text-orgb0c5e4b">
<p>
云原生（Cloud Native）这个词汇由来已久，以致于何时出现已无据可考
</p>

<pre class="example">
云原生开始大规模出现在受众视线中，与 Pivotal 提出的云原生应用的理念有着莫大的关系

现在谈到云原生，更多的指的是一种文化，而不具象为哪些技术体系

Pivotal 推出过 Pivotal Cloud Foundry 云原生应用平台和 Spring 开源 Java 开发框架，成为云原生应用架构中先驱者和探路者

Pivotal 是云原生应用平台第一股，2018 年在纽交所上市，2019 年底被 VMWare 以 27 亿美元收购，加入到 VMware 新的产品线 Tanzu
</pre>
</div>
<div id="outline-container-org30bf855" class="outline-3">
<h3 id="org30bf855">Pivotal 最初的定义</h3>
<div class="outline-text-3" id="text-org30bf855">
<p>
早在 2015 年 Pivotal 公司的 Matt Stine 写了一本叫做 <span class="underline">迁移到云原生应用架构</span> 的小册子，其中探讨了云原生应用架构的几个主要特征：
</p>
<ul class="org-ul">
<li>符合 12 因素应用</li>
<li>面向微服务架构</li>
<li>自服务敏捷架构</li>
<li>基于 API 的协作</li>
<li>抗脆弱性</li>
</ul>
</div>
</div>
<div id="outline-container-orgcc996ed" class="outline-3">
<h3 id="orgcc996ed">CNCF 最初的定义</h3>
<div class="outline-text-3" id="text-orgcc996ed">
<p>
到了 2015 年 Google 主导成立了 <span class="underline">云原生计算基金会</span> （CNCF），起初 CNCF 对云原生（Cloud Native）的定义包含以下三个方面：
</p>
<ul class="org-ul">
<li>应用容器化</li>
<li>面向微服务架构</li>
<li>应用支持 <b>容器的编排调度</b></li>
</ul>
</div>
</div>
<div id="outline-container-org30ad03c" class="outline-3">
<h3 id="org30ad03c">重定义</h3>
<div class="outline-text-3" id="text-org30ad03c">
<p>
到了 2018 年，随着近几年来云原生生态的不断壮大，所有主流云计算供应商都加入了该基金会，且从 Cloud Native Landscape 中可以看出云原生有意蚕食原先非云原生应用的部分。CNCF 基金会中的会员以及容纳的项目越来越多，该定义已经限制了云原生生态的发展，CNCF 为云原生进行了重新定位。以下是 CNCF 对云原生的重新定义（中英对照）：
</p>

<pre class="example">
Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach
</pre>
<p>
云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API
</p>

<pre class="example">
These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.
</pre>
<p>
这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更
</p>

<pre class="example">
The Cloud Native Computing Foundation seeks to drive adoption of this paradigm by fostering and sustaining an ecosystem of open source, vendor-neutral projects. We democratize state-of-the-art patterns to make these innovations accessible for everyone
</pre>

<p>
云原生计算基金会（CNCF）致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术。我们通过将最前沿的模式民主化，让这些创新为大众所用
</p>
</div>
</div>
<div id="outline-container-orgf56259d" class="outline-3">
<h3 id="orgf56259d">总结</h3>
<div class="outline-text-3" id="text-orgf56259d">
<pre class="example">
     关于什么是云原生的争论还在进行中，有种看法是云原生是一种行为方式和设计理念

     究其本质，凡是能够提高云上资源利用率和应用交付效率的行为或方式都是云原生的
</pre>
<p>
云计算的发展史就是一部云原生化的历史：
</p>
<ol class="org-ol">
<li>Kubernetes 开启了云原生 1.0 的序幕</li>
<li>服务网格 Istio 的出现，引领了后 Kubernetes 时代的微服务</li>
<li>serverless 的再次兴起，使得云原生从基础设施层不断向应用架构层挺进，我们正处于一个云原生 2.0 的新时代</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgab434c0" class="outline-2">
<h2 id="orgab434c0">设计哲学</h2>
<div class="outline-text-2" id="text-orgab434c0">
<pre class="example">
  云原生一词已经被过度的采用，很多软件都号称是云原生，很多打着云原生旗号的会议也如雨后春笋般涌现
</pre>
<p>
云原生本身甚至不能称为是一种架构，它首先是一种基础设施，运行在其上的应用称作云原生应用，只有符合云原生设计哲学的应用架构才叫云原生应用架构
</p>
</div>
<div id="outline-container-orga433cfe" class="outline-3">
<h3 id="orga433cfe">设计理念</h3>
<div class="outline-text-3" id="text-orga433cfe">
<p>
云原生系统的设计理念如下:
</p>
<ul class="org-ul">
<li>面向 <b>分布式</b> 设计 <span class="underline">Distribution</span> ：容器、微服务、API 驱动的开发</li>
<li>面向 <b>配置</b> 设计 <span class="underline">Configuration</span> ：一个镜像，多个环境配置</li>
<li>面向 <b>韧性</b> 设计 <span class="underline">Resistancy</span> ：故障容忍和自愈</li>
<li>面向 <b>弹性</b> 设计 <span class="underline">Elasticity</span> ：弹性扩展和对环境变化（负载）做出响应</li>
<li>面向 <b>交付</b> 设计 <span class="underline">Delivery</span> ：自动拉起，缩短交付时间</li>
<li>面向 <b>性能</b> 设计 <span class="underline">Performance</span> ：响应式，并发和资源高效利用</li>
<li>面向 <b>自动化</b> 设计 <span class="underline">Automation</span> ：自动化的 DevOps</li>
<li>面向 <b>诊断性</b> 设计 <span class="underline">Diagnosability</span> ：集群级别的日志、metric 和追踪</li>
<li>面向 <b>安全性</b> 设计 <span class="underline">Security</span> ：安全端点、API Gateway、端到端加密；</li>
</ul>

<pre class="example">
     以上的设计理念很多都是继承自分布式应用的设计理念，虽然有如此多的理念但是仍然无法辨认什么样的设施才是云原生基础设施

     不过可以先用排除法，先来解释什么不是云原生基础设施
</pre>
</div>
</div>
<div id="outline-container-org221bb00" class="outline-3">
<h3 id="org221bb00">什么不是云原生基础设施？</h3>
<div class="outline-text-3" id="text-org221bb00">
<p>
云原生基础设施不等于在公有云上运行的基础设施
</p>
<pre class="example">
     光是租用服务器并不会使您的基础设施云原生化

     管理 IaaS 的流程与运维物理数据中心没什么两样，将现有架构迁移到云上也未必能获得回报
</pre>

<p>
云原生不是指在容器中运行应用程序
</p>

<pre class="example">
Netflix 率先推出云原生基础设施时，几乎所有应用程序部署在虚拟机中，而不是在容器中
</pre>

<p>
改变应用程序的打包方式并不意味着就会增加自治系统的可扩展性和优势
</p>

<pre class="example">
   即使应用程序是通过 CI/CD 渠道自动构建和部署的，也不意味着您就可以从增强 API 驱动部署的基础设施中受益
</pre>

<p>
这也并不意味着您只能运行容器编排器（例如 Kubernetes 和 Mesos）
</p>

<pre class="example">
     术语 “调度器” 和 “编排器” 通常可以互换使用。在大多数情况下，编排器负责集群中的所有资源利用（例如：存储，网络和 CPU）。该术语典型地用于描述执行许多任务的产品，如健康检查和云自动化

     容器编排器提供了云原生基础设施所需的许多平台功能，但并未按预期方式使用这些功能：这意味着您的应用程序会在一组服务器上运行，被动态调度

     虽然这是一个非常好的起步，但仍有许多工作要做
</pre>

<p>
云原生不是微服务或基础设施即代码：
</p>

<pre class="example">
     微服务意味着更快的开发周期和更小的独特功能

     但是单片应用程序可以具有相同的功能，使其能够通过软件有效管理，并且还可以从云原生基础设施中受益
</pre>

<p>
基础设施即代码以机器可解析语言或领域特定语言（DSL）定义、自动化您的基础设施
</p>

<pre class="example">
     将代码应用于基础架构的传统工具包括配置管理工具（例如 Chef 和 Puppet）

     这些工具在自动执行任务和提供一致性方面有很大帮助，但是它们在提供必要的抽象来描述超出单个服务器的基础设施方面存在缺陷

     配置管理工具一次自动化一台服务器，并依靠人员将服务器提供的功能绑定在一起，这将人类定位为基础设施规模的潜在瓶颈

     这些工具也不会使构建完整系统所需的云基础设施（例如存储和网络）的额外部分自动化
</pre>

<p>
尽管配置管理工具为操作系统的资源（例如软件包管理器）提供了一些抽象，但它们并没有抽象出足够的底层操作系统来轻松管理它
</p>

<pre class="example">
     如果一位工程师想要管理系统中的每个软件包和文件，这将是一个非常艰苦的过程，并且对于每个配置变体都是独一无二的

     同样，定义不存在或不正确的资源的配置管理仅消耗系统资源并且不能提供任何价值
</pre>

<p>
虽然配置管理工具可以帮助自动化部分基础设施，但它们无法更好地管理应用程序
</p>

<pre class="example">
     在后面的章节中通过查看部署，管理，测试和操作基础架构的流程，探讨云原生基础设施的不同之处

     但首先，将了解哪些应用程序是成功的以及应该何时与原生基础设施一起使用
</pre>
</div>
</div>
<div id="outline-container-org92912ff" class="outline-3">
<h3 id="org92912ff">云原生应用程序</h3>
<div class="outline-text-3" id="text-org92912ff">
<p>
就像云改变了业务和基础设施之间的关系一样，云原生应用程序也改变了应用程序和基础设施之间的关系
</p>

<pre class="example">
   我们需要了解与传统应用程序相比，云本身有什么不同，因此我们需要了解它们与基础设施的新关系
</pre>

<p>
云原生应用程序被 <b>设计</b> 为在 <span class="underline">平台</span> 上运行，并设计用于 <span class="underline">弹性</span> ， <span class="underline">敏捷</span> 性， <span class="underline">可操作</span> 性和 <span class="underline">可观察</span> 性：
</p>
<ul class="org-ul">
<li>弹性包含失败而不是试图阻止它们；它利用了在平台上运行的动态特性</li>
<li>敏捷性允许快速部署和快速迭代</li>
<li>可操作性从应用程序内部控制应用程序生命周期，而不是依赖外部进程和监视器</li>
<li>可观察性提供信息来回答有关应用程序状态的问题</li>
</ul>

<pre class="example">
     云原生应用程序的定义仍在发展中。还有像 CNCF 这样的组织可以提供其他的定义
</pre>

<p>
云原生应用程序通过各种方法获取这些特征。它通常取决于应用程序的运行位置以及企业流程和文化。以下是实现云原生应用程序所需特性的常用方法：
</p>
<ul class="org-ul">
<li>微服务</li>
<li>健康报告</li>
<li>遥测数据</li>
<li>弹性</li>
<li>声明式的，而不是命令式的</li>
</ul>
</div>
<div id="outline-container-org40ff504" class="outline-4">
<h4 id="org40ff504">微服务</h4>
<div class="outline-text-4" id="text-org40ff504">
<p>
作为单个实体进行管理和部署的应用程序通常称为单体应用，最初开发应用程序时，单体有很多好处。它们更易于理解，并允许您在不影响其他服务的情况下更改主要功能
</p>
<pre class="example">
      随着应用程序复杂性的增长，单体应用的益处逐渐减少。它们变得更难理解，而且失去了敏捷性，因为工程师很难推断和修改代码
</pre>
<p>
对付复杂性的最好方法之一是将明确定义的功能分成更小的服务，并让每个服务独立迭代。这增加了应用程序的灵活性，允许根据需要更轻松地更改部分应用程序。每个微服务可以由单独的团队进行管理，使用适当的语言编写，并根据需要进行独立扩缩容。只要每项服务都遵守强有力的合约，应用程序就可以快速改进和改变
</p>

<pre class="example">
      拥有微服务并不意味着您拥有云原生基础设施，虽然微服务是实现您的应用程序灵活性的一种方式，但正如我们之前所说的，它们不是云原生应用程序的必需条件
</pre>
</div>
</div>
<div id="outline-container-orgc5a255a" class="outline-4">
<h4 id="orgc5a255a">健康报告</h4>
<div class="outline-text-4" id="text-orgc5a255a">
<pre class="example">
      没有人比开发人员更了解应用程序需要什么才能以健康的状态运行，然而很长一段时间，基础设施管理员都试图从他们负责运行的应用程序中找出 “健康” 该怎么定义

      如果不实际了解应用程序的健康状况，他们尝试在应用程序不健康时进行监控并发出警报，这往往是脆弱和不完整的
</pre>
<p>
为了提高云原生应用程序的可操作性，应用程序应该暴露健康检查。开发人员可以将其实施为命令或过程信号，以便应用程序在执行自我检查之后响应，或者更常见的是：通过应用程序提供 Web 服务，返回 HTTP 状态码来检查健康状态
</p>

<pre class="example">
Google 的 Borg 报告中列出了一个健康报告的例子：

几乎每个在 Borg 下运行的任务都包含一个内置的 HTTP 服务器，该服务器发布有关任务运行状况和数千个性能指标（如 RPC 延迟）的信息

Borg 会监控运行状况检查 URL 并重新启动不及时响应或返回 HTTP 错误代码的任务

其他数据由监控工具跟踪，用于仪表板和服务级别目标（SLO）违规警报
</pre>

<p>
将健康责任转移到应用程序中使应用程序更容易管理和自动化。应用程序应该知道它是否正常运行以及它依赖于什么（例如，访问数据库）来提供业务价值。这意味着开发人员需要与产品经理合作来定义应用服务的业务功能并相应地编写测试
</p>

<pre class="example">
    提供健康检查的应用程序示例包括 Zookeeper 的 ruok 命令和 etcd 的 HTTP / 健康端点
</pre>

<p>
应用程序不仅仅有健康或不健康的状态。它们将经历一个启动和关闭过程，在这个过程中它们应该通过健康检查，报告它们的状态。如果应用程序可以让平台准确了解它所处的状态，平台将更容易知道如何操作它。
</p>

<pre class="example">
      一个很好的例子就是当平台需要知道应用程序何时可以接收流量

      在应用程序启动时，如果它不能正确处理流量，它就应该表现为未准备好

      此额外状态将防止应用程序过早终止，因为如果运行状况检查失败，平台可能会认为应用程序不健康，并且会反复停止或重新启动它
</pre>

<p>
应用程序健康只是能够自动化应用程序生命周期的一部分
</p>

<pre class="example">
    除了知道应用程序是否健康之外，您还需要知道应用程序是否正在进行哪些工作。这些信息来自遥测数据
</pre>
</div>
</div>
<div id="outline-container-orgdd5aba7" class="outline-4">
<h4 id="orgdd5aba7">遥测数据</h4>
<div class="outline-text-4" id="text-orgdd5aba7">
<p>
遥测数据是进行决策所需的信息
</p>

<pre class="example">
      确实，遥测数据可能与健康报告重叠，但它们有不同的用途

      健康报告通知我们应用程序生命周期状态，而遥测数据通知我们应用程序业务目标
</pre>

<p>
测量的指标有时称为服务级指标（SLI）或关键性能指标（KPI）。这些是特定于应用程序的数据，可以确保应用程序的性能处于服务级别目标（SLO）内。遥测和度量标准用于解决以下问题：
</p>
<ul class="org-ul">
<li>应用程序每分钟收到多少请求？</li>
<li>有没有错误？</li>
<li>什么是应用程序延迟？</li>
<li>订购需要多长时间？</li>
</ul>

<p>
通常会将数据刮取或推送到时间序列数据库（例如 Prometheus 或 InfluxDB）进行聚合。遥测数据的唯一要求是它将被收集数据的系统格式化。至少，可能最好实施度量标准的 RED 方法，该方法收集应用程序的速率，错误和执行时间：
</p>
<ul class="org-ul">
<li>请求率：收到了多少个请求</li>
<li>错误：应用程序有多少错误</li>
<li>时间：多久才能收到回复</li>
</ul>

<p>
遥测数据应该用于提醒而非健康监测。在动态的、自我修复的环境中，更少关注单个应用程序实例的生命周期，更多关注关于整体应用程序 SLO 的内容
</p>
<pre class="example">
      健康报告对于自动应用程序管理仍然很重要，但不应该用于页面工程师

      如果 1 个实例或 50 个应用程序不健康，只要满足应用程序的业务需求，我们可能不会收到警报
</pre>

<p>
度量标准可让您知道您是否符合您的 SLO，应用程序的使用方式以及对于您的应用程序来说什么是 “正常”
</p>

<pre class="example">
    警报有助于您将系统恢复到已知的良好状态
</pre>

<p>
警报也不应该与日志记录混淆
</p>

<pre class="example">
    记录用于调试，开发和观察模式。它暴露了应用程序的内部功能
</pre>

<p>
度量有时可以从日志（例如错误率）计算，但需要额外的聚合服务（例如 ElasticSearch）和处理
</p>
</div>
</div>
<div id="outline-container-org5d86ed9" class="outline-4">
<h4 id="org5d86ed9">弹性</h4>
<div class="outline-text-4" id="text-org5d86ed9">
<pre class="example">
      一旦你有遥测和监测数据，你需要确保你的应用程序对故障有适应能力

      弹性是基础设施的责任，但云原生应用程序也需要承担部分工作
</pre>

<p>
基础设施被设计为抵制失败。硬件用于需要多个硬盘驱动器，电源以及全天候监控和部件更换以保持应用程序可用。使用云原生应用程序，应用程序有责任接受失败而不是避免失败。
</p>

<pre class="example">
在任何平台上，尤其是在云中，最重要的特性是其可靠性。

――David Rensin，e ARCHITECT Show：来自 Google 的关于云计算的速成课程
</pre>

<p>
将在云原生应用程序中考虑弹性的两个主要方面：为失败设计和优雅降级
</p>
</div>
<div id="outline-container-org6f64113" class="outline-5">
<h5 id="org6f64113">为失败设计</h5>
<div class="outline-text-5" id="text-org6f64113">
<p>
唯一永远不会失败的系统是那些让你活着的系统（例如心脏植入物和刹车系统）
</p>

<pre class="example">
       如果您的服务永远不会停止运行，您需要花费太多时间设计它们来抵制故障，并且没有足够的时间增加业务价值

       您的 SLO 确定服务需要多长时间。您花费在工程设计上超出 SLO 的正常运行时间的任何资源都将被浪费掉
</pre>

<p>
应该为每项服务测量两个值，即平均无故障时间（MTBF）和平均恢复时间（MTTR）。监控和指标可以让您检测您是否符合您的 SLO，但运行应用程序的平台是保持高 MTBF 和低 MTTR 的关键
</p>

<pre class="example">
       在任何复杂的系统中，都会有失败

       您可以管理硬件中的某些故障（例如，RAID 和冗余电源），以及某些基础设施中的故障（例如负载平衡器）

       但是因为应用程序知道他们什么时候健康，所以他们也应该尽可能地管理自己的失败
</pre>

<p>
设计一个以失败期望为目标的应用程序将比假定可用性的应用程序更具防御性。当故障不可避免时，将会有额外的检查，故障模式和日志内置到应用程序中
</p>

<pre class="example">
     知道应用程序可能失败的每种方式是不可能的。假设任何事情都可能并且可能会失败，这是一种云原生应用程序的模式
</pre>

<p>
您的应用程序的最佳状态是健康状态。第二好的状态是失败状态。其他一切都是非二进制的，难以监控和排除故障
</p>

<pre class="example">
Honeycomb 首席执行官 CharityMajors 在她的文章 “Ops：现在每个人都在工作” 中指出：“分布式系统永远不会起作用；它们处于部分退化服务的持续状态。接受失败，设计弹性，保护和缩小关键路径。”
</pre>

<p>
无论发生什么故障，云原生应用程序都应该是可适应的。他们期望失败，所以他们在检测到时进行调整
</p>

<pre class="example">
       有些故障不能也不应该被设计到应用程序中（例如，网络分区和可用区故障）

       该平台应自主处理未集成到应用程序中的故障域
</pre>
</div>
</div>

<div id="outline-container-orge9c0593" class="outline-5">
<h5 id="orge9c0593">优雅降级</h5>
<div class="outline-text-5" id="text-orge9c0593">
<p>
云原生应用程序需要有一种方法来处理过载，无论它是应用程序还是负载下的相关服务。处理负载的一种方式是优雅降级
</p>

<pre class="example">
       站点可靠性工程” 一书中描述了应用程序的优雅降级，因为它提供的响应在负载过重的情况下 “不如正常响应准确或含有较少数据的响应，但计算更容易”
</pre>

<p>
减少应用程序负载的某些方面由基础设施处理
</p>

<pre class="example">
       智能负载平衡和动态扩展可以提供帮助，但是在某些时候，您的应用程序可能承受的负载比它可以处理的负载更多

       云原生应用程序需要知道这种必然性并作出相应的反应
</pre>

<p>
优雅降级的重点是允许应用程序始终返回请求的答案
</p>

<pre class="example">
       如果应用程序没有足够的本地计算资源，并且依赖服务没有及时返回信息，则这是正确的

       依赖于一个或多个其他服务的服务应该可用于应答请求，即使依赖于服务不是

       当服务退化时，返回部分答案或使用本地缓存中的旧信息进行答案是可能的解决方案
</pre>

<p>
尽管优雅的降级和失败处理都应该在应用程序中实现，但平台的多个层面应该提供帮助。如果采用微服务，则网络基础设施成为需要在提供应用弹性方面发挥积极作用的关键组件
</p>
</div>

<ul class="org-ul">
<li><a id="orgc3b6642"></a>可用性数学<br />
<div class="outline-text-6" id="text-orgc3b6642">
<p>
云原生应用程序需要在基础设施之上建立一个平台，以使基础设施更具弹性。如果希望将现有应用程序 “提升并转移” 到云中，则应检查云提供商的服务级别协议（SLA），并考虑在使用多个服务时会发生什么情况
</p>

<pre class="example">
	让我们拿运行我们的应用程序的云来进行假设。

	计算基础设施的典型可用性是每月 99.95％的正常运行时间。这意味着您的实例每天可能会缩短到 43.2 秒，并且仍在您的云服务提供商的 SLA 中

	另外，实例的本地存储（例如 EBS 卷）也具有 99.95％的可用性正常运行时间。如果幸运的话，他们都会同时出现故障，但最糟糕的情况是他们可能会在不同的时间停机，让您的实例只有 99.9％的可用性

	您的应用程序可能还需要一个数据库，而不是自己安装一个计算可能的停机时间为 1 分 26 秒（99.9％可用性）的情况下，选择可靠性为 99.95％的更可靠的托管数据库。这使您的应用程序的可靠性达到 99.85％，或者每天可能发生 2 分钟和 9 秒的宕机时间

	将可用性乘到一起可以快速了解为什么应以不同方式处理云。真正不好的部分是，如果云提供商不符合其 SLA，它将退还其账单中一定比例的退款
</pre>

<p>
虽然您不必为停机支付费用，但我们并不知道世界上存在云计算信用的单一业务。如果您的应用程序的可用性不足以超过您收到的信用额度，那么您应该真正考虑是否应该运行这个应用程序
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-orga7add2a" class="outline-4">
<h4 id="orga7add2a">声明式，非反应式</h4>
<div class="outline-text-4" id="text-orga7add2a">
<p>
因为云原生应用程序被设计为在云环境中运行，所以它们与基础设施以及相关依赖应用程序的交互方式不同于传统应用程序。在云原生应用程序中，与任何事物的通信都需要通过网络来进行
</p>

<pre class="example">
      很多时候，网络通信是通过 RESTful HTTP 调用完成的，但是也可以通过其他接口实现，比如远程过程调用 (RPC)
</pre>

<p>
传统的应用程序会通过向消息队列发送消息、在共享存储上写入文件或触发本地 shell 脚本来执行自动化任务。通信方法基于发生的事件作出反应（例如，如果用户单击提交，运行提交脚本）并且通常需要存在于同一物理或虚拟服务器上的信息 
</p>

<pre class="example">
      传统应用程序中的反应式通信通常是构建弹性的一种尝试

      如果应用程序（以反应式的方式）在磁盘上或消息队列中写入了一个文件，然后应用程序死亡，那么该消息或文件的结果仍然可以完成
</pre>

<p>
这里并不是说不应该使用像消息队列这样的技术，而是说在动态且经常出现故障的系统中， 不能将它们作为 <b>惟一的弹性层</b> 来依赖
</p>

<pre class="example">
      从根本上说，在云原生环境之中，应用程序之间的通信方法应该有所变化 -

      这不仅是因为还存在其他方法来构建通信弹性，而是还因为如果要让传统的通信方法在云中实现复制，往往需要做更多工作
</pre>

<p>
当应用程序可以信任通信的弹性时，它们应该放弃反应式并使用声明式。声明式通信信任网络会将消息送达。它也相信应用程序将返回成功或错误
</p>

<pre class="example">
      这并不是说让应用程序观察变化不重要，Kubernetes 的控制器对 API 服务器做的就是这个

      但是，一旦发现变更，他们就会声明一个新的状态，并相信 API 服务器和 kubelets 会做必要的事情
</pre>

<p>
声明式通信模型由于多种原因而变得更加健壮。最重要的是，它规范了通信模型，并且它将（如何从某种状态到达期望状态的）功能实现从应用程序转移到远程 API 或服务端点。这有助于简化应用程序，并使它们彼此的行为更具可预测性 
</p>
</div>

<div id="outline-container-org61cd47b" class="outline-5">
<h5 id="org61cd47b">Serverless</h5>
<div class="outline-text-5" id="text-org61cd47b">
<p>
无服务器平台是云原生化的，并被设计为对事件做出反应
</p>

<pre class="example">
       他们在云中工作得很好的原因是他们通过 HTTP API 进行通信，（这些 API）是单一用途的函数，并且在它们的调用中是声明性的

       该平台还使它们可伸缩并可从云内访问
</pre>
</div>
</div>
</div>

<div id="outline-container-org4e1eb8c" class="outline-4">
<h4 id="org4e1eb8c">如何影响基础设施？</h4>
<div class="outline-text-4" id="text-org4e1eb8c">
<pre class="example">
      云原生应用程序不能直接在 PaaS 上运行或与服务器的操作系统紧密耦合

      它们期望在一个拥有大多数自治系统的动态环境中运行
</pre>

<p>
云原生基础设施在提供自主应用管理的 IaaS 之上创建了一个平台。该平台建立在动态创建的基础设施之上，以抽象出单个服务器并促进动态资源分配调度
</p>

<pre class="example">
      自动化与自治不一样。自动化使人类对他们所采取的行动产生更大的影响

      云原生是关于不需要人类做出决定的自治系统：它仍然使用自动化，但只有在决定了所需的操作之后。只有在系统不能自动确定正确的事情时才应该通知人
</pre>

<p>
具有这些特征的应用程序需要一个能够实际监控，收集度量标准并在发生故障时做出反应的平台
</p>

<pre class="example">
      云原生应用程序不依赖于人员设置 ping 检查或创建 Syslog 规则

      他们需要从选择基本操作系统或软件包管理器的过程中提取自助服务资源，并依靠服务发现和强大的网络通信来提供丰富的功能体验
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgba67276" class="outline-2">
<h2 id="orgba67276">Kubernetes 的诞生</h2>
<div class="outline-text-2" id="text-orgba67276">
<p>
众所周知，Kubernetes 是 Google 于 2014 年 6 月基于其内部使用的 Borg 系统开源出来的容器编排调度引擎。其实从 2000 年开始，Google 就开始基于容器研发三个容器管理系统，分别是 Borg、Omega 和 Kubernetes
</p>

<pre class="example">
    这篇由 Google 工程师 Brendan Burns、Brian Grant、David Oppenheimer、Eric Brewer 和 John Wilkes 几人在 2016 年发表的《Borg, Omega, and Kubernetes》论文里，阐述了 Google 从 Borg 到 Kubernetes 这个旅程中所获得知识和经验教训
</pre>
</div>
<div id="outline-container-org5ff9510" class="outline-3">
<h3 id="org5ff9510">Borg、Omega 和 Kubernetes</h3>
<div class="outline-text-3" id="text-org5ff9510">
<p>
Google 从 2000 年初就开始使用容器（Linux 容器）系统，Google 开发出来的第一个统一的容器管理系统在内部称之为 “Borg”，用来管理长时间运行的生产服务和批处理服务。由于 Borg 的规模、功能的广泛性和超高的稳定性，一直到现在 Borg 在 Google 内部依然是主要的容器管理系统。
</p>

<p>
Google 的第二套容器管理系统叫做 Omega，作为 Borg 的延伸，它的出现是出于提升 Borg 生态系统软件工程的愿望。由于越来越多的应用被开发并运行在 Borg 上，Google 开发了一个广泛的工具和服务的生态系统。它应用到了很多在 Borg 内已经被认证的成功的模式，但是从头开始来搭建以期更为一致的构架。这些系统提供了配置和更新 job 的机制，能够预测资源需求，动态地对在运行中的程序推送配置文件、服务发现、负载均衡、自动扩容、机器生命周期管理、额度管理等。许多 Omega 的创新（包括多个调度器）都被收录进了 Borg
</p>

<p>
Google 的第三套容器管理系统就是我们所熟知的 Kubernetes，它是针对在 Google 外部的对 Linux 容器感兴趣的开发者以及 Google 在公有云底层商业增长的考虑而研发的。和 Borg、Omega 完全是谷歌内部系统相比，Kubernetes 是开源的。像 Omega 一样，Kubernetes 在其核心有一个被分享的持久存储，有组件来检测相关 object 的变化。跟 Omega 不同的是，Omega 把存储直接暴露给信任的控制平面的组件，而在 Kubernete 中，提供了完全由特定领域更高层面的版本控制、认证、语义、策略的 REST API 接口，以服务更多的用户。更重要的是，Kubernetes 是由一群底层开发能力更强的开发者开发的，他们主要的设计目标是用更容易的方法去部署和管理复杂的分布式系统，同时仍能从容器提升的效率中受益。
</p>

<pre class="example">
2014 年 Kubernetes 正式开源，2015 年被作为初创项目贡献给了云原生计算基金会（CNCF），从此开启了 Kubernetes 及云原生化的大潮
</pre>
</div>
</div>
</div>
<div id="outline-container-org1a80b38" class="outline-2">
<h2 id="org1a80b38">Kubernetes概览</h2>
<div class="outline-text-2" id="text-org1a80b38">
<pre class="example">
2017年9月，Mesos宣布支持Kubernetes，而在2017年10月份的DockerCon EU上，Docker公司宣布官方同时支持Swarm和Kubernetes容器编排

Kubernetes已然成为容器编排调度的标准
</pre>
</div>

<div id="outline-container-org4798cb4" class="outline-3">
<h3 id="org4798cb4">发展历史</h3>
<div class="outline-text-3" id="text-org4798cb4">
<p>
云计算的发展历程引入云原生计算，请看下图：
</p>


<div class="figure">
<p><img src="pic/cloud-computing-evolution-road.jpg" alt="cloud-computing-evolution-road.jpg" width="70%" /> 
</p>
</div>

<p>
云原生应用到2020年将比目前至少翻一番，下图是Marc Wilczek的调查报告：
</p>

<div class="figure">
<p><img src="pic/cloud-native-comes-of-age.jpg" alt="cloud-native-comes-of-age.jpg" width="50%" /> 
</p>
</div>
</div>

<div id="outline-container-org5a1bbc6" class="outline-4">
<h4 id="org5a1bbc6">云计算介绍</h4>
<div class="outline-text-4" id="text-org5a1bbc6">
<pre class="example">
    云计算包含的内容十分繁杂，也有很多技术和公司牵强附会说自己是云计算公司，说自己是做云的，实际上可能风马牛不相及
</pre>

<p>
云计算就是一种 <span class="underline">配置资源</span> 的方式，根据资源配置方式的不同可以把云计算从宏观上分为以下三种类型：
</p>
<ul class="org-ul">
<li>IaaS：这是为了想要建立自己的商业模式并进行自定义的客户，例如亚马逊的EC2、S3存储、Rackspace虚拟机等都是IaaS</li>
<li>PaaS：工具和服务的集合，对于想用它来构建自己的应用程序或者想快速得将应用程序部署到生产环境而不必关心底层硬件的用户和开发者来说是特别有用的，比如Cloud Foundry、Google App Engine、Heroku等</li>
<li>SaaS：终端用户可以直接使用的应用程序。这个就太多，生活中用到的很多软件都是SaaS服务，只要基于互联网来提供的服务基本都是SaaS服务，有的服务是免费的，比如Google Docs，还有更多的是根据购买的Plan和使用量付费，比如GitHub、各种云存储</li>
</ul>
</div>
</div>

<div id="outline-container-org66f6d03" class="outline-4">
<h4 id="org66f6d03">微服务介绍</h4>
<div class="outline-text-4" id="text-org66f6d03">
<p>
微服务（Microservices）这个词比较新颖，但是其实这种架构设计理念早就有了。微服务是一种 <span class="underline">分布式架构</span> 设计理念，为了推动细粒度服务的使用，这些服务要能协同工作，每个服务都有自己的生命周期。一个微服务就是一个独立的实体，可以独立的部署在PAAS平台上，也可以作为一个独立的进程在主机中运行。服务之间通过API访问，修改一个服务不会影响其它服务
</p>


<pre class="example">
    下面会谈到Kubernetes与微服务的关系，其中Kubernetes的service天生就适合于微服务
</pre>
</div>
</div>

<div id="outline-container-org458b05c" class="outline-4">
<h4 id="org458b05c">云原生概念介绍</h4>
<div class="outline-text-4" id="text-org458b05c">
<pre class="example">
      云原生准确来说是一种文化，更是一种潮流，它是云计算的一个必然导向

      它的意义在于让云成为云化战略成功的基石，而不是阻碍，如果业务应用上云之后开发和运维人员比原先还痛苦，成本还高的话，这样的云我们宁愿不上
</pre>

<p>
下面是Cloud Native概念思维导图：
</p>

<div class="figure">
<p><img src="pic/cloud-native-architecutre-mindnode.jpg" alt="cloud-native-architecutre-mindnode.jpg" width="50%" />
</p>
</div>

<pre class="example">
      自从云的概念开始普及，许多公司都部署了实施云化的策略，纷纷搭建起云平台，希望完成传统应用到云端的迁移

      但是这个过程中会遇到一些技术难题，上云以后，效率并没有变得更高，故障也没有迅速定位
</pre>

<p>
为了解决传统应用升级缓慢、架构臃肿、不能快速迭代、故障不能快速定位、问题无法快速解决等问题，云原生这一概念横空出世。云原生可以改进应用开发的效率，改变企业的组织结构，甚至会在文化层面上直接影响一个公司的决策。另外，云原生也很好地解释了云上运行的应用应该具备什么样的架构特性： <span class="underline">敏捷性</span> 、 <span class="underline">可扩展性</span> 、 <span class="underline">故障可恢复性</span> 
</p>

<p>
综上所述，云原生应用应该具备以下几个关键词：
</p>
<ul class="org-ul">
<li>敏捷</li>
<li>可靠</li>
<li>高弹性</li>
<li>易扩展</li>
<li>故障隔离保护</li>
<li>不中断业务持续更新</li>
</ul>

<pre class="example">
    以上特性也是云原生区别于传统云应用的优势特点
</pre>
</div>
</div>
</div>

<div id="outline-container-orgebf84f0" class="outline-3">
<h3 id="orgebf84f0">Kubernetes与云原生的关系</h3>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>基础概念</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="start.html"> UP </a>
 |
 <a accesskey="H" href="rust.html"> HOME </a>
</div><div id="content">
<h1 class="title">基础概念</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8ad86ea">变量</a>
<ul>
<li><a href="#org43fdded">不变性</a></li>
<li><a href="#orga71993e">变量和常量的区别</a></li>
<li><a href="#orgd3a6293">隐藏</a></li>
</ul>
</li>
<li><a href="#org5b04c96">基本数据类型</a>
<ul>
<li><a href="#org09de34c">标量</a>
<ul>
<li><a href="#orgbf62d3e">整形</a>
<ul>
<li><a href="#org15eaab6">整形溢出</a></li>
</ul>
</li>
<li><a href="#org6cf1f67">浮点型</a></li>
<li><a href="#orgfe8c099">数值运算</a></li>
<li><a href="#orgefea643">布尔型</a></li>
<li><a href="#org26ead3d">字符类型</a></li>
</ul>
</li>
<li><a href="#org7fa4c5d">复合类型</a></li>
</ul>
</li>
</ul>
</div>
</div>
<pre class="example">
  本章介绍一些几乎所有编程语言都有的概念，以及它们在 Rust 中是如何工作的

  很多编程语言的核心概念都是共通的，本章中展示的概念都不是 Rust 所特有的，不过会在 Rust 上下文中讨论它们，并解释使用这些概念的惯例
</pre>

<p>
具体来说，将会学习 <span class="underline">变量</span> 、 <span class="underline">基本类型</span> 、 <span class="underline">函数</span> 、 <span class="underline">注释</span> 和 <span class="underline">控制流</span> 
</p>

<pre class="example">
  每一个 Rust 程序中都会用到这些基础知识，提早学习这些概念会让人在起步时就打下坚实的基础
</pre>
<div id="outline-container-org8ad86ea" class="outline-2">
<h2 id="org8ad86ea">变量</h2>
<div class="outline-text-2" id="text-org8ad86ea">
</div>
<div id="outline-container-org43fdded" class="outline-3">
<h3 id="org43fdded">不变性</h3>
<div class="outline-text-3" id="text-org43fdded">
<pre class="example">
     前面提到过，变量默认是不可改变的。这是推动充分利用 Rust 提供的安全性和简单并发性来编写代码的众多方式之一

     不过，仍然可以使用可变变量。先来探讨一下 Rust 拥抱不可变性的原因及方法，以及何时不想使用不可变性
</pre>

<p>
当变量不可变时，一旦值被绑定一个名称上，就不能改变这个值。为了对此进行说明，使用 <span class="underline">cargo new variables</span> 命令在 projects 目录生成一个叫做 variables 的新项目。
</p>

<p>
接着，在新建的 variables 目录，打开 src/main.rs 并将代码替换为如下代码，这些代码还不能编译：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = 5;
    <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"The value of x is: </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, x);
    x = 6;
    <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"The value of x is: </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, x);
}
</pre>
</div>

<p>
保存并使用 cargo build 运行程序。应该会看到一条错误信息，如下输出所示：
</p>
<div class="org-src-container">
<pre class="src src-sh">$ cargo build
   Compiling variables v0.1.0 (/home/i514692/Documents/programming/html/klose911.github.io/src/rust/src/variables)
error[E0384]: cannot assign twice to immutable variable <span style="color: #fa8072;">`x`</span>
 --&gt; src/main.rs:4:5
  |
2 |     <span style="color: #b0c4de;">let</span> x = 5;
  |         -
  |         |
  |         first assignment to <span style="color: #fa8072;">`x`</span>
  |         <span style="color: #b0c4de;">help</span>: make this binding mutable: <span style="color: #fa8072;">`mut x`</span>
3 |     println!(<span style="color: #ffa07a;">"The value of x is: {}"</span>, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error

For more information about this error, try <span style="color: #fa8072;">`rustc --explain E0384`</span><span style="color: #b0c4de;">.</span>
error: could not compile <span style="color: #fa8072;">`variables`</span><span style="color: #b0c4de;">.</span>

To learn more, run the command again with --verbose.
</pre>
</div>

<p>
错误信息指出错误的原因是 <b>不能对不可变变量 x 二次赋值</b> (cannot assign twice to immutable variable x)
</p>

<pre class="example">
Rust 编译器保证，如果声明一个值不会变，它就真的不会变

这意味着当阅读和编写代码时，不需要追踪一个值如何和在哪可能会被改变，从而使得代码易于推导
</pre>

<p>
不过可变性也是非常有用的。变量只是默认不可变：可以在变量名之前加 <span class="underline">mut</span> 来使其可变
</p>

<pre class="example">
     除了允许改变值之外，mut 向代码阅读者表明了其他代码将会改变这个变量值的意图
</pre>

<p>
例如，将 src/main.rs 修改为如下代码：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #00ffff;">mut</span> <span style="color: #eedd82;">x</span> = 5;
    <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"The value of x is: </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, x);
    x = 6;
    <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"The value of x is: </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, x);
}
</pre>
</div>

<p>
现在运行这个程序：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo run
   Compiling variables v0.1.0 (/home/i514692/Documents/programming/html/klose911.github.io/src/rust/src/variables)
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00ffff;">in</span> 0.81s
     Running <span style="color: #fa8072;">`target/debug/variables`</span>
The value of x is: 5
The value of x is: 6
</pre>
</div>

<p>
通过 mut，允许把绑定到 x 的值从 5 改成 6。在一些情况下，会想用可变变量，因为与只用不可变变量相比，它会让 <b>代码更容易编写</b> 
</p>

<pre class="example">
     除了防止出现 bug 外，还有很多地方需要权衡取舍

     例如，使用大型数据结构时，适当地使用可变变量，可能比复制和返回新分配的实例更快
     对于较小的数据结构，总是创建新实例，采用更偏向函数式的编程风格，可能会使代码更易理解，为可读性而牺牲性能或许是值得的。
</pre>
</div>
</div>

<div id="outline-container-orga71993e" class="outline-3">
<h3 id="orga71993e">变量和常量的区别</h3>
<div class="outline-text-3" id="text-orga71993e">
<pre class="example">
     不允许改变值的变量，可能会使你想起另一个大部分编程语言都有的概念：常量
</pre>

<p>
类似于不可变变量，常量是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别：
</p>
<ul class="org-ul">
<li><b>不允许对常量使用 mut</b> ：常量不光默认不能变，它 <b>总是不能变</b></li>
<li>声明常量使用 <b>const</b> 关键字而不是 <span class="underline">let</span> ，并且 <b>必须注明值的类型</b></li>
</ul>
<pre class="example">
     在下一部分，“数据类型” 中会介绍类型和类型注解
</pre>
<ul class="org-ul">
<li>常量可以在 <b>任何作用域中声明</b> ，包括 <span class="underline">全局作用域</span> ，这在一个值需要被很多部分的代码用到时很有用</li>
<li>常量只能 <b>被设置为常量表达式</b> ，而不能是 <span class="underline">函数调用的结果</span> ，或任何其他 <span class="underline">只能在运行时计算出的值</span></li>
</ul>


<p>
下面是一个声明常量的例子，它的名称是 MAX_POINTS，值是 100,000：
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">const</span> <span style="color: #eedd82;">MAX_POINTS</span>: <span style="color: #98fb98;">u32</span> = 100_000;
</pre>
</div>

<p>
在声明它的作用域之中，常量在 <b>整个程序生命周期中都有效</b> ，这使得常量可以作为 <span class="underline">多处代码使用的全局范围的值</span> ，例如一个游戏中所有玩家可以获取的最高分或者光速
</p>

<pre class="example">
     将遍布于应用程序中的硬编码值声明为常量，能帮助后来的代码维护人员了解值的意图

     如果将来需要修改硬编码值，也只需修改汇聚于一处的硬编码值
</pre>
</div>
</div>

<div id="outline-container-orgd3a6293" class="outline-3">
<h3 id="orgd3a6293">隐藏</h3>
<div class="outline-text-3" id="text-orgd3a6293">
<p>
可以定义一个与之前变量同名的新变量，而新变量会 <b>隐藏</b> 之前的变量。Rustacean 们称之为第一个变量被第二个 隐藏 了，这意味着使用这个变量时会看到第二个值。可以用相同变量名称来隐藏一个变量，以及重复使用 <span class="underline">let</span> 关键字来多次隐藏，如下所示：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = 5;

    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = x + 1;

    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = x * 2;

    <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"The value of x is: </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, x);
}
</pre>
</div>

<p>
这个程序首先将 x 绑定到值 5 上。接着通过 let x = 隐藏 x，获取初始值并加 1，这样 x 的值就变成 6 了。第三个 let 语句也隐藏了 x，将之前的值乘以 2，x 最终的值是 12。运行这个程序，它会有如下输出：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo run
   Compiling shadowing v0.1.0 (/home/i514692/Documents/programming/html/klose911.github.io/src/rust/src/shadowing)
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00ffff;">in</span> 0.61s
     Running <span style="color: #fa8072;">`target/debug/shadowing`</span>
The value of x is: 12
</pre>
</div>

<p>
<span class="underline">隐藏</span> 与将变量 <span class="underline">标记为 mut</span> 是有区别的：
</p>
<ul class="org-ul">
<li>当不小心尝试对变量重新赋值时：
<ul class="org-ul">
<li>如果 <span class="underline">没有使用 let</span> 关键字，就会导致 <b>编译时错误</b></li>
<li>通过 <span class="underline">使用 let</span> ，可以用这个值进行一些计算，不过 <b>计算完之后变量仍然是不变的</b></li>
</ul></li>
<li>当再次使用 let 时，实际上 <b>创建了一个新变量</b> ，可以 <b>改变值的类型</b> ，但复用这个名字
<ul class="org-ul">
<li>例如，假设程序请求用户输入空格字符来说明希望在文本之间显示多少个空格，然而真正需要的是将输入存储成数字（多少个空格）：</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">let</span> <span style="color: #eedd82;">spaces</span> = <span style="color: #ffa07a;">"   "</span>;
<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">spaces</span> = spaces.len();
</pre>
</div>

<p>
这里允许第一个 spaces 变量是字符串类型，而第二个 spaces 变量，它是一个恰巧与第一个变量同名的崭新变量，是数字类型。 <b>隐藏使我们不必使用不同的名字，如 spaces_str 和 spaces_num</b> ；相反，可以复用 spaces 这个更简单的名字。然而，如果尝试使用 mut：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">let</span> <span style="color: #00ffff;">mut</span> <span style="color: #eedd82;">spaces</span> = <span style="color: #ffa07a;">"   "</span>;
spaces = spaces.len();
</pre>
</div>

<p>
将会得到一个编译时错误，如下所示：
</p>
<div class="org-src-container">
<pre class="src src-sh">error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &amp;str, found usize
  |
  = note: expected type <span style="color: #fa8072;">`&amp;str`</span>
             found type <span style="color: #fa8072;">`usize`</span>
</pre>
</div>

<p>
这说明 mut 不能改变变量的类型
</p>

<pre class="example">
     现在已经了解了变量如何工作，接下来看看变量可以拥有的更多数据类型
</pre>
</div>
</div>
</div>

<div id="outline-container-org5b04c96" class="outline-2">
<h2 id="org5b04c96">基本数据类型</h2>
<div class="outline-text-2" id="text-org5b04c96">
<p>
在 Rust 中，每一个值都属于某一个 <b>数据类型</b> ，这告诉 Rust 它被指定为何种数据，以便明确数据处理方式。将看到两类数据类型子集： <span class="underline">标量</span> 和 <span class="underline">复合</span> 
</p>

<pre class="example">
    记住，Rust 是静态类型 (statically typed) 语言，也就是说在编译时就必须知道所有变量的类型

</pre>
<p>
根据 <span class="underline">值</span> 及其 <span class="underline">使用方式</span> ， <b>编译器通常可以推断出想要用的类型</b> 。当 <span class="underline">多种类型均有可能</span> 时，必须 <b>增加类型注解</b> ，像这样：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">let</span> <span style="color: #eedd82;">guess</span>: <span style="color: #98fb98;">u32</span> = <span style="color: #ffa07a;">"42"</span>.parse().expect(<span style="color: #ffa07a;">"Not a number!"</span>);
</pre>
</div>

<p>
如果不添加类型注解，Rust 会显示如下错误，这说明编译器需要提供更多信息，来了解想要的类型：
</p>

<div class="org-src-container">
<pre class="src src-sh">error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     <span style="color: #b0c4de;">let</span> guess = <span style="color: #ffa07a;">"42"</span>.parse().expect(<span style="color: #ffa07a;">"Not a number!"</span>);
  |         ^^^^^
  |         |
  |         cannot infer type for <span style="color: #fa8072;">`_`</span>
  |         consider giving <span style="color: #fa8072;">`guess`</span> a type
</pre>
</div>
</div>

<div id="outline-container-org09de34c" class="outline-3">
<h3 id="org09de34c">标量</h3>
<div class="outline-text-3" id="text-org09de34c">
<p>
<span class="underline">标量</span> 类型代表 <b>一个单独的值</b> 。Rust 有四种基本的标量类型： <span class="underline">整型</span> 、 <span class="underline">浮点型</span> 、 <span class="underline">布尔</span> 类型和 <span class="underline">字符</span> 类型
</p>
</div>

<div id="outline-container-orgbf62d3e" class="outline-4">
<h4 id="orgbf62d3e">整形</h4>
<div class="outline-text-4" id="text-orgbf62d3e">
<p>
<span class="underline">整数</span> 是一个 <b>没有小数部分的数字</b> 
</p>
<pre class="example">
      以前使用过 u32 整数类型

      该类型声明表明，它关联的值应该是一个占据 32 比特位的无符号整数
      有符号整数类型以 i 开头而不是 u
</pre>
<p>
下面表格展示了 Rust 内建的整数类型。在有符号列和无符号列中的每一个变体（例如，i16）都可以用来声明整数值的类型：
</p>

<table border="1" cellspacing="0" cellpadding="6" rules="all" frame="boader">
<caption class="t-above"><span class="table-number">Table 1:</span> Rust 中的整型</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">长度</td>
<td class="org-left">有符号</td>
<td class="org-left">无符号</td>
</tr>

<tr>
<td class="org-left">8-bit</td>
<td class="org-left">i8</td>
<td class="org-left">u8</td>
</tr>

<tr>
<td class="org-left">16-bit</td>
<td class="org-left">i16</td>
<td class="org-left">u16</td>
</tr>

<tr>
<td class="org-left">32-bit</td>
<td class="org-left">i32</td>
<td class="org-left">u32</td>
</tr>

<tr>
<td class="org-left">64-bit</td>
<td class="org-left">i64</td>
<td class="org-left">u64</td>
</tr>

<tr>
<td class="org-left">128-bit</td>
<td class="org-left">i128</td>
<td class="org-left">u128</td>
</tr>

<tr>
<td class="org-left">arch</td>
<td class="org-left">isize</td>
<td class="org-left">usize</td>
</tr>
</tbody>
</table>

<p>
每一个变体都可以是有符号或无符号的，并有一个明确的大小：
</p>
<ul class="org-ul">
<li>有符号 和 无符号 代表数字能否为负值，换句话说，数字是否需要有一个符号（有符号数），或者永远为正而不需要符号（无符号数）</li>
</ul>
<pre class="example">
  这有点像在纸上书写数字：当需要考虑符号的时候，数字以加号或减号作为前缀
  然而，可以安全地假设为正数时，加号前缀通常省略

  有符号数以补码形式存储
</pre>
<p>
每一个有符号的变体可以储存包含从 -2^(n - 1) 到 2^(n - 1) - 1 在内的数字，这里 n 是变体使用的位数
</p>
<pre class="example">
  所以 i8 可以储存从 -(2^7) 到 2^7 - 1 在内的数字，也就是从 -128 到 127
</pre>

<p>
无符号的变体可以储存从 0 到 (2^n - 1) 的数字
</p>
<pre class="example">
  所以 u8 可以储存从 0 到 2^8 - 1 的数字，也就是从 0 到 255
</pre>

<p>
<span class="underline">isize</span> 和 <span class="underline">usize</span> 类型依赖 <b>运行程序的计算机架构</b> ：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的
</p>

<p>
可以使用下面表格中的任何一种形式编写数字字面值：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">数字字面值</td>
<td class="org-left">例子</td>
</tr>

<tr>
<td class="org-left">Decimal</td>
<td class="org-left">98_222</td>
</tr>

<tr>
<td class="org-left">Hex</td>
<td class="org-left">0xff</td>
</tr>

<tr>
<td class="org-left">Octal</td>
<td class="org-left">0o77</td>
</tr>

<tr>
<td class="org-left">Binary</td>
<td class="org-left">0b1111_0000</td>
</tr>

<tr>
<td class="org-left">Byte (u8 only)</td>
<td class="org-left">b'A'</td>
</tr>
</tbody>
</table>

<pre class="example">
  注意除 byte 以外的所有数字字面值允许使用类型后缀，例如 57u8

  同时也允许使用 _ 做为分隔符以方便读数，例如1_000
</pre>
</div>

<div id="outline-container-org15eaab6" class="outline-5">
<h5 id="org15eaab6">整形溢出</h5>
<div class="outline-text-5" id="text-org15eaab6">
<p>
比方说有一个 u8 ，它可以存放从零到 255 的值。那么当你将其修改为 256 时会发生什么呢？这被称为 <span class="underline">整型溢出</span> 
</p>

<pre class="example">
  关于这一行为 Rust 有一些有趣的规则

  当在 debug 模式编译时，Rust 检查这类问题并使程序 panic，这个术语被 Rust 用来表明程序因错误而退出
  在 release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码包装的操作
  简而言之，256 变成 0，257 变成 1，依此类推

  依赖整型溢出被认为是一种错误，即便可能出现这种行为。如果你确实需要这种行为，标准库中有一个类型显式提供此功能，Wrapping
</pre>
</div>
</div>
</div>

<div id="outline-container-org6cf1f67" class="outline-4">
<h4 id="org6cf1f67">浮点型</h4>
<div class="outline-text-4" id="text-org6cf1f67">
<p>
Rust 也有两个原生的 <span class="underline">浮点数</span> 类型，它们是 <b>带小数点的数字</b> 。Rust 的浮点数类型是 <span class="underline">f32</span> 和 <span class="underline">f64</span> ，分别占 32 位和 64 位。 默认类型是 f64
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span> = 2.0; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">f64</span>

    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">y</span>: <span style="color: #98fb98;">f32</span> = 3.0; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">f32</span>
}
</pre>
</div>

<pre class="example">
  浮点数采用 IEEE-754 标准表示：f32 是单精度浮点数，f64 是双精度浮点数

  在现代 CPU 中，f64 与 f32 速度几乎一样，不过精度更高
</pre>
</div>
</div>

<div id="outline-container-orgfe8c099" class="outline-4">
<h4 id="orgfe8c099">数值运算</h4>
<div class="outline-text-4" id="text-orgfe8c099">
<p>
Rust 中的所有数字类型都支持基本数学运算： <span class="underline">加法</span> 、 <span class="underline">减法</span> 、 <span class="underline">乘法</span> 、 <span class="underline">除法</span> 和 <span class="underline">取余</span> 。下面的代码展示了如何在 let 语句中使用它们：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#21152;&#27861;</span>
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">sum</span> = 5 + 10;

    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20943;&#27861;</span>
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">difference</span> = 95.5 - 4.3;

    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#20056;&#27861;</span>
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">product</span> = 4 * 30;

    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#38500;&#27861;</span>
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">quotient</span> = 56.7 / 32.2;

    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#21462;&#20313;</span>
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">remainder</span> = 43 % 5;
}
</pre>
</div>

<p>
这些语句中的每个表达式使用了一个数学运算符并计算出了一个值，然后绑定给一个变量
</p>
</div>
</div>

<div id="outline-container-orgefea643" class="outline-4">
<h4 id="orgefea643">布尔型</h4>
<div class="outline-text-4" id="text-orgefea643">
<p>
Rust 中的布尔类型有两个可能的值： <span class="underline">true</span> 和 <span class="underline">false</span> 。Rust 中的布尔类型使用 <span class="underline">bool</span> 表示。例如：
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">t</span> = <span style="color: #00ffff;">true</span>;

    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">f</span>: <span style="color: #98fb98;">bool</span> = <span style="color: #00ffff;">false</span>; <span style="color: #ff4500;">// </span><span style="color: #ff4500;">&#26174;&#24335;&#25351;&#23450;&#31867;&#22411;&#27880;&#35299;</span>
}
</pre>
</div>

<pre class="example">
  使用布尔值的主要场景是条件表达式，例如 if 表达式
</pre>
</div>
</div>

<div id="outline-container-org26ead3d" class="outline-4">
<h4 id="org26ead3d">字符类型</h4>
<div class="outline-text-4" id="text-org26ead3d">
<p>
目前为止只使用到了数字，不过 Rust 也支持字母。Rust 的 <span class="underline">char</span> 类型是语言中 <b>最原生的字母类型</b> ，如下代码展示了如何使用它：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">c</span> = <span style="color: #ffa07a;">'z'</span>;
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">z</span> = <span style="color: #ffa07a;">'&#8484;'</span>;
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">heart_eyed_cat</span> = <span style="color: #ffa07a;">'&#128571;'</span>;
}
</pre>
</div>

<pre class="example">
  注意 char 由单引号指定，不同于字符串使用双引号
</pre>

<p>
Rust 的 char 类型的大小为 <b>四个字节</b> ，并代表了一个 <b>Unicode 标量值</b> ，这意味着它可以比 ASCII 表示更多内容
</p>

<pre class="example">
在 Rust 中，拼音字母，中文、日文、韩文等字符，emoji以及零长度的空白字符都是有效的 char 值

Unicode 标量值包含从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF 在内的值

不过，“字符” 并不是一个 Unicode 中的概念，所以人直觉上的 “字符” 可能与 Rust 中的 char 并不符合
</pre>
</div>
</div>
</div>

<div id="outline-container-org7fa4c5d" class="outline-3">
<h3 id="org7fa4c5d">复合类型</h3>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>

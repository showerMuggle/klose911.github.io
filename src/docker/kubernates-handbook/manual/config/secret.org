#+TITLE: Secret 配置
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../../css/main.css" />
#+HTML_LINK_UP: probness.html
#+HTML_LINK_HOME: config.html
#+OPTIONS: num:nil timestamp:nil ^:nil

Secret 对象类型用来保存 *敏感* 信息

#+begin_example
  例如密码、OAuth 令牌和 ssh key
#+end_example

将这些信息放在 secret 中比放在 pod 的定义中或者 docker 镜像中来说更加安全和灵活
* 概览
  Secret 是一种包含少量敏感信息例如密码、token 或 key 的对象。这样的信息可能会被放在 Pod spec 中或者镜像中

  #+BEGIN_EXAMPLE
    将其放在一个 secret 对象中可以更好地控制它的用途，并降低意外暴露的风险
  #+END_EXAMPLE

  用户可以创建 secret，同时系统也创建了一些 secret 

  要使用 secret，pod 需要引用 secret。Pod 可以用两种方式使用 secret：
  1. 作为 volume 中的文件被挂载到 pod 中的一个或者多个容器里
  2. 当 kubelet 为 pod 拉取镜像时使用
** 内置 secret
*** Service Account 使用 API 凭证自动创建和附加 secret
    Kubernetes 自动创建包含访问 API 凭据的 secret，并自动修改 pod 以使用此类型的 secret

    #+BEGIN_EXAMPLE
      如果需要，可以禁用或覆盖自动创建和使用API凭据

      但是，如果需要的只是安全地访问 apiserver，推荐这样的工作流程
    #+END_EXAMPLE
** 创建 
*** 使用 kubectl 
    假设有些 pod 需要访问数据库。这些 pod 需要使用的用户名和密码在本地机器的 ./username.txt 和 ./password.txt 文件里：

    #+BEGIN_SRC sh 
  # Create files needed for rest of example.
  $ echo -n "admin" > ./username.txt
  $ echo -n "1f2d1e2e67df" > ./password.txt
    #+END_SRC

    kubectl create secret 命令将这些文件打包到一个 Secret 中并在 API server 中创建了一个对象：

    #+BEGIN_SRC sh 
  $ kubectl create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txt
  secret "db-user-pass" created
    #+END_SRC

    可以这样检查刚创建的 secret：

    #+BEGIN_SRC sh 
  $ kubectl get secrets
  NAME                  TYPE                                  DATA      AGE
  db-user-pass          Opaque                                2         51s

  $ kubectl describe secrets/db-user-pass
  Name:            db-user-pass
  Namespace:       default
  Labels:          <none>
  Annotations:     <none>

  Type:            Opaque

  Data
  ====
  password.txt:    12 bytes
  username.txt:    5 bytes
    #+END_SRC

    #+BEGIN_EXAMPLE
      请注意，默认情况下，get 和 describe 命令都不会显示文件的内容

      这是为了防止将 secret 中的内容被意外暴露给从终端日志记录中刻意寻找它们的人
    #+END_EXAMPLE
*** 手动创建 
    可以先以 json 或 yaml 格式在文件中创建一个 secret 对象，然后创建该对象：

    #+BEGIN_SRC sh 
  $ echo -n "admin" | base64
  YWRtaW4=
  $ echo -n "1f2d1e2e67df" | base64
  MWYyZDFlMmU2N2Rm
    #+END_SRC

    #+BEGIN_EXAMPLE
      每一项必须是 base64 编码
    #+END_EXAMPLE

    现在可以像这样写一个 secret 对象：

    #+BEGIN_EXAMPLE
      apiVersion: v1
      kind: Secret
      metadata:
	name: mysecret
      type: Opaque
      data:
	username: YWRtaW4=
	password: MWYyZDFlMmU2N2Rm
    #+END_EXAMPLE

    数据字段是一个映射。它的键必须匹配 DNS_SUBDOMAIN，前导点也是可以的。这些值可以是任意数据，使用 base64 进行编码。使用 kubectl create创建 secret：
    #+BEGIN_SRC sh 
  $ kubectl create -f ./mysecret.yaml
  secret "mysecret" created
    #+END_SRC

    #+BEGIN_EXAMPLE
      编码注意： secret 数据的序列化 JSON 和 YAML 值使用 base64 编码成字符串。另外：

      1. 换行符在这些字符串中无效，必须省略

      2. 当在Darwin/OS X上使用 base64 实用程序时，用户应避免使用 -b 选项来拆分长行

      3. 对于 Linux用户如果 -w 选项不可用的话，应该添加选项 -w 0 到 base64 命令或管道 base64 | tr -d '\n' 
    #+END_EXAMPLE
*** 解码 Secret
    可以使用 kubectl get secret 命令获取 secret。例如，获取在上一节中创建的 secret：

    #+BEGIN_SRC sh 
  $ kubectl get secret mysecret -o yaml
  apiVersion: v1
  data:
    username: YWRtaW4=
    password: MWYyZDFlMmU2N2Rm
  kind: Secret
  metadata:
    creationTimestamp: 2016-01-22T18:41:56Z
    name: mysecret
    namespace: default
    resourceVersion: "164619"
    selfLink: /api/v1/namespaces/default/secrets/mysecret
    uid: cfee02d6-c137-11e5-8d73-42010af00002
  type: Opaque
    #+END_SRC

    解码密码字段：

    #+BEGIN_SRC sh 
  $ echo "MWYyZDFlMmU2N2Rm" | base64 --decode
  1f2d1e2e67df
    #+END_SRC

** 使用
   Secret 可以作为 _数据卷_ 被挂载，或作为 _环境变量_ 暴露出来以供 pod 中的容器使用

   #+BEGIN_EXAMPLE
     它们也可以被系统的其他部分使用，而不直接暴露在 pod 内

     例如，它们可以保存凭据，系统的其他部分应该用它来代表您与外部系统进行交互
   #+END_EXAMPLE

*** 在 Pod 中使用 Secret 文件
    在 Pod 中的 volume 里使用 Secret：
    1. 创建一个 secret 或者使用已有的 secret
       #+BEGIN_EXAMPLE
	 多个 pod 可以引用同一个 secret
       #+END_EXAMPLE
    2. 修改 pod 的定义在 spec.volumes[] 下增加一个 volume
       #+BEGIN_EXAMPLE
	 可以给这个 volume 随意命名，它的 spec.volumes[].secret.secretName 必须等于 secret 对象的名字
       #+END_EXAMPLE
    3. 将 spec.containers[].volumeMounts[] 加到需要用到该 secret 的容器中
       #+BEGIN_EXAMPLE
	 指定 spec.containers[].volumeMounts[].readOnly = true 和 spec.containers[].volumeMounts[].mountPath 为想要该 secret 出现的尚未使用的目录
       #+END_EXAMPLE
    4. 修改镜像并且／或者命令行让程序从该目录下寻找文件。Secret 的 data 映射中的每一个键都成为了 mountPath 下的一个文件名 

    一个在 pod 中使用 volume 挂在 secret 的例子：

    #+BEGIN_EXAMPLE
      apiVersion: v1
      kind: Pod
      metadata:
	name: mypod
      spec:
	containers:
	- name: mypod
	  image: redis
	  volumeMounts:
	  - name: foo
	    mountPath: "/etc/foo"
	    readOnly: true
	volumes:
	- name: foo
	  secret:
	    secretName: mysecret
    #+END_EXAMPLE

    如果 pod 中有多个容器，每个容器都需要自己的 volumeMounts 配置块，但是每个 secret 只需要一个 spec.volumes 

**** 向特性路径映射 secret 密钥
     可以控制 Secret key 映射在 volume 中的路径。使用 spec.volumes[].secret.items 字段修改每个 key 的目标路径：

     #+BEGIN_EXAMPLE
       apiVersion: v1
       kind: Pod
       metadata:
	 name: mypod
       spec:
	 containers:
	 - name: mypod
	   image: redis
	   volumeMounts:
	   - name: foo
	     mountPath: "/etc/foo"
	     readOnly: true
	 volumes:
	 - name: foo
	   secret:
	     secretName: mysecret
	     items:
	     - key: username
	       path: my-group/my-username
     #+END_EXAMPLE

     + username secret 存储在 /etc/foo/my-group/my-username 文件中而不是 /etc/foo/username 中
     + password secret 没有被影射

     #+BEGIN_EXAMPLE
       如果使用了 spec.volumes[].secret.items，只有在 items 中指定的 key 被影射，要使用 secret 中所有的 key，所有这些都必须列在 items 字段中

       所有列出的密钥必须存在于相应的 secret 中。否则，不会创建卷
     #+END_EXAMPLE

**** Secret 文件权限
     可以指定 secret 将拥有的权限模式位文件。如果不指定，默认使用 0644。可以为整个保密卷指定默认模式，如果需要，可以覆盖每个密钥：

     #+BEGIN_EXAMPLE
       apiVersion: v1
       kind: Pod
       metadata:
	 name: mypod
       spec:
	 containers:
	 - name: mypod
	   image: redis
	   volumeMounts:
	   - name: foo
	     mountPath: "/etc/foo"
	 volumes:
	 - name: foo
	   secret:
	     secretName: mysecret
	     defaultMode: 256
     #+END_EXAMPLE


     secret 将被挂载到 /etc/foo 目录，所有通过该 secret volume 挂载创建的文件的权限都是 _0400_ 

     #+BEGIN_EXAMPLE
       请注意，JSON 规范不支持八进制符号，使用 256 值作为 0400 权限

       如果使用 yaml 而不是 json 作为 pod，则可以使用八进制符号以更自然的方式指定权限
     #+END_EXAMPLE

     为不同的文件指定不同的权限，如下所示：

     #+BEGIN_EXAMPLE
       apiVersion: v1
       kind: Pod
       metadata:
	 name: mypod
       spec:
	 containers:
	 - name: mypod
	   image: redis
	   volumeMounts:
	   - name: foo
	     mountPath: "/etc/foo"
	 volumes:
	 - name: foo
	   secret:
	     secretName: mysecret
	     items:
	     - key: username
	       path: my-group/my-username
	       mode: 511
     #+END_EXAMPLE

     #+BEGIN_EXAMPLE
       在这种情况下，导致 /etc/foo/my-group/my-username 的文件的权限值为 0777

       由于 JSON 限制，必须以十进制格式指定模式
     #+END_EXAMPLE

**** 从 Volume 中消费 secret 值
     在挂载的 secret volume 的容器内，secret key 将作为文件，并且 secret 的值使用 base-64 解码并存储在这些文件中。这是在上面的示例容器内执行的命令的结果：

     #+BEGIN_SRC sh 
  $ ls /etc/foo/
  username
  password
  $ cat /etc/foo/username
  admin
  $ cat /etc/foo/password
  1f2d1e2e67df
     #+END_SRC

     容器中的程序负责从文件中读取 secret

**** 挂载的 secret 被自动更新
     当已经在 volume 中消被消费的 secret 被更新时，被映射的 key 也将被更新

     #+BEGIN_EXAMPLE
       Kubelet 在周期性同步时检查被挂载的 secret 是不是最新的。但是，它正在使用其基于本地 ttl 的缓存来获取当前的 secret 值

       结果是，当 secret 被更新的时刻到将新的 secret 映射到 pod 的时刻的总延迟可以与 kubelet 中的secret 缓存的 kubelet sync period + ttl 一样长
     #+END_EXAMPLE

*** Secret 作为环境变量
    将 secret 作为 pod 中的环境变量使用：
    1. 创建一个 secret 或者使用一个已存在的 secret
       #+BEGIN_EXAMPLE
	 多个 pod 可以引用同一个 secret
       #+END_EXAMPLE
    2. 在每个容器中修改您想要使用 secret key 的 Pod 定义，为要使用的每个 secret key 添加一个环境变量
       #+BEGIN_EXAMPLE
	 消费secret key 的环境变量应填充 secret 的名称，并键入 env[x].valueFrom.secretKeyRef
       #+END_EXAMPLE
    3. 修改镜像并／或者命令行，以便程序在指定的环境变量中查找值

    #+BEGIN_EXAMPLE
      apiVersion: v1
      kind: Pod
      metadata:
	name: secret-env-pod
      spec:
	containers:
	- name: mycontainer
	  image: redis
	  env:
	    - name: SECRET_USERNAME
	      valueFrom:
		secretKeyRef:
		  name: mysecret
		  key: username
	    - name: SECRET_PASSWORD
	      valueFrom:
		secretKeyRef:
		  name: mysecret
		  key: password
	restartPolicy: Never
    #+END_EXAMPLE

**** 消费环境变量里的 Secret 值
     在一个消耗环境变量 secret 的容器中，secret key 作为包含 secret 数据的 base-64 解码值的常规环境变量。这是从上面的示例在容器内执行的命令的结果：

     #+BEGIN_SRC sh 
  $ echo $SECRET_USERNAME
  admin
  $ echo $SECRET_PASSWORD
  1f2d1e2e67df
     #+END_SRC

*** 使用 imagePullSecret
    imagePullSecret 是将包含 Docker（或其他）镜像注册表密码的 secret 传递给 Kubelet 的一种方式，因此可以代表 pod 拉取私有镜像

** 安排 imagePullSecrets 自动附加
   可以手动创建 imagePullSecret，并从 serviceAccount 引用它

   #+BEGIN_EXAMPLE
     使用该 serviceAccount 创建的任何 pod 和默认使用该 serviceAccount 的 pod 将会将其的 imagePullSecret 字段设置为服务帐户的 imagePullSecret 字段
   #+END_EXAMPLE

*** 自动挂载手动创建的 Secret
    手动创建的 secret（例如包含用于访问 github 帐户的令牌）可以根据其服务帐户自动附加到 pod 

* 细节

** 限制
   + 验证 secret volume 来源确保指定的对象引用实际上指向一个类型为 Secret 的对象
     #+BEGIN_EXAMPLE
       因此，需要在依赖于它的任何 pod 之前创建一个 secret
     #+END_EXAMPLE
   + Secret API 对象驻留在命名空间中
     #+BEGIN_EXAMPLE
       它们只能由同一命名空间中的 pod 引用
     #+END_EXAMPLE
   + 每个 secret 的大小限制为1MB
     #+BEGIN_EXAMPLE
       这是为了防止创建非常大的 secret 会耗尽 apiserver 和 kubelet 的内存。然而，创建许多较小的 secret 也可能耗尽内存
     #+END_EXAMPLE
   + Kubelet 仅支持从 API server 获取的 Pod 使用 secret
     #+BEGIN_EXAMPLE
       这包括使用 kubectl 创建的任何 pod，或间接通过 replication controller 创建的 pod

       它不包括通过 kubelet --manifest-url 标志，其 --config 标志或其 REST API 创建的pod（这些不是创建 pod 的常用方法）
     #+END_EXAMPLE
   + 必须先创建 secret，除非将它们标记为可选项，否则必须在将其作为环境变量在 pod 中使用之前创建 secret
     #+BEGIN_EXAMPLE
       对不存在的 secret 的引用将阻止其启动
     #+END_EXAMPLE
   + 通过 secretKeyRef 对不存在于命名的 key 中的 key 进行引用将阻止该启动
   + 用于通过 envFrom 填充环境变量的 secret，这些环境变量具有被认为是无效环境变量名称的 key 将跳过这些键。下面示例显示一个 pod，它指的是包含2个无效键，1badkey 和 2alsobad 的默认/mysecret ConfigMap：

   #+BEGIN_SRC sh 
  $ kubectl get events
  LASTSEEN   FIRSTSEEN   COUNT     NAME            KIND      SUBOBJECT                         TYPE      REASON
  0s         0s          1         dapi-test-pod   Pod                                         Warning   InvalidEnvironmentVariableNames
   #+END_SRC

   #+BEGIN_EXAMPLE
     该 pod 将被允许启动。将会有一个事件，其原因是 InvalidVariableNames，该消息将包含被跳过的无效键的列表
   #+END_EXAMPLE

** Secret 与 Pod 生命周期的联系
   1. 通过 API 创建的 Pod 时，不会检查应用的 secret 是否存在
   2. 一旦 Pod 被调度，kubelet 就会尝试获取该 secret 的值
      + 如果获取不到该 secret，或者暂时无法与 API server 建立连接，kubelet 将会定期重试
      + Kubelet 将会报告关于 pod 的事件，并解释它无法启动的原因
   3. 一旦获取的 secret，kubelet将创建并装载一个包含它的卷
      + 在安装所有pod的卷之前，都不会启动 pod 的容器
      
* 实例

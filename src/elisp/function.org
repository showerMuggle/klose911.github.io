#+TITLE: 函数和命令
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: variable.html   
#+HTML_LINK_HOME: elisp.html
#+OPTIONS: num:nil timestamp:nil ^:nil

在 elisp 里类似函数的对象很多，比如：
+ 函数：这里的函数特指用 lisp 写的函数
+ 原子函数（primitive）：用 C 写的函数，比如 car、append
+ lambda 表达式
+ 特殊表达式
+ 宏(macro)：它可以把一种 lisp 表达式转换成等价的另一个表达式
+ 命令：命令能用 command-execute 调用。函数也可以是命令

#+BEGIN_EXAMPLE
  已经学过如何定义一个函数。但是这些函数的参数个数都是确定

  但是可以看到 emacs 里有很多函数是接受可选参数，比如 random 函数，还有一些函数可以接受不确定的参数，比如加减乘除

  这样的函数在 elisp 中是如何定义的呢？
#+END_EXAMPLE
* 参数列表
  这是 _参数列表_ 的方法形式：

  #+BEGIN_SRC lisp 
  (REQUIRED-VARS...
   [&optional OPTIONAL-VARS...]
   [&rest REST-VAR])
  #+END_SRC

  把 _必须提供_ 的参数写在前面， _可选的参数_ 写在后面，最后用一个符号表示 _剩余的所有参数_ ：

  #+BEGIN_SRC lisp 
  (defun foo (var1 var2 &optional opt1 opt2 &rest rest)
    (list var1 var2 opt1 opt2 rest))

  (foo 1 2)                               ; => (1 2 nil nil nil)
  (foo 1 2 3)                             ; => (1 2 3 nil nil)
  (foo 1 2 3 4 5 6)                       ; => (1 2 3 4 (5 6))
  #+END_SRC

  从这个例子可以看出：
  + 当 _可选参数_ 没有提供时，在函数体里，对应的参数值都是 nil
  + 同样调用函数时没有提供 _剩余参数_ 时，其值也为 nil
    + 但是一旦提供了剩余参数，则所有参数是以 _列表_ 的形式放在对应变量里

* 文档字符串
  最好为你的函数都提供一个 _文档字符串_ 。关于文档字符串有一些规范，最好遵守这些约定：
  + 字符串的第一行最好是独立的。因为 apropos 命令只能显示第一行的文档。所以最好用一行（一两个完整的句子）总结这个函数的目的
  + 文档的缩进最好要根据最后的显示的效果来调用。因为引号之类字符会多占用一个字符，所以在源文件里缩进最好看，不一定显示的最好
  + 如果你想要让你的函数参数显示的与函数定义的不同（比如提示用户如何调用这个函数），可以在文档最后一行，加上一行：
  #+BEGIN_SRC lisp 
  \(fn ARGLIST)
  #+END_SRC

  注意：这一行前面要有一个空行，这一行后不能再有空行。比如

  #+BEGIN_SRC lisp 
  (defun foo (var1 var2 &optional opt1 opt2 &rest rest)
    "You should call the function like:

  \(fn v1 v2)"
    (list var1 var2 opt1 opt2 rest))
  #+END_SRC

  还有一些有特殊标记功能的符号，比如 `' 引起的符号名可以生成一个链接，这样可以在 *Help* 中更方便的查看相关变量或函数的文档，例如：

  #+BEGIN_SRC lisp 
  (defun foo ()
    "A simple document string to show how to use `' and \\=\\{}.
  You can press this button `help' to see the document of
  function \"help\".

  This is keybind of text-mode(substitute from \\=\\{text-mode-map}):
  \\{text-mode-map}

  See also `substitute-command-keys' and `documentation'"
    )
  #+END_SRC

  #+BEGIN_EXAMPLE
  \\{major-mode-map} 可以显示扩展成这个模式按键的说明
  #+END_EXAMPLE

* 调用函数
#+BEGIN_EXAMPLE
通常函数的调用都是用 eval 进行的，但是有时需要在“运行时”才决定使用什么函数
#+END_EXAMPLE
这时就需要用 _funcall_ 和 _apply_ 两个函数了，这两个函数都是把其余的参数作为函数的参数进行调用。唯一的区别就：
+ funcall 是 *直接* 把 _参数_ 传递给函数
+ apply 的 *最后一个参数* 是一个 _列表_ ，传入函数的参数把列表进行一次平铺后再传给函数

#+BEGIN_SRC lisp 
  (funcall 'list 'x '(y) '(z a))               ; => (x (y) (z a))
  (apply 'list 'x '(y ) '(z a))                ; => (x (y) z a)
#+END_SRC

#+BEGIN_EXAMPLE
  例子中的 funcall 和 apply 的区别就在于“怎么处理最好一个参数 '(z a)”

  funcall 是直接使用了 '(z a)
  apply 是用了 'z 'a, 去掉了列表 
#+END_EXAMPLE

* 宏
宏的调用和函数是很类似的，它的求值和函数差不多，但是有一个重要的区别是， *宏的参数是出现在最后扩展后的表达式中* ，而函数参数是求值后才传递给这个函数：
#+BEGIN_SRC lisp 
  (defmacro foo (arg)
    (list 'message "%d %d" arg arg))

  (defun bar (arg)
    (message "%d %d" arg arg))

  (let ((i 1))
    (bar (incf i)))                       ; => "2 2"

  (let ((i 1))
    (foo (incf i)))                       ; => "2 3"
#+END_SRC

宏可以这样看，如果把宏定义作一个表达式来运行，最后把参数用调用时的参数替换，这样就得到了宏调用最后用于求值的表达式。这个过程称为 _扩展_ 。可以用 _macroexpand_ 函数进行模拟：

#+BEGIN_SRC lisp 
  (macroexpand '(foo (incf i))) ; => (message "%d %d" (incf i) (incf i))
#+END_SRC

#+BEGIN_EXAMPLE
上面用 macroexpand 得到的结果就是用于求值的表达式
#+END_EXAMPLE

使用 macroexpand 可以使宏的编写变得容易一些。但是如果不能进行 debug 是很不方便的。在宏定义里可以引入 declare 表达式，它可以增加一些信息。目前只支持两类声明：debug 和 indent
#+BEGIN_EXAMPLE
debug 可选择的类型很多，具体参考 info elisp - Edebug 一章，一般情况下用 t 就足够了
#+END_EXAMPLE
indent 的类型比较简单，它可以使用这样几种类型：
+ nil: 也就是一般的方式缩进
+ defun: 类似 def 的结构，把第二行作为主体，对主体里的表达式使用同样的缩进
+ 整数: 表示从第 n 个表达式后作为主体。比如 if 设置为 2，而 when 设置为 1
+ 符号: 这个是最坏情况，要写一个函数自己处理缩进

看 when 的定义就能知道 declare 如何使用了：
#+BEGIN_SRC lisp 
  (defmacro when (cond &rest body)
    (declare (indent 1) (debug t))
    (list 'if cond (cons 'progn body)))
#+END_SRC

实际上，declare 声明只是设置这个符号的属性列表
#+BEGIN_SRC lisp 
  (symbol-plist 'when)    ; => (lisp-indent-function 1 edebug-form-spec t)
#+END_SRC

从前面宏 when 的定义可以看出直接使用 list，cons，append 构造宏是很麻烦的。为了使记号简洁，lisp 中有一个特殊的宏  _`_ ，称为 backquote：
+ 在这个宏里，所有的表达式都是引起（quote）的
+ 如果要让一个表达式不引起（也就是列表中使用的是表达式的值），需要在前面加 _,_
+ 如果要让一个列表作为整个列表的一部分（slice），可以用 _,@_ 

#+BEGIN_SRC lisp 
  `(a list of ,(+ 2 3) elements)          ; => (a list of 5 elements)
  (setq some-list '(2 3))                 ; => (2 3)
  `(1 ,some-list 4 ,@some-list)           ; => (1 (2 3) 4 2 3)
#+END_SRC

有了这些标记，前面 when 这个宏可以写成：

#+BEGIN_SRC lisp 
  (defmacro my-when (cond &rest body)
    `(if ,cond
	 (progn ,@body)))
#+END_SRC

#+BEGIN_EXAMPLE
注意：这个 backquote 本身就是一个宏
#+END_EXAMPLE
从这里可以看出宏除了 _减少重复代码_ 这个作用之外的另一个用途： *定义新的控制结构* ，甚至增加新的语法特性

* 命令

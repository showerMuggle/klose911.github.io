#+TITLE: Deployment
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../../css/main.css" />
#+HTML_LINK_UP: controller.html   
#+HTML_LINK_HOME: controller.html
#+OPTIONS: num:nil timestamp:nil ^:nil

Deployment 为 _Pod_ 和 _ReplicaSet_ 提供了一个 *声明式* 定义方法，用来替代以前的 ReplicationController 来方便的管理应用。典型的应用场景包括：
+ 定义 Deployment 来 *创建* _Pod_ 和 _ReplicaSet_
+ _滚动升级_ 和 _回滚_ 应用
+ _扩容_ 和 _缩容_
+ _暂停_ 和 _继续_ Deployment

比如一个简单的 nginx 应用可以定义为：

#+BEGIN_EXAMPLE
  apiVersion: extensions/v1beta1
  kind: Deployment
  metadata:
    name: nginx-deployment
  spec:
    replicas: 3
    template:
      metadata:
	labels:
	  app: nginx
      spec:
	containers:
	- name: nginx
	  image: nginx:1.7.9
	  ports:
	  - containerPort: 80
#+END_EXAMPLE

扩容：

#+BEGIN_SRC sh 
  kubectl scale deployment nginx-deployment --replicas 10
#+END_SRC

如果集群支持 horizontal pod autoscaling 的话，还可以为 Deployment 设置自动扩展：

#+BEGIN_SRC sh 
  kubectl autoscale deployment nginx-deployment --min=10 --max=15 --cpu-percent=80
#+END_SRC

更新镜像也比较简单：

#+BEGIN_SRC sh 
  kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1
#+END_SRC

回滚：

#+BEGIN_SRC sh 
  kubectl rollout undo deployment/nginx-deployment
#+END_SRC
* Deployment 结构示意图

  #+ATTR_HTML: image :width 70% 
  [[file:../../pic/deployment-cheatsheet.png]]
* 概念
  Deployment 为 Pod 和 Replica Set（下一代 Replication Controller）提供声明式更新

  #+BEGIN_EXAMPLE
    只需要在 Deployment 中描述您想要的目标状态是什么，Deployment controller 就会将 Pod 和 ReplicaSet 的实际状态改变到目标状态
  #+END_EXAMPLE

  可以定义一个全新的 Deployment 来创建 ReplicaSet 或者删除已有的 Deployment 并创建一个新的来替换

  #+BEGIN_EXAMPLE
    注意：不该手动管理由 Deployment 创建的 ReplicaSet，否则就篡越了 Deployment controller 的职责

  #+END_EXAMPLE

  典型的用例如下：
  + 使用 Deployment 来创建 ReplicaSet。ReplicaSet 在后台创建 pod。检查启动状态，看它是成功还是失败
  + 然后，通过更新 Deployment 的 _PodTemplateSpec_ 字段来声明 Pod 的新状态。这会创建一个新的 ReplicaSet，Deployment 会按照控制的速率将 pod 从旧的 ReplicaSet 移动到新的 ReplicaSet 中
  + 如果当前状态不稳定，回滚到之前的 Deployment _revision_ 。每次回滚都会更新 Deployment 的 revision
  + 扩容 Deployment 以满足更高的负载
  + 暂停 Deployment 来应用 PodTemplateSpec 的多个修复，然后恢复上线
  + 根据 Deployment 的状态判断上线是否 hang 住了
  + 清除旧的不必要的 ReplicaSet 
* 创建
  #+BEGIN_EXAMPLE
    下面是一个 Deployment 示例，它创建了一个 ReplicaSet 来启动 3 个 nginx pod
  #+END_EXAMPLE

  下载示例文件并执行命令：

  #+BEGIN_SRC sh 
  $ kubectl create -f https://kubernetes.io/docs/user-guide/nginx-deployment.yaml --record
  deployment "nginx-deployment" created
  #+END_SRC

  #+BEGIN_EXAMPLE
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: nginx-deployment
      labels:
	app: nginx
    spec:
      replicas: 3
      selector:
	matchLabels:
	  app: nginx
      template:
	metadata:
	  labels:
	    app: nginx
	spec:
	  containers:
	  - name: nginx
	    image: nginx:1.7.9
	    ports:
	    - containerPort: 80
  #+END_EXAMPLE

  将 kubectl 的 _--record_ 的 flag 设置为true 可以在 _annotation_ 中 *记录* 当前命令 _创建_ 或者 _升级_ 了该资源

  #+BEGIN_EXAMPLE
    这在未来会很有用，例如，查看在每个 Deployment revision 中执行了哪些命令
  #+END_EXAMPLE

  然后立即执行 get 将获得如下结果：

  #+BEGIN_SRC sh 
  $ kubectl get deployments
  NAME               READY   UP-TO-DATE   AVAILABLE   AGE
  nginx-deployment   3/0     0            0           1s
  #+END_SRC

  输出结果表明：
  + 希望的 repalica 数（根据 deployment 中的 _.spec.replicas_ 配置）是 3 
  + 当前 replica 数（ _.status.replicas_ ）是 0,
  + 最新的 replica 数（ _.status.updatedReplicas_ ）是 0
  + 可用的 replica 数（ _.status.availableReplicas_ ）是 0 

  过几秒后再执行 get 命令，将获得如下输出：
  #+BEGIN_SRC sh 
  $ kubectl get deployments
  NAME               READY   UP-TO-DATE   AVAILABLE   AGE
  nginx-deployment   3/3     3            3           18s
  #+END_SRC

  #+BEGIN_EXAMPLE
    可以看到 Deployment 已经创建了 3 个 replica，所有的 replica 都已经是最新的了（包含最新的 pod template），可用的（根据 Deployment 中的.spec.minReadySeconds声明，处于已就绪状态的 pod 的最少个数）
  #+END_EXAMPLE
  执行kubectl get rs和kubectl get pods会显示 _Replica Set_ 和 _Pod_ 已创建：

  #+BEGIN_SRC sh 
  $ kubectl get rs 
  NAME                          DESIRED   CURRENT   READY   AGE
  nginx-deployment-5d59d67564   3         3         3       5m45s
  #+END_SRC

  注意： ReplicaSet 的名字总是 _<Deployment 的名字>_ - _<pod template 的 hash 值>_ 

  #+BEGIN_SRC sh 
  $ kubectl get pods 
  NAME                                READY   STATUS    RESTARTS   AGE
  nginx-deployment-5d59d67564-7hk6b   2/2     Running   0          6m52s
  nginx-deployment-5d59d67564-h9l2x   2/2     Running   0          6m52s
  nginx-deployment-5d59d67564-tqnh5   2/2     Running   0          6m52s
  #+END_SRC

  #+BEGIN_EXAMPLE
    刚创建的 Replica Set 将保证总是有 3 个 nginx 的 pod 存在
  #+END_EXAMPLE

  注意： 必须在 _Deployment_ 中的 _selector_ 指定 *正确的 pod template label* 
  #+BEGIN_EXAMPLE
    在该示例中是 app = nginx
  #+END_EXAMPLE
  不要跟其他的 controller 的 selector 中指定的 pod template label 搞混了（包括 Deployment、Replica Set、Replication Controller 等）
  #+BEGIN_EXAMPLE
    Kubernetes 本身并不会阻止任意指定 pod template label，但是如果真的这么做了，这些 controller 之间会相互打架，并可能导致不正确的行为
  #+END_EXAMPLE
** Pod-template-hash label
   注意示例中的 pod label 里的 pod-template-hash label：
   + 当 Deployment 创建或者接管 ReplicaSet 时，Deployment controller 会自动为 Pod 添加 pod-template-hash label
   #+BEGIN_EXAMPLE
     这样做的目的是防止 Deployment 的子 ReplicaSet 的 pod 名字重复
   #+END_EXAMPLE
   + 通过将 ReplicaSet 的 _PodTemplate_ 进行 *哈希散列* ，使用生成的哈希值作为 label 的值，并添加到 _ReplicaSet selector_ 里、 _pod template label_ 和 _ReplicaSet 管理中的 Pod 上_ 
   #+BEGIN_EXAMPLE
     注意：这个 label 不是用户指定的！
   #+END_EXAMPLE
* 更新
  #+BEGIN_EXAMPLE
    注意：Deployment 的 rollout 当且仅当 Deployment 的 pod template（例如 .spec.template）中的 label 更新或者镜像更改时被触发

    其他更新，例如扩容 Deployment 不会触发 rollout
  #+END_EXAMPLE

  假如现在想要让 nginx pod 使用 nginx:1.16.1 的镜像来代替原来的 nginx:1.14.2 的镜像 
  #+BEGIN_SRC sh 
  $ kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
  deployment "nginx-deployment" image updated
  #+END_SRC

  可以使用edit命令来编辑 Deployment，修改.spec.template.spec.containers [0].image

  #+BEGIN_SRC sh 
  $ kubectl edit deployment/nginx-deployment
  deployment "nginx-deployment" edited
  #+END_SRC

  查看 rollout 的状态，只要执行：

  #+BEGIN_SRC sh 
  $ kubectl rollout status deployment/nginx-deployment 
  Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
  deployment "nginx-deployment" successfully rolled out
  #+END_SRC

  Rollout 成功后，getDeployment：

  #+BEGIN_SRC sh 
  $ kubectl get deployments
  NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
  nginx-deployment   3         3         3            3           36s
  #+END_SRC

  #+BEGIN_EXAMPLE
    UP-TO-DATE 的 replica 的数目已经达到了配置中要求的数目

    CURRENT 的 replica 数表示 Deployment 管理的 replica 数量

    AVAILABLE 的 replica 数是当前可用的 replica 数量
  #+END_EXAMPLE

  通过执行 _kubectl get rs_ 可以看到 Deployment 更新了 Pod，通过创建一个新的 ReplicaSet 并扩容了 3 个 replica，同时将原来的 ReplicaSet 缩容到了 0 个 replica

  #+BEGIN_SRC sh 
  $ kubectl get rs 
  NAME                          DESIRED   CURRENT   READY   AGE
  nginx-deployment-559d658b74   3         3         3       2m43s
  nginx-deployment-5d59d67564   0         0         0       3m49s
  #+END_SRC

  执行get pods只会看到当前的新的 pod：

  #+BEGIN_SRC sh 
  $ kubectl get pods 
  NAME                                READY   STATUS    RESTARTS   AGE
  nginx-deployment-559d658b74-f7r7t   2/2     Running   0          3m30s
  nginx-deployment-559d658b74-kvdql   2/2     Running   0          3m26s
  nginx-deployment-559d658b74-swzqk   2/2     Running   0          3m34s
  #+END_SRC

  + Deployment保证在升级时只有一定数量的 Pod 是 down 的。默认的，它会确保至少有比期望的 Pod 数量少一个是 up 状态（最多一个不可用）
  + Deployment 同时也可以确保只创建出超过期望数量的一定数量的 Pod。默认的，它会确保最多比期望的 Pod 数量多一个的 Pod 是 up 的（最多 1 个 surge ） 

  #+BEGIN_EXAMPLE
    例如，如果看下上面的 Deployment，会发现，开始创建一个新的 Pod，然后删除一些旧的 Pod 再创建一个新的，当新的 Pod 创建出来之前不会杀掉旧的 Pod

    这样能够确保可用的 Pod 数量至少有 2 个，Pod 的总数最多 4 个
  #+END_EXAMPLE

  #+BEGIN_SRC sh 
  $ kubectl describe deployments
  Name:           nginx-deployment
  Namespace:      default
  CreationTimestamp:  Tue, 15 Mar 2016 12:01:06 -0700
  Labels:         app=nginx
  Selector:       app=nginx
  Replicas:       3 updated | 3 total | 3 available | 0 unavailable
  StrategyType:       RollingUpdate
  MinReadySeconds:    0
  RollingUpdateStrategy:  1 max unavailable, 1 max surge
  OldReplicaSets:     <none>
  NewReplicaSet:      nginx-deployment-1564180365 (3/3 replicas created)
  Events:
    FirstSeen LastSeen    Count   From                     SubobjectPath   Type        Reason              Message
    --------- --------    -----   ----                     -------------   --------    ------              -------
    36s       36s         1       {deployment-controller}                 Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-2035384211 to 3
    23s       23s         1       {deployment-controller}                 Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 1
    23s       23s         1       {deployment-controller}                 Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 2
    23s       23s         1       {deployment-controller}                 Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 2
    21s       21s         1       {deployment-controller}                 Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 0
    21s       21s         1       {deployment-controller}                 Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 3
  #+END_SRC

  1. 刚开始创建这个 Deployment 的时候，创建了一个 ReplicaSet（nginx-deployment-2035384211），并直接扩容到了 3 个 replica
  2. 当更新这个 Deployment 的时候，它会创建一个新的 ReplicaSet（nginx-deployment-1564180365），将它扩容到 1 个 replica，然后缩容原先的 ReplicaSet 到 2 个 replica，此时满足至少 2 个 Pod 是可用状态，同一时刻最多有 4 个 Pod 处于创建的状态
  3. 接着继续使用相同的 rolling update 策略扩容新的 ReplicaSet 和缩容旧的 ReplicaSet
  4. 最终，将会在新的 ReplicaSet 中有 3 个可用的 replica，旧的 ReplicaSet 的 replica 数目变成 0

  #+BEGIN_EXAMPLE
    在未来的 Kuberentes 版本中，将从 1-1 变成 25%-25%
  #+END_EXAMPLE
** Rollover 
   #+BEGIN_EXAMPLE
     每当 Deployment controller 观测到有新的 deployment 被创建时，如果没有已存在的 ReplicaSet 来创建期望个数的 Pod 的话，就会创建出一个新的 ReplicaSet 来做这件事

     已存在的 ReplicaSet 控制 label 与 .spec.selector 匹配但是 template 跟 .spec.template 不匹配的 Pod 缩容

     最终，新的 ReplicaSet 将会扩容出 .spec.replicas 指定数目的 Pod，旧的 ReplicaSet 会缩容到 0
   #+END_EXAMPLE

   如果更新了一个的已存在并正在进行中的 Deployment，每次更新 Deployment 都会创建一个新的 ReplicaSet 并扩容它，同时 *回滚* 之前扩容的 ReplicaSet（将它添加到旧的 ReplicaSet 列表中，开始缩容）

   #+BEGIN_EXAMPLE
     例如，假如创建了一个有 5 个 niginx:1.7.9 replica 的 Deployment，但是当还只有 3 个 nginx:1.7.9 的 replica 创建出来的时候就开始更新含有 5 个 nginx:1.9.1 replica 的 Deployment

     在这种情况下，Deployment 会立即杀掉已创建的 3 个 nginx:1.7.9 的 Pod，并开始创建 nginx:1.9.1 的 Pod

     它不会等到所有的 5 个 nginx:1.7.9 的 Pod 都创建完成后才开始改变航道
   #+END_EXAMPLE
** Label Selector 更新

   #+BEGIN_EXAMPLE
     通常不鼓励更新 label selector，建议事先规划好您的 selector
   #+END_EXAMPLE
   任何情况下，只要想要执行 label selector 的更新，请一定要谨慎并确认已经预料到所有可能因此导致的后果：
   + 增添 selector 需要同时在 Deployment 的 spec 中更新新的 label，否则将返回校验错误
     #+BEGIN_EXAMPLE
       此更改是不可覆盖的，这意味着新的 selector 不会选择使用旧 selector 创建的 ReplicaSet 和 Pod，从而导致所有旧版本的 ReplicaSet 都被丢弃，并创建新的 ReplicaSet
     #+END_EXAMPLE
   + 更新 selector，即更改 selector key 的当前值，将导致跟增添 selector 同样的后果
   + 删除 selector，即删除 Deployment selector 中的已有的 key，不需要对 Pod template label 做任何更改，现有的 ReplicaSet 也不会成为孤儿
     #+BEGIN_EXAMPLE
       但是请注意，删除的 label 仍然存在于现有的 Pod 和 ReplicaSet 中
     #+END_EXAMPLE
* 回退

  #+BEGIN_EXAMPLE
    有时候可能想回退一个 Deployment，例如，当 Deployment 不稳定时，比如一直 crash looping
  #+END_EXAMPLE

  默认情况下，kubernetes 会在系统中保存前两次的 Deployment 的 rollout 历史记录，以便可以随时回退（可以修改 _revision history limit_ 来更改保存的 revision 数） 

  #+BEGIN_EXAMPLE
    注意：只有 Deployment 的 rollout 被触发就会创建一个 revision，也就是说当且仅当 Deployment 的 Pod template（如 .spec.template）被更改

    例如更新 template 中的 label 和容器镜像时，就会创建出一个新的 revision，其他的更新，比如扩容 Deployment 不会创建 revision

    因此可以很方便的手动或者自动扩容。这意味着当回退到历史 revision 时，只有 Deployment 中的 Pod template 部分才会回退
  #+END_EXAMPLE

  假设在更新 Deployment 的时候犯了一个拼写错误，将镜像的名字写成了 nginx:1.91，而正确的名字应该是 nginx:1.9.1：

  #+BEGIN_SRC sh 
  $ kubectl set image deployment/nginx-deployment nginx=nginx:1.91
  deployment "nginx-deployment" image updated
  #+END_SRC

  Rollout 将会卡住：

  #+BEGIN_SRC sh 
  $ kubectl rollout status deployments nginx-deployment
  Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
  #+END_SRC

  按住 Ctrl-C 停止上面的 rollout 状态监控。查看 rs 会发现旧的 replica（nginx-deployment-1564180365 和 nginx-deployment-2035384211）和新的 replica （nginx-deployment-3066724191）数目都是 2 个　

  #+BEGIN_SRC sh 
  $ kubectl get rs
  NAME                          DESIRED   CURRENT   READY   AGE
  nginx-deployment-1564180365   2         2         0       25s
  nginx-deployment-2035384211   0         0         0       36s
  nginx-deployment-3066724191   2         2         2       6s
  #+END_SRC

  看下 Pod，会看到有两个新的 ReplicaSet 创建的 Pod 处于 ImagePullBackOff 状态，循环拉取镜像

  #+BEGIN_SRC sh 
  $ kubectl get pods
  NAME                                READY     STATUS             RESTARTS   AGE
  nginx-deployment-1564180365-70iae   1/1       Running            0          25s
  nginx-deployment-1564180365-jbqqo   1/1       Running            0          25s
  nginx-deployment-3066724191-08mng   0/1       ImagePullBackOff   0          6s
  nginx-deployment-3066724191-eocby   0/1       ImagePullBackOff   0          6s
  #+END_SRC

  注意，Deployment controller 会自动停止坏的 rollout，并停止扩容新的 ReplicaSet

  #+BEGIN_SRC sh 
  $ kubectl describe deployment
  Name:           nginx-deployment
  Namespace:      default
  CreationTimestamp:  Tue, 15 Mar 2016 14:48:04 -0700
  Labels:         app=nginx
  Selector:       app=nginx
  Replicas:       2 updated | 3 total | 2 available | 2 unavailable
  StrategyType:       RollingUpdate
  MinReadySeconds:    0
  RollingUpdateStrategy:  1 max unavailable, 1 max surge
  OldReplicaSets:     nginx-deployment-1564180365 (2/2 replicas created)
  NewReplicaSet:      nginx-deployment-3066724191 (2/2 replicas created)
  Events:
    FirstSeen LastSeen    Count   From                    SubobjectPath   Type        Reason              Message
    --------- --------    -----   ----                    -------------   --------    ------              -------
    1m        1m          1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-2035384211 to 3
    22s       22s         1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 1
    22s       22s         1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 2
    22s       22s         1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 2
    21s       21s         1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 0
    21s       21s         1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 3
    13s       13s         1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-3066724191 to 1
    13s       13s         1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-1564180365 to 2
    13s       13s         1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-3066724191 to 2
  #+END_SRC

  为了修复这个问题，需要 *回退* 到稳定的 Deployment revision
** 检查 Deployment 升级的历史记录
   首先，检查下 Deployment 的 revision：

   #+BEGIN_SRC sh 
  $ kubectl rollout history deployment/nginx-deployment
  deployments "nginx-deployment":
  REVISION    CHANGE-CAUSE
  1           kubectl create -f https://kubernetes.io/docs/user-guide/nginx-deployment.yaml--record
  2           kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1
  3           kubectl set image deployment/nginx-deployment nginx=nginx:1.91
   #+END_SRC

   #+BEGIN_EXAMPLE
     因为创建 Deployment 的时候使用了--record 参数可以记录命令，可以很方便的查看每次 revision 的变化
   #+END_EXAMPLE

   查看单个 revision 的详细信息：
   #+BEGIN_SRC sh 
  $ kubectl rollout history deployment/nginx-deployment --revision=2
  deployments "nginx-deployment" revision 2
    Labels:       app=nginx
	    pod-template-hash=1159050644
    Annotations:  kubernetes.io/change-cause=kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1
    Containers:
     nginx:
      Image:      nginx:1.9.1
      Port:       80/TCP
       QoS Tier:
	  cpu:      BestEffort
	  memory:   BestEffort
      Environment Variables:      <none>
    No volumes.
   #+END_SRC
** 回退到历史版本
   现在，可以决定回退当前的 rollout 到之前的版本：

   #+BEGIN_SRC sh 
  $ kubectl rollout undo deployment/nginx-deployment
  deployment "nginx-deployment" rolled back
   #+END_SRC
   也可以使用--revision参数指定某个历史版本：

   #+BEGIN_SRC sh 
  $ kubectl rollout undo deployment/nginx-deployment --to-revision=2
  deployment "nginx-deployment" rolled back
   #+END_SRC

   该 Deployment 现在已经回退到了先前的稳定版本。Deployment controller 产生了一个回退到 revison 2 的DeploymentRollback的 event 

   #+BEGIN_SRC sh 
  $ kubectl get deployment
  NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
  nginx-deployment   3         3         3            3           30m

  $ kubectl describe deployment
  Name:           nginx-deployment
  Namespace:      default
  CreationTimestamp:  Tue, 15 Mar 2016 14:48:04 -0700
  Labels:         app=nginx
  Selector:       app=nginx
  Replicas:       3 updated | 3 total | 3 available | 0 unavailable
  StrategyType:       RollingUpdate
  MinReadySeconds:    0
  RollingUpdateStrategy:  1 max unavailable, 1 max surge
  OldReplicaSets:     <none>
  NewReplicaSet:      nginx-deployment-1564180365 (3/3 replicas created)
  Events:
    FirstSeen LastSeen    Count   From                    SubobjectPath   Type        Reason              Message
    --------- --------    -----   ----                    -------------   --------    ------              -------
    30m       30m         1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-2035384211 to 3
    29m       29m         1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 1
    29m       29m         1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 2
    29m       29m         1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 2
    29m       29m         1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 0
    29m       29m         1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-3066724191 to 2
    29m       29m         1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-3066724191 to 1
    29m       29m         1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-1564180365 to 2
    2m        2m          1       {deployment-controller}                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-3066724191 to 0
    2m        2m          1       {deployment-controller}                Normal      DeploymentRollback  Rolled back deployment "nginx-deployment" to revision 2
    29m       2m          2       {deployment-controller}                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 3
   #+END_SRC
** 清理 Policy
   可以通过设置 _.spec.revisonHistoryLimit_ 项来指定 deployment 最多保留多少 revision 历史记录：
   + 默认的会保留所有的 revision
   + 如果将该项设置为 0，Deployment 就不允许回退了 
* 扩容
  可以使用以下命令扩容 Deployment：
  #+BEGIN_SRC sh 
  $ kubectl scale deployment nginx-deployment --replicas 10
  #+END_SRC

  假设集群中启用了 _horizontal pod autoscaling_ ，可以给 Deployment 设置一个 autoscale，基于当前 Pod 的 *CPU 利用率* 选择 _最少_ 和 _最多_ 的 Pod 数 

  #+BEGIN_SRC sh 
  $ kubectl autoscale deployment nginx-deployment --min=10 --max=15 --cpu-percent=80
  deployment "nginx-deployment" autoscaled
  #+END_SRC
** 比例扩容
   RollingUpdate Deployment 支持同时运行一个应用的多个版本。或者 autoscaler 扩容 RollingUpdate Deployment 的时候，正在中途的 rollout（进行中或者已经暂停的），为了降低风险，Deployment controller 将会 *平衡& _已存在的活动中的 ReplicaSet_ （有 Pod 的 ReplicaSet）和 _新加入的 Replicaset_ 。这被称为 _比例扩容_ 

   #+BEGIN_EXAMPLE
   例如，正在运行中含有 10 个 replica 的 Deployment。maxSurge=3，maxUnavailable=2
   #+END_EXAMPLE

   #+BEGIN_SRC sh 
  $ kubectl get deploy
  NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
  nginx-deployment     10        10        10           10          50s
   #+END_SRC

   更新了一个镜像，而在集群内部无法解析 

   #+BEGIN_SRC sh 
  $ kubectl set image deploy/nginx-deployment nginx=nginx:sometag
  deployment "nginx-deployment" image updated
   #+END_SRC

   镜像更新启动了一个包含 ReplicaSet _nginx-deployment-1989198191_ 的新的 rollout，但是它被阻塞了，因为上面提到的 maxUnavailable 

   #+BEGIN_SRC sh 
  $ kubectl get rs
  NAME                          DESIRED   CURRENT   READY     AGE
  nginx-deployment-1989198191   5         5         0         9s
  nginx-deployment-618515232    8         8         8         1m
   #+END_SRC

   然后发起了一个新的 Deployment 扩容请求。autoscaler 将 Deployment 的 replica 数目增加到了 15 个。Deployment controller 需要判断在哪里增加这 5 个新的 replica：
   + 如果没有用比例扩容，所有的 5 个 replica 都会加到一个新的 ReplicaSet 中
   + 如果使用比例扩容，新添加的 replica 将传播到所有的 ReplicaSet 中
     + 大的部分加入 replica 数最多的 ReplicaSet 中
     + 小的部分加入到 replica 数少的 ReplciaSet 中
     + 0 个 replica 的 ReplicaSet 不会被扩容 

   #+BEGIN_EXAMPLE
     在上面的例子中，3 个 replica 将添加到旧的 ReplicaSet 中，2 个 replica 将添加到新的 ReplicaSet 中

     rollout 进程最终会将所有的 replica 移动到新的 ReplicaSet 中，假设新的 replica 成为健康状态
   #+END_EXAMPLE

   #+BEGIN_SRC sh 
  $ kubectl get deploy
  NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
  nginx-deployment     15        18        7            8           7m
  $ kubectl get rs
  NAME                          DESIRED   CURRENT   READY     AGE
  nginx-deployment-1989198191   7         7         0         7m
  nginx-deployment-618515232    11        11        11        7m
   #+END_SRC



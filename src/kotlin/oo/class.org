#+TITLE: 类与继承
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+HTML_LINK_HOME: ./oo.html
#+OPTIONS: num:nil timestamp:nil 
* 类

  Kotlin 中使用关键字 class 声明类

  #+BEGIN_SRC kotlin 
  class Invoice { /*……*/ }
  #+END_SRC

  类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成。类头与类体都是可选的； 如果一个类没有类体，可以省略花括号。

  #+BEGIN_SRC kotlin
  class Empty
  #+END_SRC
** 构造函数
   在 Kotlin 中的一个类可以有 _一个_ *主构造函数* 以及 _一个或多个_ *次构造函数* 。主构造函数是 _类头_ 的一部分：它跟在 _类名_ （与可选的类型参数）后。

   #+BEGIN_SRC kotlin 
  class Person constructor(firstName: String) { /*……*/ }
   #+END_SRC

   如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 _constructor_ 关键字：

   #+BEGIN_SRC kotlin
  class Person(firstName: String) { /*……*/ }
   #+END_SRC

   主构造函数不能包含任何的代码

   #+BEGIN_EXAMPLE
     初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中
   #+END_EXAMPLE

   在 _实例初始化_ 期间，初始化块按照它们出现在 _类体中的顺序_ 执行，与 _属性初始化器_ 交织在一起：

   #+BEGIN_SRC kotlin 

  //sampleStart
  class InitOrderDemo(name: String) {
      val firstProperty = "First property: $name".also(::println)

      init {
	  println("First initializer block that prints ${name}")
      }

      val secondProperty = "Second property: ${name.length}".also(::println)

      init {
	  println("Second initializer block that prints ${name.length}")
      }
  }
  //sampleEnd

  fun main() {
      InitOrderDemo("hello")
  }
   #+END_SRC

   请注意， _主构造的参数_ 可以在 _初始化块_ 中使用。它们也可以在类体内声明的 _属性初始化器_ 中使用：

   #+BEGIN_SRC kotlin 
  class Customer(name: String) {
      val customerKey = name.toUpperCase()
  }
   #+END_SRC


   事实上，声明属性以及从主构造函数初始化属性，Kotlin 有简洁的语法：

   #+BEGIN_SRC kotlin 
  class Person(val firstName: String, val lastName: String, var age: Int) { /*……*/ }
   #+END_SRC

   #+BEGIN_EXAMPLE
     与普通属性一样，主构造函数中声明的属性可以是可变的 var 或只读的 val 
   #+END_EXAMPLE


   如果构造函数有 _注解_ 或 _可见性_ 修饰符，这个 _constructor_ *关键字* 是必需的，并且这些修饰符在它前面：

   #+BEGIN_SRC kotlin 
  class Customer public @Inject constructor(name: String) { /*……*/ }
   #+END_SRC
*** 次构造函数
    类也可以声明前缀有 _constructor_ 的 *次构造函数* ： 

    #+BEGIN_SRC kotlin 
  class Person {
      var children: MutableList<Person> = mutableListOf<Person>();
      constructor(parent: Person) {
	  parent.children.add(this)
      }
  }
    #+END_SRC

    如果类有一个主构造函数，每个次构造函数需要 *委托* 给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 _this_ 关键字即可：

    #+BEGIN_SRC kotlin 
  class Person(val name: String) {
      var children: MutableList<Person> = mutableListOf<Person>();
      constructor(name: String, parent: Person) : this(name) {
	  parent.children.add(this)
      }
  }
    #+END_SRC
    请注意：
    + _初始化块_ 中的代码实际上会成为 _主构造函数的一部分_ 
    + *委托* 给 _主构造函数_ 会作为 _次构造函数_ 的 _第一条语句_

    #+BEGIN_EXAMPLE
      因此所有初始化块与属性初始化器中的代码都会在次构造函数体之前执行

      即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块
    #+END_EXAMPLE

    #+BEGIN_SRC kotlin 
  //sampleStart
  class Constructors {
      init {
	  println("Init block")
      }

      constructor(i: Int) {
	  println("Constructor")
      }
  }
  //sampleEnd

  fun main() {
      Constructors(1)
  }
    #+END_SRC

    如果一个非抽象类没有声明任何（主或次）构造函数，它会有一个生成的 _不带参数的_ 主构造函数。构造函数的 _默认可见性_ 是 _public_ 。如果不希望类有一个公有构造函数，需要声明一个带有 *非默认可见性* 的空的主构造函数：

    #+BEGIN_SRC kotlin 
  class DontCreateMe private constructor () { /*……*/ }
    #+END_SRC

    #+BEGIN_EXAMPLE
      注意：在 JVM 上，如果主构造函数的所有的参数都有默认值，编译器会生成 一个额外的无参构造函数，它将使用默认值

      这使得 Kotlin 更易于使用像 Jackson 或者 JPA 这样的通过无参构造函数创建类的实例的库
    #+END_EXAMPLE

    #+BEGIN_SRC kotlin 
  class Customer(val customerName: String = "")
    #+END_SRC
** 创建类的实例

   要创建一个类的实例，就像普通函数一样调用构造函数：

   #+BEGIN_SRC kotlin 
  val invoice = Invoice()

  val customer = Customer("Joe Smith")
   #+END_SRC

   #+BEGIN_EXAMPLE
     注意 Kotlin 并没有 new 关键字
   #+END_EXAMPLE
** 类成员
   类可以包含：
   + 构造函数与初始化块
   + 函数
   + 属性
   + 嵌套类与内部类
   + 对象声明
* 继承

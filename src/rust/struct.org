#+TITLE: 结构体
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: ownership.html   
#+HTML_LINK_HOME: rust.html
#+OPTIONS: num:nil timestamp:nil ^:nil

_struct_ ，是一个 _自定义数据类型_ ，允许 *命名和包装* _多个相关的值_ ，从而形成一个 *有意义的组合* 

#+BEGIN_EXAMPLE
  如果熟悉一门面向对象语言，struct 就像Class

  在本章中，会对比元组与结构体的异同，演示结构体的用法，并讨论如何在结构体上定义方法和关联函数来指定与结构体数据相关的行为
#+END_EXAMPLE
* 定义

#+BEGIN_EXAMPLE
  结构体和以前讨论过的元组类似：和元组一样，结构体的每一部分可以是不同类型

  但不同于元组，结构体需要命名各部分数据以便能清楚的表明其值的意义
  由于有了这些名字，结构体比元组更灵活：不需要依赖顺序来指定或访问实例中的值
#+END_EXAMPLE

定义结构体，需要使用 _struct_ 关键字：
+ 为整个结构体提供一个 _名字_ ，结构体的名字需要描述它所组合的数据的意义
+ 在 _大括号_ 中，定义每一部分数据的名字和类型，称为 _字段_ 

下面示例展示了一个存储用户账号信息的结构体：
#+BEGIN_SRC rust 
  struct User {
      username: String,
      email: String,
      sign_in_count: u64,
      active: bool,
  }
#+END_SRC

一旦定义了结构体后，为了使用它，通过给 _每个字段_ *指定* _具体值_ 来 *创建* 这个结构体的 _实例_ ：
+ 创建一个实例需要以 _结构体的名字_ 开头
+ 在 _大括号_ 中使用 _key: value_ 键-值对的形式提供字段
  + key: _字段的名字_ 
  + value: 需要存储在 _字段中的数据值_ 
+ 实例中 *字段的顺序不需要和它们在结构体中声明的顺序一致* 

#+BEGIN_EXAMPLE
  换句话说：结构体的定义就像一个类型的通用模板
  而实例则会在这个模板中放入特定数据来创建这个类型的值
#+END_EXAMPLE

例如，可以像下面实例这样来声明一个特定的用户：
#+BEGIN_SRC rust 
  let user1 = User {
      email: String::from("someone@example.com"),
      username: String::from("someusername123"),
      active: true,
      sign_in_count: 1,
  };
#+END_SRC

+ 为了从结构体中 *获取* 某个特定的值，可以使用 _点号_ ：如果只想要用户的邮箱地址，可以用 user1.email
+ 要 *更改* 结构体中的值，如果 _结构体的实例_ 是 _可变的_ ，可以使用 _点号_ 并为对应的 *字段赋值* 

下面示例展示了如何改变一个可变的 User 实例 email 字段的值：
#+BEGIN_SRC rust 
  let mut user1 = User {
      email: String::from("someone@example.com"),
      username: String::from("someusername123"),
      active: true,
      sign_in_count: 1,
  };

  user1.email = String::from("anotheremail@example.com");
#+END_SRC

#+BEGIN_EXAMPLE
  注意：“整个实例”必须是可变的

  Rust 并不允许只将某个字段标记为可变
#+END_EXAMPLE

同其他任何表达式一样，可以在 _函数体的最后一个表达式_ 中 *构造* 一个 _结构体的新实例_ ，来 *隐式* 地 _返回_ 这个实例。下面显示了一个 build_user 函数，它返回一个带有给定的 email 和用户名的 User 结构体实例。active 字段的值为 true，并且 sign_in_count 的值为 1：

#+BEGIN_SRC rust 
  fn build_user(email: String, username: String) -> User {
      User {
	  email: email,
	  username: username,
	  active: true,
	  sign_in_count: 1,
      }
  }
#+END_SRC

#+BEGIN_EXAMPLE
  为函数参数起与结构体字段相同的名字是可以理解的，但是不得不重复 email 和 username 字段名称与变量有些啰嗦。如果要重复更多这样的字段就显得更加烦人

  幸运的是，rust提供了一些简便的方式
#+END_EXAMPLE
** 简化语法
*** 变量与字段同名时的字段初始化
函数的参数名与字段名都完全相同，可以使用 _字段初始化简写语法_ 来重写 build_user，这样其行为与之前完全相同，不过无需重复 email 和 username 了，如示例所示：

#+BEGIN_SRC rust 
  fn build_user(email: String, username: String) -> User {
      User {
	  email,
	  username,
	  active: true,
	  sign_in_count: 1,
      }
  }
#+END_SRC

#+BEGIN_EXAMPLE
  这里创建了一个新的 User 结构体实例，它有一个叫做 email 的字段，然后想要将 email 字段的值设置为 build_user 函数 email 参数的值

  因为 email 字段与 email 参数有着相同的名称，则只需编写 email 而不是 email: email
#+END_EXAMPLE
*** 使用结构体更新语法从其他实例创建实例
#+BEGIN_EXAMPLE
  使用旧实例的大部分值，但改变其部分值来创建一个新的结构体实例，通常是很有帮助的
#+END_EXAMPLE
这可以通过 _结构体更新语法_ 实现。首先，示例展示了不使用更新语法时，如何在 user2 中创建一个新 User 实例。为 email 和 username 设置了新的值，其他值则使用了前面创建的 user1 中的同名值：

#+BEGIN_SRC rust 
  let user2 = User {
      email: String::from("another@example.com"),
      username: String::from("anotherusername567"),
      active: user1.active,
      sign_in_count: user1.sign_in_count,
  };
#+END_SRC

使用结构体更新语法，通过更少的代码来达到相同的效果： _.._  语法指定了 *剩余未显式设置值* 的字段应有与 _给定实例_ 对应字段相同的值。如下所示：

#+BEGIN_SRC rust 
  let user2 = User {
      email: String::from("another@example.com"),
      username: String::from("anotherusername567"),
      ..user1
  };
#+END_SRC

#+BEGIN_EXAMPLE
  在 user2 中创建了一个新实例，其有不同的 email 和 username 值

  不过 active 和 sign_in_count 字段的值与 user1 相同
#+END_EXAMPLE
*** 使用没有命名字段的元组结构体来创建不同的类型
也可以定义与元组类似的结构体，称为 _元组结构体_ ：元组结构体有着 _结构体名称_ 提供的含义，但 *没有具体的字段名* ，只有 *字段的类型* 
#+BEGIN_EXAMPLE
  当想给整个元组取一个名字，并使元组成为与其他元组不同的类型时，元组结构体是很有用的

  这时像常规结构体那样为每个字段命名就显得多余和形式化了
#+END_EXAMPLE

要定义元组结构体，以 _struct_ 关键字和 _结构体名_ 开头并后跟 _元组中的类型_ 。例如，下面是两个分别叫做 Color 和 Point 元组结构体的定义和用法：

#+BEGIN_SRC rust 
  struct Color(i32, i32, i32);
  struct Point(i32, i32, i32);

  let black = Color(0, 0, 0);
  let origin = Point(0, 0, 0);
#+END_SRC

#+BEGIN_EXAMPLE
  注意： black 和 origin 值的类型不同，因为它们是不同的元组结构体的实例
#+END_EXAMPLE

+ 定义的每一个结构体有其自己的类型，即使结构体中的字段有着相同的类型。例如，一个获取 Color 类型参数的函数不能接受 Point 作为参数，即便这两个类型都由三个 i32 值组成
+ 在其他方面，元组结构体实例类似于元组：可以将其解构为单独的部分，也可以使用 _._  后跟索引来访问单独的值
*** 没有任何字段的类单元结构体
也可以定义一个 *没有任何字段* 的结构体，这被称为 _类单元结构体_ 因为它们类似于 *()* ，即 _unit 类型_ 

#+BEGIN_EXAMPLE
  类单元结构体常常在想要在某个类型上实现 trait ，但不需要在类型中存储数据的时候发挥作用
#+END_EXAMPLE
** 结构体的所有权
在 User 结构体的定义中，使用了 *自身拥有所有权* 的 _String 类型_ 而不是  _&str_ 字符串 *slice 类型* 。这是一个有意而为之的选择，因为想要这个 *结构体拥有它所有的数据* ，为此 *只要整个结构体是有效的话其数据也是有效的* 

#+BEGIN_EXAMPLE
  可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上“生命周期”

  生命周期确保“结构体引用的数据有效性”跟 “结构体本身”保持一致
#+END_EXAMPLE

如果尝试在结构体中存储一个 _引用_ 而 *不指定生命周期* 将是无效的，比如这样：

#+BEGIN_SRC rust 
  struct User {
      username: &str,
      email: &str,
      sign_in_count: u64,
      active: bool,
  }

  fn main() {
      let user1 = User {
	  email: "someone@example.com",
	  username: "someusername123",
	  active: true,
	  sign_in_count: 1,
      };
  }
#+END_SRC

编译器会报错：
#+BEGIN_SRC sh 
  error[E0106]: missing lifetime specifier
   --> src/main.rs:2:15
    |
  2 |     username: &str,
    |               ^ expected lifetime parameter

  error[E0106]: missing lifetime specifier
   --> src/main.rs:3:12
    |
  3 |     email: &str,
    |            ^ expected lifetime parameter

  error: aborting due to 2 previous errors

  For more information about this error, try `rustc --explain E0106`.
  error: could not compile `reference_without_lifetime`.
#+END_SRC
* 实例

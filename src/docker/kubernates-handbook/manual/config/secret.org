#+TITLE: Secret 配置
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../../css/main.css" />
#+HTML_LINK_UP: probness.html
#+HTML_LINK_HOME: config.html
#+OPTIONS: num:nil timestamp:nil ^:nil

Secret 对象类型用来保存 *敏感* 信息

#+begin_example
  例如密码、OAuth 令牌和 ssh key
#+end_example

将这些信息放在 secret 中比放在 pod 的定义中或者 docker 镜像中来说更加安全和灵活
* 概览
Secret 是一种包含少量敏感信息例如密码、token 或 key 的对象。这样的信息可能会被放在 Pod spec 中或者镜像中

#+BEGIN_EXAMPLE
  将其放在一个 secret 对象中可以更好地控制它的用途，并降低意外暴露的风险
#+END_EXAMPLE

用户可以创建 secret，同时系统也创建了一些 secret 

要使用 secret，pod 需要引用 secret。Pod 可以用两种方式使用 secret：
1. 作为 volume 中的文件被挂载到 pod 中的一个或者多个容器里
2. 当 kubelet 为 pod 拉取镜像时使用
** 内置 secret
*** Service Account 使用 API 凭证自动创建和附加 secret
Kubernetes 自动创建包含访问 API 凭据的 secret，并自动修改 pod 以使用此类型的 secret

#+BEGIN_EXAMPLE
  如果需要，可以禁用或覆盖自动创建和使用API凭据

  但是，如果需要的只是安全地访问 apiserver，推荐这样的工作流程
#+END_EXAMPLE
** 创建 
*** 使用 kubectl 
假设有些 pod 需要访问数据库。这些 pod 需要使用的用户名和密码在本地机器的 ./username.txt 和 ./password.txt 文件里：

#+BEGIN_SRC sh 
  # Create files needed for rest of example.
  $ echo -n "admin" > ./username.txt
  $ echo -n "1f2d1e2e67df" > ./password.txt
#+END_SRC

kubectl create secret 命令将这些文件打包到一个 Secret 中并在 API server 中创建了一个对象：

#+BEGIN_SRC sh 
  $ kubectl create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txt
  secret "db-user-pass" created
#+END_SRC

可以这样检查刚创建的 secret：

#+BEGIN_SRC sh 
  $ kubectl get secrets
  NAME                  TYPE                                  DATA      AGE
  db-user-pass          Opaque                                2         51s

  $ kubectl describe secrets/db-user-pass
  Name:            db-user-pass
  Namespace:       default
  Labels:          <none>
  Annotations:     <none>

  Type:            Opaque

  Data
  ====
  password.txt:    12 bytes
  username.txt:    5 bytes
#+END_SRC

#+BEGIN_EXAMPLE
  请注意，默认情况下，get 和 describe 命令都不会显示文件的内容

  这是为了防止将 secret 中的内容被意外暴露给从终端日志记录中刻意寻找它们的人
#+END_EXAMPLE
*** 手动创建 
可以先以 json 或 yaml 格式在文件中创建一个 secret 对象，然后创建该对象：

#+BEGIN_SRC sh 
  $ echo -n "admin" | base64
  YWRtaW4=
  $ echo -n "1f2d1e2e67df" | base64
  MWYyZDFlMmU2N2Rm
#+END_SRC

#+BEGIN_EXAMPLE
  每一项必须是 base64 编码
#+END_EXAMPLE

现在可以像这样写一个 secret 对象：

#+BEGIN_EXAMPLE
  apiVersion: v1
  kind: Secret
  metadata:
    name: mysecret
  type: Opaque
  data:
    username: YWRtaW4=
    password: MWYyZDFlMmU2N2Rm
#+END_EXAMPLE

  数据字段是一个映射。它的键必须匹配 DNS_SUBDOMAIN，前导点也是可以的。这些值可以是任意数据，使用 base64 进行编码。使用 kubectl create创建 secret：
#+BEGIN_SRC sh 
  $ kubectl create -f ./mysecret.yaml
  secret "mysecret" created
#+END_SRC

#+BEGIN_EXAMPLE
  编码注意： secret 数据的序列化 JSON 和 YAML 值使用 base64 编码成字符串。另外：

  1. 换行符在这些字符串中无效，必须省略

  2. 当在Darwin/OS X上使用 base64 实用程序时，用户应避免使用 -b 选项来拆分长行

  3. 对于 Linux用户如果 -w 选项不可用的话，应该添加选项 -w 0 到 base64 命令或管道 base64 | tr -d '\n' 
#+END_EXAMPLE
*** 解码 Secret
可以使用 kubectl get secret 命令获取 secret。例如，获取在上一节中创建的 secret：

#+BEGIN_SRC sh 
  $ kubectl get secret mysecret -o yaml
  apiVersion: v1
  data:
    username: YWRtaW4=
    password: MWYyZDFlMmU2N2Rm
  kind: Secret
  metadata:
    creationTimestamp: 2016-01-22T18:41:56Z
    name: mysecret
    namespace: default
    resourceVersion: "164619"
    selfLink: /api/v1/namespaces/default/secrets/mysecret
    uid: cfee02d6-c137-11e5-8d73-42010af00002
  type: Opaque
#+END_SRC

解码密码字段：

#+BEGIN_SRC sh 
  $ echo "MWYyZDFlMmU2N2Rm" | base64 --decode
  1f2d1e2e67df
#+END_SRC

** 使用

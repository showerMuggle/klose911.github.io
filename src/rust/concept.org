#+TITLE: 基础概念
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: start.html   
#+HTML_LINK_HOME: rust.html
#+OPTIONS: num:nil timestamp:nil ^:nil

#+BEGIN_EXAMPLE
  本章介绍一些几乎所有编程语言都有的概念，以及它们在 Rust 中是如何工作的

  很多编程语言的核心概念都是共通的，本章中展示的概念都不是 Rust 所特有的，不过会在 Rust 上下文中讨论它们，并解释使用这些概念的惯例
#+END_EXAMPLE

具体来说，将会学习 _变量_ 、 _基本类型_ 、 _函数_ 、 _注释_ 和 _控制流_ 

#+BEGIN_EXAMPLE
  每一个 Rust 程序中都会用到这些基础知识，提早学习这些概念会让人在起步时就打下坚实的基础
#+END_EXAMPLE
* 变量

** 不变性
#+BEGIN_EXAMPLE
  前面提到过，变量默认是不可改变的。这是推动充分利用 Rust 提供的安全性和简单并发性来编写代码的众多方式之一

  不过，仍然可以使用可变变量。先来探讨一下 Rust 拥抱不可变性的原因及方法，以及何时不想使用不可变性
#+END_EXAMPLE

当变量不可变时，一旦值被绑定一个名称上，就不能改变这个值。为了对此进行说明，使用 _cargo new variables_ 命令在 projects 目录生成一个叫做 variables 的新项目。

接着，在新建的 variables 目录，打开 src/main.rs 并将代码替换为如下代码，这些代码还不能编译：

#+BEGIN_SRC rust
  fn main() {
      let x = 5;
      println!("The value of x is: {}", x);
      x = 6;
      println!("The value of x is: {}", x);
  }
#+END_SRC

保存并使用 cargo build 运行程序。应该会看到一条错误信息，如下输出所示：
#+BEGIN_SRC sh 
  $ cargo build
     Compiling variables v0.1.0 (/home/i514692/Documents/programming/html/klose911.github.io/src/rust/src/variables)
  error[E0384]: cannot assign twice to immutable variable `x`
   --> src/main.rs:4:5
    |
  2 |     let x = 5;
    |         -
    |         |
    |         first assignment to `x`
    |         help: make this binding mutable: `mut x`
  3 |     println!("The value of x is: {}", x);
  4 |     x = 6;
    |     ^^^^^ cannot assign twice to immutable variable

  error: aborting due to previous error

  For more information about this error, try `rustc --explain E0384`.
  error: could not compile `variables`.

  To learn more, run the command again with --verbose.
#+END_SRC

错误信息指出错误的原因是 *不能对不可变变量 x 二次赋值* (cannot assign twice to immutable variable x)

#+BEGIN_EXAMPLE
  Rust 编译器保证，如果声明一个值不会变，它就真的不会变

  这意味着当阅读和编写代码时，不需要追踪一个值如何和在哪可能会被改变，从而使得代码易于推导
#+END_EXAMPLE

不过可变性也是非常有用的。变量只是默认不可变：可以在变量名之前加 _mut_ 来使其可变

#+BEGIN_EXAMPLE
  除了允许改变值之外，mut 向代码阅读者表明了其他代码将会改变这个变量值的意图
#+END_EXAMPLE

例如，将 src/main.rs 修改为如下代码：

#+BEGIN_SRC rust 
  fn main() {
      let mut x = 5;
      println!("The value of x is: {}", x);
      x = 6;
      println!("The value of x is: {}", x);
  }
#+END_SRC

现在运行这个程序：

#+BEGIN_SRC sh 
  $ cargo run
     Compiling variables v0.1.0 (/home/i514692/Documents/programming/html/klose911.github.io/src/rust/src/variables)
      Finished dev [unoptimized + debuginfo] target(s) in 0.81s
       Running `target/debug/variables`
  The value of x is: 5
  The value of x is: 6
#+END_SRC

通过 mut，允许把绑定到 x 的值从 5 改成 6。在一些情况下，会想用可变变量，因为与只用不可变变量相比，它会让 *代码更容易编写* 

#+BEGIN_EXAMPLE
  除了防止出现 bug 外，还有很多地方需要权衡取舍

  例如，使用大型数据结构时，适当地使用可变变量，可能比复制和返回新分配的实例更快
  对于较小的数据结构，总是创建新实例，采用更偏向函数式的编程风格，可能会使代码更易理解，为可读性而牺牲性能或许是值得的。
#+END_EXAMPLE

** 变量和常量的区别
#+BEGIN_EXAMPLE
  不允许改变值的变量，可能会使你想起另一个大部分编程语言都有的概念：常量
#+END_EXAMPLE

类似于不可变变量，常量是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别：
+ *不允许对常量使用 mut* ：常量不光默认不能变，它 *总是不能变*
+ 声明常量使用 *const* 关键字而不是 _let_ ，并且 *必须注明值的类型* 
#+BEGIN_EXAMPLE
  在下一部分，“数据类型” 中会介绍类型和类型注解
#+END_EXAMPLE
+ 常量可以在 *任何作用域中声明* ，包括 _全局作用域_ ，这在一个值需要被很多部分的代码用到时很有用
+ 常量只能 *被设置为常量表达式* ，而不能是 _函数调用的结果_ ，或任何其他 _只能在运行时计算出的值_ 


下面是一个声明常量的例子，它的名称是 MAX_POINTS，值是 100,000：
#+BEGIN_SRC rust 
  const MAX_POINTS: u32 = 100_000;
#+END_SRC

在声明它的作用域之中，常量在 *整个程序生命周期中都有效* ，这使得常量可以作为 _多处代码使用的全局范围的值_ ，例如一个游戏中所有玩家可以获取的最高分或者光速

#+BEGIN_EXAMPLE
  将遍布于应用程序中的硬编码值声明为常量，能帮助后来的代码维护人员了解值的意图

  如果将来需要修改硬编码值，也只需修改汇聚于一处的硬编码值
#+END_EXAMPLE

** 隐藏
可以定义一个与之前变量同名的新变量，而新变量会 *隐藏* 之前的变量。Rustacean 们称之为第一个变量被第二个 隐藏 了，这意味着使用这个变量时会看到第二个值。可以用相同变量名称来隐藏一个变量，以及重复使用 _let_ 关键字来多次隐藏，如下所示：

#+BEGIN_SRC rust 
  fn main() {
      let x = 5;

      let x = x + 1;

      let x = x * 2;

      println!("The value of x is: {}", x);
  }
#+END_SRC

这个程序首先将 x 绑定到值 5 上。接着通过 let x = 隐藏 x，获取初始值并加 1，这样 x 的值就变成 6 了。第三个 let 语句也隐藏了 x，将之前的值乘以 2，x 最终的值是 12。运行这个程序，它会有如下输出：

#+BEGIN_SRC sh 
  $ cargo run
     Compiling shadowing v0.1.0 (/home/i514692/Documents/programming/html/klose911.github.io/src/rust/src/shadowing)
      Finished dev [unoptimized + debuginfo] target(s) in 0.61s
       Running `target/debug/shadowing`
  The value of x is: 12
#+END_SRC

_隐藏_ 与将变量 _标记为 mut_ 是有区别的：
+ 当不小心尝试对变量重新赋值时：
  + 如果 _没有使用 let_ 关键字，就会导致 *编译时错误* 
  + 通过 _使用 let_ ，可以用这个值进行一些计算，不过 *计算完之后变量仍然是不变的* 
+ 当再次使用 let 时，实际上 *创建了一个新变量* ，可以 *改变值的类型* ，但复用这个名字
  + 例如，假设程序请求用户输入空格字符来说明希望在文本之间显示多少个空格，然而真正需要的是将输入存储成数字（多少个空格）：

#+BEGIN_SRC rust 
  let spaces = "   ";
  let spaces = spaces.len();
#+END_SRC

这里允许第一个 spaces 变量是字符串类型，而第二个 spaces 变量，它是一个恰巧与第一个变量同名的崭新变量，是数字类型。 *隐藏使我们不必使用不同的名字，如 spaces_str 和 spaces_num* ；相反，可以复用 spaces 这个更简单的名字。然而，如果尝试使用 mut：

#+BEGIN_SRC rust 
  let mut spaces = "   ";
  spaces = spaces.len();
#+END_SRC

将会得到一个编译时错误，如下所示：
#+BEGIN_SRC sh 
  error[E0308]: mismatched types
   --> src/main.rs:3:14
    |
  3 |     spaces = spaces.len();
    |              ^^^^^^^^^^^^ expected &str, found usize
    |
    = note: expected type `&str`
	       found type `usize`
#+END_SRC

这说明 mut 不能改变变量的类型

#+BEGIN_EXAMPLE
  现在已经了解了变量如何工作，接下来看看变量可以拥有的更多数据类型
#+END_EXAMPLE

* 基本数据类型

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>高阶内容</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="pattern.html"> UP </a>
 |
 <a accesskey="H" href="rust.html"> HOME </a>
</div><div id="content">
<h1 class="title">高阶内容</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org73d5c15">不安全 Rust</a>
<ul>
<li><a href="#orgd68e828">不安全的超级力量</a></li>
<li><a href="#org6ae519e">解引用裸指针</a></li>
<li><a href="#org39816da">调用不安全函数或方法</a>
<ul>
<li><a href="#orga94d504">创建不安全代码的安全抽象</a></li>
<li><a href="#org2c1a5b4">使用 extern 函数调用外部代码</a>
<ul>
<li><a href="#orge6cf4c6">从其它语言调用 Rust 函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge7a5d9c">访问或修改可变静态变量</a></li>
<li><a href="#org4ef2018">实现不安全 trait</a></li>
<li><a href="#org2f45392">何时使用不安全代码</a></li>
</ul>
</li>
<li><a href="#org7c7cf9f">高级 trait</a>
<ul>
<li><a href="#org8765888">关联类型</a></li>
<li><a href="#orgc535f26">默认泛型类型参数和运算符重载</a></li>
<li><a href="#orgf984395">完全限定语法与消歧义：调用相同名称的方法</a></li>
<li><a href="#org06a79c3">父 trait</a></li>
<li><a href="#orgcdfe901">newtype 模式</a></li>
</ul>
</li>
<li><a href="#org4107958">高级类型</a>
<ul>
<li><a href="#orgcae0aa7">为了类型安全和抽象而使用 newtype 模式</a></li>
<li><a href="#orgd671723">类型别名</a></li>
<li><a href="#orgd93cf0f">从不返回的 never type</a></li>
<li><a href="#org2995db0">动态大小类型和 Sized trait</a></li>
</ul>
</li>
<li><a href="#org767e606">高级函数和闭包</a></li>
<li><a href="#orgafb23f7">宏</a></li>
</ul>
</div>
</div>
<pre class="example">
  现在已经学习了 Rust 编程语言中最常用的部分。接下来的功能在一些非常特定的场景下很有用处

  虽然很少会碰到它们，这会确保了解 Rust 提供的所有功能

</pre>
<p>
本章将涉及如下内容：
</p>
<ul class="org-ul">
<li>不安全 Rust：用于当需要舍弃 Rust 的某些保证并负责手动维持这些保证</li>
<li>高级 trait：与 trait 相关的关联类型，默认类型参数，完全限定语法，超父trait和 newtype 模式</li>
<li>高级类型：关于 newtype 模式的更多内容，类型别名，never 类型和动态大小类型</li>
<li>高级函数和闭包：函数指针和返回闭包</li>
<li>宏：定义在编译时定义更多代码的方式</li>
</ul>
<div id="outline-container-org73d5c15" class="outline-2">
<h2 id="org73d5c15">不安全 Rust</h2>
<div class="outline-text-2" id="text-org73d5c15">
<p>
目前为止讨论过的代码都有 Rust 在编译时会强制执行的内存安全保证。然而，Rust 还隐藏有第二种语言，它不会强制执行这类内存安全保证：这被称为 <span class="underline">不安全 Rust</span> 。它与常规 Rust 代码无异，但是会提供额外的超级力量
</p>
<ul class="org-ul">
<li>不安全 Rust 之所以存在，是因为静态分析本质上是保守的</li>
</ul>
<pre class="example">
    当编译器尝试确定一段代码是否支持某个保证时，拒绝一些有效的程序比接受无效程序要好一些

    这必然意味着有时代码可能是合法的，但是 Rust 不这么认为！

    在这种情况下，可以使用不安全代码告诉编译器，“相信我，我知道我在干什么。”

    这么做的缺点就是你只能靠自己了：如果不安全代码出错了，比如解引用空指针，可能会导致不安全的内存使用
</pre>
<ul class="org-ul">
<li>另一个 Rust 存在不安全一面的原因是：底层计算机硬件固有的不安全性</li>
</ul>
<pre class="example">
如果 Rust 不允许进行不安全操作，那么有些任务则根本完成不了

Rust 需要能够进行像直接与操作系统交互，甚至于编写自己的操作系统这样的底层系统编程！
</pre>

<p>
先看看不安全 Rust 能做什么，和怎么做
</p>
</div>
<div id="outline-container-orgd68e828" class="outline-3">
<h3 id="orgd68e828">不安全的超级力量</h3>
<div class="outline-text-3" id="text-orgd68e828">
<p>
可以通过 <span class="underline">unsafe</span> 关键字来切换到不安全 Rust，接着可以开启一个新的存放不安全代码的块。这里有几类可以在不安全 Rust 中进行而不能用于安全 Rust 的操作，它们称之为 “不安全的超级力量。” 这些超级力量是：
</p>
<ol class="org-ol">
<li>解引用裸指针</li>
<li>调用不安全的函数或方法</li>
<li>访问或修改可变静态变量</li>
<li>实现不安全 trait</li>
</ol>

<p>
有一点很重要，unsafe 并不会关闭 <span class="underline">借用检查器</span> 或禁用任何 <span class="underline">其他 Rust 安全检查</span> ：如果在不安全代码中使用引用，它仍会被检查
</p>

<pre class="example">
unsafe 关键字只是提供了那几个不会被编译器检查内存安全的功能

仍然能在不安全块中获得某种程度的安全
</pre>

<p>
再者，unsafe 不意味着块中的代码就一定是危险的或者必然导致内存安全问题：其意图在于作为程序员将会确保 unsafe 块中的代码以有效的方式访问内存
</p>
<pre class="example">
     人是会犯错误的，错误总会发生

     不过通过要求这类操作必须位于标记为 unsafe 的块中，就能够知道任何与内存安全相关的错误必定位于 unsafe 块内

     保持 unsafe 块尽可能小，如此当之后调查内存 bug 时就会感谢你自己了
</pre>
<p>
为了尽可能隔离不安全代码，将 <span class="underline">不安全代码</span> <b>封装</b> 进一个 <span class="underline">安全的抽象</span> 并 <b>提供</b> <span class="underline">安全 API</span> 是一个好主意
</p>

<pre class="example">
     标准库的一部分被实现为在被评审过的不安全代码之上的安全抽象

     这个技术防止了 unsafe 泄露到所有你或者用户希望使用由 unsafe 代码实现的功能的地方，因为使用其安全抽象是安全的
</pre>

<p>
接下来按顺序依次介绍上述几个超级力量，同时会看到一些提供不安全代码的安全接口的抽象
</p>
</div>
</div>
<div id="outline-container-org6ae519e" class="outline-3">
<h3 id="org6ae519e">解引用裸指针</h3>
<div class="outline-text-3" id="text-org6ae519e">
<pre class="example">
   回到前面的 “悬垂引用” 部分，那里提到了编译器会确保引用总是有效的
</pre>
<p>
不安全 Rust 有两个被称为 <span class="underline">裸指针</span> 的类似于引用的新类型。和引用一样，裸指针是 <span class="underline">可变</span> 或 <span class="underline">不可变</span> 的，分别写作 <span class="underline">*const T</span> 和 <span class="underline">*mut T</span> 
</p>
<ul class="org-ul">
<li>这里的 <span class="underline">星号</span> 不是解引用运算符；它是 <b>类型名称</b> 的一部分</li>
<li>在裸指针的上下文中，不可变意味着 <span class="underline">指针解引用</span> 之后 <b>不能直接</b> <span class="underline">赋值</span></li>
</ul>

<p>
与引用和智能指针的区别在于，记住裸指针：
</p>
<ul class="org-ul">
<li>允许忽略借用规则，可以同时拥有不可变和可变的指针，或多个指向相同位置的可变指针</li>
<li>不保证指向有效的内存</li>
<li>允许为空</li>
<li>不能实现任何自动清理功能</li>
</ul>

<pre class="example">
   通过去掉 Rust 强加的保证，可以放弃安全保证以换取性能或使用另一个语言或硬件接口的能力，此时 Rust 的保证并不适用
</pre>
<p>
下面展示了如何从引用同时创建不可变和可变裸指针：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">let</span> <span style="color: #00ffff;">mut</span> <span style="color: #eedd82;">num</span> = 5;

<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">r1</span> = &amp;num <span style="color: #00ffff;">as</span> *<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">i32</span>;
<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">r2</span> = &amp;<span style="color: #00ffff;">mut</span> num <span style="color: #00ffff;">as</span> *<span style="color: #00ffff;">mut</span> <span style="color: #98fb98;">i32</span>;
</pre>
</div>

<p>
注意：这里没有引入 unsafe 关键字。可以在 <span class="underline">安全代码</span> 中 <b>创建</b> 裸指针，只是 <b>不能</b> 在 <span class="underline">不安全块之外</span> <b>解引用</b> 裸指针
</p>

<pre class="example">
     这里使用 as 将不可变和可变引用强转为对应的裸指针类型

     因为直接从保证安全的引用来创建他们，可以知道这些特定的裸指针是有效，但是不能对任何裸指针做出如此假设

</pre>
<p>
接下来创建一个不能确定其有效性的裸指针，下面展示了如何创建一个指向任意内存地址的裸指针
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">let</span> <span style="color: #eedd82;">address</span> = 0x012345usize;
<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">r</span> = address <span style="color: #00ffff;">as</span> *<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">i32</span>;
</pre>
</div>

<pre class="example">
     尝试使用任意内存是未定义行为：此地址可能有数据也可能没有，编译器可能会优化掉这个内存访问，或者程序可能会出现段错误

     通常没有好的理由编写这样的代码，不过却是可行的
</pre>

<p>
对裸指针使用解引用运算符 *，这需要一个 unsafe 块：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">let</span> <span style="color: #00ffff;">mut</span> <span style="color: #eedd82;">num</span> = 5;

<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">r1</span> = &amp;num <span style="color: #00ffff;">as</span> *<span style="color: #00ffff;">const</span> <span style="color: #98fb98;">i32</span>;
<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">r2</span> = &amp;<span style="color: #00ffff;">mut</span> num <span style="color: #00ffff;">as</span> *<span style="color: #00ffff;">mut</span> <span style="color: #98fb98;">i32</span>;

<span style="color: #ffc0cb; font-weight: bold;">unsafe</span> {
    <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"r1 is: </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, *r1);
    <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"r2 is: </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, *r2);
}
</pre>
</div>

<pre class="example">
     创建一个指针不会造成任何危险；只有当访问其指向的值时才有可能遇到无效的值
</pre>
<p>
示例创建了同时指向相同内存位置 num 的裸指针 *const i32 和 *mut i32
</p>
<ul class="org-ul">
<li>如果尝试创建 num 的不可变和可变引用，这将无法编译因为 Rust 的所有权规则不允许拥有可变引用的同时拥有不可变引用</li>
<li>通过裸指针，就能够同时创建同一地址的可变指针和不可变指针</li>
<li>若通过 <span class="underline">可变指针</span> <b>修改</b> 数据，则可能造成 <span class="underline">数据竞争</span></li>
</ul>

<pre class="example">
     既然存在这么多的危险，为何还要使用裸指针呢？

     一个主要的应用场景便是调用 C 代码接口

     另一个场景是构建借用检查器无法理解的安全抽象
</pre>
</div>
</div>
<div id="outline-container-org39816da" class="outline-3">
<h3 id="org39816da">调用不安全函数或方法</h3>
<div class="outline-text-3" id="text-org39816da">
<p>
不安全函数和方法与常规函数方法十分类似，除了其开头有一个额外的 <span class="underline">unsafe</span> 
</p>

<pre class="example">
     在此上下文中，关键字unsafe表示该函数具有调用时需要满足的要求，而 Rust 不会保证满足这些要求

     通过在 unsafe 块中调用不安全函数，表明已经阅读过此函数的文档并对其是否满足函数自身的契约负责
</pre>

<p>
如下是一个没有做任何操作的不安全函数 dangerous 的例子：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #ffc0cb; font-weight: bold;">unsafe</span> <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">dangerous</span>() {}

<span style="color: #ffc0cb; font-weight: bold;">unsafe</span> {
    dangerous();
}
</pre>
</div>

<p>
必须在一个单独的 unsafe 块中调用 dangerous 函数。如果尝试不使用 unsafe 块调用 dangerous，则会得到一个错误：
</p>
<div class="org-src-container">
<pre class="src src-sh">error[E0133]: call to unsafe <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">requires</span> unsafe <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">or</span> block
 --&gt;
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe <span style="color: #00ffff;">function</span>
</pre>
</div>

<pre class="example">
     通过将 dangerous 调用插入 unsafe 块中，就向 Rust 保证了已经阅读过函数的文档，理解如何正确使用，并验证过其满足函数的契约
</pre>
<p>
不安全函数体也是有效的 unsafe 块，所以在不安全函数中进行另一个不安全操作时无需新增额外的 unsafe 块
</p>
</div>
<div id="outline-container-orga94d504" class="outline-4">
<h4 id="orga94d504">创建不安全代码的安全抽象</h4>
<div class="outline-text-4" id="text-orga94d504">
<p>
仅仅因为函数包含不安全代码并不意味着整个函数都需要标记为不安全的。事实上，将不安全代码封装进安全函数是一个常见的抽象。作为一个例子，标准库中的函数，split_at_mut，它需要一些不安全代码，这个安全函数定义于可变 slice 之上：它获取一个 slice 并从给定的索引参数开始将其分为两个 slice。split_at_mut 的用法：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">let</span> <span style="color: #00ffff;">mut</span> <span style="color: #eedd82;">v</span> = <span style="color: #7fffd4;">vec!</span>[1, 2, 3, 4, 5, 6];

<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">r</span> = &amp;<span style="color: #00ffff;">mut</span> v[..];

<span style="color: #00ffff;">let</span> (a, b) = r.split_at_mut(3);

<span style="color: #7fffd4;">assert_eq!</span>(a, &amp;<span style="color: #00ffff;">mut</span> [1, 2, 3]);
<span style="color: #7fffd4;">assert_eq!</span>(b, &amp;<span style="color: #00ffff;">mut</span> [4, 5, 6]);
</pre>
</div>

<p>
这个函数无法只通过安全 Rust 实现。一个尝试可能看起来像示例，然而它不能编译。出于简单考虑，将 split_at_mut 实现为函数而不是方法，并只处理 i32 值而非泛型 T 的 slice：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">split_at_mut</span>(<span style="color: #eedd82;">slice</span>: &amp;<span style="color: #00ffff;">mut</span> [<span style="color: #98fb98;">i32</span>], <span style="color: #eedd82;">mid</span>: <span style="color: #98fb98;">usize</span>) -&gt; (&amp;<span style="color: #00ffff;">mut</span> [<span style="color: #98fb98;">i32</span>], &amp;<span style="color: #00ffff;">mut</span> [<span style="color: #98fb98;">i32</span>]) {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">len</span> = slice.len();

    <span style="color: #7fffd4;">assert!</span>(mid &lt;= len);

    (&amp;<span style="color: #00ffff;">mut</span> slice[..mid],
     &amp;<span style="color: #00ffff;">mut</span> slice[mid..])
}
</pre>
</div>

<ol class="org-ol">
<li>此函数首先获取 slice 的长度</li>
<li>通过检查参数是否小于或等于这个长度来断言参数所给定的索引位于 slice 当中：该断言意味着如果传入的索引比要分割的 slice 的索引更大，此函数在尝试使用这个索引前 panic</li>
<li>在一个元组中返回两个可变的 slice：一个从原始 slice 的开头直到 mid 索引，另一个从 mid 直到原 slice 的结尾</li>
</ol>

<p>
如果尝试编译的，会得到一个错误：
</p>

<div class="org-src-container">
<pre class="src src-sh">error[E0499]: cannot borrow <span style="color: #fa8072;">`*slice`</span> as mutable more than once at a time
 --&gt;
  |
6 |     (&amp;mut slice[..mid],
  |           ----- first mutable borrow occurs here
7 |      &amp;mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
8 | }
  | - first borrow ends here
</pre>
</div>

<p>
Rust 的借用检查器不能理解要借用这个 slice 的两个不同部分：它只知道我们借用了同一个 slice 两次
</p>

<pre class="example">
      本质上借用 slice 的不同部分是可以的，因为结果两个 slice 不会重叠，不过 Rust 还没有智能到能够理解这些

      当我们知道某些事是可以的而 Rust 不知道的时候，就是触及不安全代码的时候了
</pre>
<p>
下面展示了如何使用 unsafe 块，裸指针和一些不安全函数调用来实现 split_at_mut：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::slice;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">split_at_mut</span>(<span style="color: #eedd82;">slice</span>: &amp;<span style="color: #00ffff;">mut</span> [<span style="color: #98fb98;">i32</span>], <span style="color: #eedd82;">mid</span>: <span style="color: #98fb98;">usize</span>) -&gt; (&amp;<span style="color: #00ffff;">mut</span> [<span style="color: #98fb98;">i32</span>], &amp;<span style="color: #00ffff;">mut</span> [<span style="color: #98fb98;">i32</span>]) {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">len</span> = slice.len();
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">ptr</span> = slice.as_mut_ptr();

    <span style="color: #7fffd4;">assert!</span>(mid &lt;= len);

    <span style="color: #ffc0cb; font-weight: bold;">unsafe</span> {
        (<span style="color: #7fffd4;">slice</span>::from_raw_parts_mut(ptr, mid),
         <span style="color: #7fffd4;">slice</span>::from_raw_parts_mut(ptr.offset(mid <span style="color: #00ffff;">as</span> <span style="color: #98fb98;">isize</span>), len - mid))
    }
}
</pre>
</div>

<p>
slice 是一个指向一些数据的指针，并带有该 slice 的长度。可以使用 len 方法获取 slice 的长度，使用 <span class="underline">as_mut_ptr</span> 方法访问 <b>slice 的裸指针</b> 
</p>

<pre class="example">
    在这个例子中，因为有一个 i32 值的可变 slice，as_mut_ptr 返回一个 *mut i32 类型的裸指针，储存在 ptr 变量中
</pre>
<p>
保持索引 mid 位于 slice 中的断言。接着是不安全代码： <span class="underline">slice::from_raw_parts_mut</span>  函数获取一个裸指针和一个长度来 <b>创建</b> 一个 slice：
</p>
<ul class="org-ul">
<li>使用此函数从 ptr 中创建了一个有 mid 个项的 slice</li>
<li>在 ptr 上调用 offset 方法并使用 mid 作为参数来获取一个从 mid 开始的裸指针，使用这个裸指针并以 mid 之后项的数量为长度创建一个 slice</li>
</ul>

<pre class="example">
slice::from_raw_parts_mut 函数是不安全的因为它获取一个裸指针，并必须确信这个指针是有效的

裸指针上的 offset 方法也是不安全的，因为其必须确信此地址偏移量也是有效的指针

因此必须将 slice::from_raw_parts_mut 和 offset 放入 unsafe 块中以便能调用它们

通过观察代码，和增加 mid 必然小于等于 len 的断言，可以说 unsafe 块中所有的裸指针将是有效的 slice 中数据的指针。这是一个可以接受的 unsafe 的恰当用法
</pre>

<p>
注意：无需将 split_at_mut 函数的结果标记为 unsafe，并可以在安全 Rust 中调用此函数。因为创建了一个不安全代码的安全抽象，其代码以一种安全的方式使用了 unsafe 代码，其只从这个函数访问的数据中创建了有效的指针
</p>

<p>
与此相对，下面示例中的 slice::from_raw_parts_mut 在使用 slice 时很有可能会崩溃。这段代码获取任意内存地址并创建了一个长为一万的 slice：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::slice;

<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">address</span> = 0x01234usize;
<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">r</span> = address <span style="color: #00ffff;">as</span> *<span style="color: #00ffff;">mut</span> <span style="color: #98fb98;">i32</span>;

<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">slice</span>: &amp;[<span style="color: #98fb98;">i32</span>] = <span style="color: #ffc0cb; font-weight: bold;">unsafe</span> {
    <span style="color: #7fffd4;">slice</span>::from_raw_parts_mut(r, 10000)
};
</pre>
</div>

<p>
并不拥有这个任意地址的内存，也不能保证这段代码创建的 slice 包含有效的 i32 值。试图使用臆测为有效的 slice 会导致未定义的行为
</p>
</div>
</div>
<div id="outline-container-org2c1a5b4" class="outline-4">
<h4 id="org2c1a5b4">使用 extern 函数调用外部代码</h4>
<div class="outline-text-4" id="text-org2c1a5b4">
<p>
有时 Rust 代码可能需要与其他语言编写的代码交互。为此 Rust 有一个关键字 <span class="underline">extern</span> ，有助于创建和使用外部函数接口。外部函数接口是一个编程语言用以定义函数的方式，其允许不同（外部）编程语言调用这些函数。下面示例展示了如何集成 C 标准库中的 abs 函数：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">extern</span> <span style="color: #ffa07a;">"C"</span> {
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">abs</span>(<span style="color: #eedd82;">input</span>: <span style="color: #98fb98;">i32</span>) -&gt; <span style="color: #98fb98;">i32</span>;
}

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #ffc0cb; font-weight: bold;">unsafe</span> {
        <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"Absolute value of -3 according to C: </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, abs(-3));
    }
}
</pre>
</div>

<pre class="example">
extern 块中声明的函数在 Rust 代码中总是不安全的

因为其他语言不会强制执行 Rust 的规则且 Rust 无法检查它们，所以确保其安全是程序员的责任
</pre>

<p>
在 extern "C" 块中，列出了希望能够调用的另一个语言中的外部函数的签名和名称
</p>

<pre class="example">
"C" 部分定义了外部函数所使用的 应用程序接口(application binary interface，ABI) 

ABI 定义了如何在汇编语言层面调用此函数，"C" ABI 是最常见的，并遵循 C 编程语言的 ABI
</pre>
</div>

<div id="outline-container-orge6cf4c6" class="outline-5">
<h5 id="orge6cf4c6">从其它语言调用 Rust 函数</h5>
<div class="outline-text-5" id="text-orge6cf4c6">
<p>
也可以使用 extern 来创建一个允许其他语言调用 Rust 函数的接口。不同于 extern 块，就在 fn 关键字之前增加 extern 关键字并指定所用到的 ABI。还需增加 <span class="underline">#[no_mangle]</span> 注解来告诉 Rust 编译器不要 mangle 此函数的名称
</p>

<pre class="example">
Mangling 发生于当编译器将指定的函数名修改为不同的名称时，这会增加用于其他编译过程的额外信息，不过会使其名称更难以阅读

每一个编程语言的编译器都会以稍微不同的方式 mangle 函数名，所以为了使 Rust 函数能在其他语言中指定，必须禁用 Rust 编译器的 name mangling
</pre>

<p>
在如下的例子中，一旦其编译为动态库并从 C 语言中链接，call_from_c 函数就能够在 C 代码中访问：
</p>


<div class="org-src-container">
<pre class="src src-rust"><span style="color: #7fffd4;">#[no_mangle]</span>
<span style="color: #00ffff;">pub</span> <span style="color: #00ffff;">extern</span> <span style="color: #ffa07a;">"C"</span> <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">call_from_c</span>() {
    <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"Just called a Rust function from C!"</span>);
}
</pre>
</div>
<p>
注意：extern 的使用无需 unsafe
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orge7a5d9c" class="outline-3">
<h3 id="orge7a5d9c">访问或修改可变静态变量</h3>
<div class="outline-text-3" id="text-orge7a5d9c">
<pre class="example">
     目前为止都尽量避免讨论 全局变量，Rust 确实支持他们，不过这对于 Rust 的所有权规则来说是有问题的

     如果有两个线程访问相同的可变全局变量，则可能会造成数据竞争
</pre>
<p>
全局变量在 Rust 中被称为 <span class="underline">静态</span> (static)变量。下面展示了一个拥有字符串 slice 值的静态变量的声明和应用：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">static</span> <span style="color: #eedd82;">HELLO_WORLD</span>: &amp;<span style="color: #98fb98;">str</span> = <span style="color: #ffa07a;">"Hello, world!"</span>;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"name is: </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, <span style="color: #98fb98;">HELLO_WORLD</span>);
}
</pre>
</div>

<p>
static 变量类似于开头讨论的常量。通常静态变量的名称采用 SCREAMING_SNAKE_CASE 写法，并 <b>必须</b> 标注 <span class="underline">变量的类型</span> ，在这个例子中是 &amp;'static str：
</p>
<ul class="org-ul">
<li>静态变量只能储存拥有 <span class="underline">'static</span> <b>生命周期的引用</b> ，这意味着 Rust 编译器可以自己计算出其生命周期而无需显式标注</li>
<li>访问 <span class="underline">不可变</span> 静态变量是 <b>安全</b> 的</li>
</ul>

<p>
常量与不可变静态变量可能看起来很类似，不过一个微妙的区别是：
</p>
<ul class="org-ul">
<li><span class="underline">静态变量</span> 中的值有一个 <b>固定的内存地址</b> ，使用这个值总是会访问相同的地址</li>
<li><span class="underline">常量</span> 则允许在任何被用到的时候 <b>复制</b> 其 <span class="underline">数据</span></li>
</ul>

<p>
常量与静态变量的另一个区别在于 <span class="underline">静态变量</span> 可以是 <b>可变</b> 的。 <span class="underline">访问</span> 和 <span class="underline">修改</span> <b>可变</b> <span class="underline">静态变量</span> 都是 <b>不安全</b> 的。下面展示了如何声明、访问和修改名为 COUNTER 的可变静态变量：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">static</span> <span style="color: #00ffff;">mut</span> <span style="color: #eedd82;">COUNTER</span>: <span style="color: #98fb98;">u32</span> = 0;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">add_to_count</span>(<span style="color: #eedd82;">inc</span>: <span style="color: #98fb98;">u32</span>) {
    <span style="color: #ffc0cb; font-weight: bold;">unsafe</span> {
        <span style="color: #98fb98;">COUNTER</span> += inc;
    }
}

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    add_to_count(3);

    <span style="color: #ffc0cb; font-weight: bold;">unsafe</span> {
        <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"COUNTER: </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, <span style="color: #98fb98;">COUNTER</span>);
    }
}
</pre>
</div>

<p>
就像常规变量一样，使用 mut 关键来指定可变性。任何读写 COUNTER 的代码都必须位于 unsafe 块中。这段代码可以编译并如期打印出 COUNTER: 3，因为这是单线程的。拥有多个线程访问 COUNTER 则可能导致数据竞争
</p>

<pre class="example">
     拥有可以全局访问的可变数据，难以保证不存在数据竞争，这就是为何 Rust 认为可变静态变量是不安全的

     任何可能的情况，请优先使用并发技术和线程安全智能指针，这样编译器就能检测不同线程间的数据访问是否是安全的
</pre>
</div>
</div>

<div id="outline-container-org4ef2018" class="outline-3">
<h3 id="org4ef2018">实现不安全 trait</h3>
<div class="outline-text-3" id="text-org4ef2018">
<p>
最后一个只能用在 unsafe 中的操作是实现不安全 trait。当至少有一个方法中包含编译器不能验证的不变量时 trait 是不安全的。可以在 trait 之前增加 unsafe 关键字将 trait 声明为 unsafe，同时 trait 的实现也必须标记为 unsafe：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #ffc0cb; font-weight: bold;">unsafe</span> <span style="color: #00ffff;">trait</span> <span style="color: #98fb98;">Foo</span> {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">methods go here</span>
}

<span style="color: #ffc0cb; font-weight: bold;">unsafe</span> <span style="color: #00ffff;">impl</span> <span style="color: #98fb98;">Foo</span> <span style="color: #00ffff;">for</span> <span style="color: #98fb98;">i32</span> {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">method implementations go here</span>
}
</pre>
</div>

<p>
通过 unsafe impl，将保证编译器所不能验证的不变量
</p>

<pre class="example">
作为一个例子，回忆“使用 Sync 和 Send trait 的可扩展并发” 部分中的 Sync 和 Send 标记 trait，编译器会自动为完全由 Send 和 Sync 类型组成的类型自动实现他们

如果实现了一个包含一些不是 Send 或 Sync 的类型，比如裸指针，并希望将此类型标记为 Send 或 Sync，则必须使用 unsafe

Rust 不能验证我们的类型保证可以安全的跨线程发送或在多线程键访问，所以需要我们自己进行检查并通过 unsafe 表明
</pre>
</div>
</div>

<div id="outline-container-org2f45392" class="outline-3">
<h3 id="org2f45392">何时使用不安全代码</h3>
<div class="outline-text-3" id="text-org2f45392">
<p>
使用 unsafe 来进行这四个操作（超级力量）之一是没有问题的，甚至是不需要深思熟虑的
</p>

<pre class="example">
     不过使用 unsafe 代码正确也实属不易，因为编译器不能帮助保证内存安全

     当有理由使用 unsafe 代码时，是可以这么做的，通过使用显式的 unsafe 标注使得在出现错误时易于追踪问题的源头
</pre>
</div>
</div>
</div>

<div id="outline-container-org7c7cf9f" class="outline-2">
<h2 id="org7c7cf9f">高级 trait</h2>
<div class="outline-text-2" id="text-org7c7cf9f">
<pre class="example">
“trait：定义共享的行为” 部分，第一次涉及到了 trait，不过就像生命周期一样，并没有覆盖一些较为高级的细节

现在更加了解 Rust 了，可以深入理解其本质了
</pre>
</div>

<div id="outline-container-org8765888" class="outline-3">
<h3 id="org8765888">关联类型</h3>
<div class="outline-text-3" id="text-org8765888">
<p>
<span class="underline">关联类型</span> 是一个将 <span class="underline">类型占位符</span> 与 <span class="underline">trait</span> 相关联的方式，这样 trait 的方法签名中就可以使用这些占位符类型。trait 的实现者会针对特定的实现在这个类型的位置指定相应的具体类型。如此可以定义一个使用多种类型的 trait，直到实现此 trait 时都无需知道这些类型具体是什么
</p>

<pre class="example">
     本章所描述的大部分内容都非常少见

     关联类型则比较适中；它们比本书其他的内容要少见，不过比本章中的很多内容要更常见
</pre>
<p>
一个带有关联类型的 trait 的例子是标准库提供的 Iterator trait。它有一个叫做 <span class="underline">Item</span> 的关联类型来替代遍历的值的类型：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">pub</span> <span style="color: #00ffff;">trait</span> <span style="color: #98fb98;">Iterator</span> {
    <span style="color: #00ffff;">type</span> <span style="color: #98fb98;">Item</span>;

    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">next</span>(&amp;<span style="color: #00ffff;">mut</span> <span style="color: #00ffff;">self</span>) -&gt; <span style="color: #98fb98;">Option</span>&lt;<span style="color: #98fb98;">Self</span>::<span style="color: #98fb98;">Item</span>&gt;;
}
</pre>
</div>

<p>
Item 是一个占位类型，同时 next 方法定义表明它返回 Option&lt;Self::Item&gt; 类型的值。这个 trait 的实现者会指定 Item 的具体类型，然而不管实现者指定何种类型, next 方法都会返回一个包含了此具体类型值的 Option
</p>

<pre class="example">
     关联类型看起来像一个类似泛型的概念，因为它允许定义一个函数而不指定其可以处理的类型

     那么为什么要使用关联类型呢？
</pre>

<p>
通过一个前面出现过的 Counter 结构体上实现 Iterator trait 的例子来检视其中的区别。下面指定了 Item 的类型为 u32：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">impl</span> <span style="color: #98fb98;">Iterator</span> <span style="color: #00ffff;">for</span> <span style="color: #98fb98;">Counter</span> {
    <span style="color: #00ffff;">type</span> <span style="color: #98fb98;">Item</span> = <span style="color: #98fb98;">u32</span>;

    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">next</span>(&amp;<span style="color: #00ffff;">mut</span> <span style="color: #00ffff;">self</span>) -&gt; <span style="color: #98fb98;">Option</span>&lt;<span style="color: #98fb98;">Self</span>::<span style="color: #98fb98;">Item</span>&gt; {
        <span style="color: #ff4500;">// </span><span style="color: #ff4500;">--snip--</span>
</pre>
</div>

<p>
这类似于泛型。那么为什么 Iterator trait 不像下面那样定义呢？
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">pub</span> <span style="color: #00ffff;">trait</span> <span style="color: #98fb98;">Iterator</span>&lt;<span style="color: #98fb98;">T</span>&gt; {
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">next</span>(&amp;<span style="color: #00ffff;">mut</span> <span style="color: #00ffff;">self</span>) -&gt; <span style="color: #98fb98;">Option</span>&lt;<span style="color: #98fb98;">T</span>&gt;;
}
</pre>
</div>

<pre class="example">
     区别在于当如上面那样使用泛型时，则不得不在每一个实现中标注类型，这是因为我们也可以实现为 Iterator&lt;String&gt; for Counter，或任何其他类型，这样就可以有多个 Counter 的 Iterator 的实现

     换句话说，当 trait 有泛型参数时，可以多次实现这个 trait，每次需改变泛型参数的具体类型，接着当使用 Counter 的 next 方法时，必须提供类型注解来表明希望使用 Iterator 的哪一个实现

</pre>
<p>
通过关联类型，则无需标注类型因为不能多次实现这个 trait。对于使用关联类型的定义，只能选择一次 Item 会是什么类型，因为只能有一个 impl Iterator for Counter。当调用 Counter 的 next 时不必每次指定需要 u32 值的迭代器
</p>
</div>
</div>

<div id="outline-container-orgc535f26" class="outline-3">
<h3 id="orgc535f26">默认泛型类型参数和运算符重载</h3>
<div class="outline-text-3" id="text-orgc535f26">
<p>
当使用泛型类型参数时，可以为泛型指定一个默认的具体类型。如果默认类型就足够的话，这消除了为具体类型实现 trait 的需要。为泛型类型指定默认类型的语法是在声明泛型类型时使用 <span class="underline">&lt;PlaceholderType=ConcreteType&gt;</span> 
</p>

<pre class="example">
这种情况的一个非常好的例子是用于运算符重载，运算符重载：是指在特定情况下自定义运算符（比如 +）行为的操作

Rust 并不允许创建自定义运算符或重载任意运算符，不过 std::ops 中所列出的运算符和相应的 trait 可以通过实现运算符相关 trait 来重载
</pre>
<p>
例如，下面展示了如何在 <span class="underline">Point 结构体</span> 上实现 <span class="underline">Add trait</span> 来 <b>重载</b> <span class="underline">+ 运算符</span> ，这样就可以将两个 Point 实例相加了：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">ops</span>::<span style="color: #98fb98;">Add</span>;

<span style="color: #7fffd4;">#[derive(Debug, PartialEq)]</span>
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Point</span> {
    <span style="color: #eedd82;">x</span>: <span style="color: #98fb98;">i32</span>,
    <span style="color: #eedd82;">y</span>: <span style="color: #98fb98;">i32</span>,
}

<span style="color: #00ffff;">impl</span> <span style="color: #98fb98;">Add</span> <span style="color: #00ffff;">for</span> <span style="color: #98fb98;">Point</span> {
    <span style="color: #00ffff;">type</span> <span style="color: #98fb98;">Output</span> = <span style="color: #98fb98;">Point</span>;

    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">add</span>(<span style="color: #00ffff;">self</span>, <span style="color: #eedd82;">other</span>: <span style="color: #98fb98;">Point</span>) -&gt; <span style="color: #98fb98;">Point</span> {
        <span style="color: #98fb98;">Point</span> {
            <span style="color: #eedd82;">x</span>: <span style="color: #00ffff;">self</span>.x + other.x,
            <span style="color: #eedd82;">y</span>: <span style="color: #00ffff;">self</span>.y + other.y,
        }
    }
}

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #7fffd4;">assert_eq!</span>(<span style="color: #98fb98;">Point</span> { <span style="color: #eedd82;">x</span>: 1, <span style="color: #eedd82;">y</span>: 0 } + <span style="color: #98fb98;">Point</span> { <span style="color: #eedd82;">x</span>: 2, <span style="color: #eedd82;">y</span>: 3 },
               <span style="color: #98fb98;">Point</span> { <span style="color: #eedd82;">x</span>: 3, <span style="color: #eedd82;">y</span>: 3 });
}
</pre>
</div>

<p>
add 方法将两个 Point 实例的 x 值和 y 值分别相加来创建一个新的 Point。 <span class="underline">Add trait</span> 有一个叫做 <span class="underline">Output</span> 的 <b>关联类型</b> ，它用来决定 add 方法的返回值类型，这里默认泛型类型位于 Add trait 中。这里是其定义：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">trait</span> <span style="color: #98fb98;">Add</span>&lt;RHS=Self&gt; {
    <span style="color: #00ffff;">type</span> <span style="color: #98fb98;">Output</span>;

    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">add</span>(<span style="color: #00ffff;">self</span>, <span style="color: #eedd82;">rhs</span>: <span style="color: #98fb98;">RHS</span>) -&gt; <span style="color: #98fb98;">Self</span>::<span style="color: #98fb98;">Output</span>;
}
</pre>
</div>

<p>
这看来应该很熟悉，这是一个带有一个方法和一个关联类型的 trait。比较陌生的部分是尖括号中的 <span class="underline">RHS=Self</span> ：这个语法叫做 <span class="underline">默认类型参数</span> 。RHS 是一个泛型类型参数，它用于定义 add 方法中的 rhs 参数
</p>

<pre class="example">
     如果实现 Add trait 时不指定 RHS 的具体类型，RHS 的类型将是默认的 Self 类型，也就是在其上实现 Add 的类型

     当为 Point 实现 Add 时，使用了默认的 RHS，因为希望将两个 Point 实例相加
</pre>
<p>
看看一个实现 Add trait 时希望自定义 RHS 类型而不是使用默认类型的例子。这里有两个存放不同单元值的结构体，Millimeters 和 Meters。希望能够将毫米值与米值相加，并让 Add 的实现正确处理转换。可以为 Millimeters 实现 Add 并以 Meters 作为 RHS：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">ops</span>::<span style="color: #98fb98;">Add</span>;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Millimeters</span>(<span style="color: #98fb98;">u32</span>);
<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Meters</span>(<span style="color: #98fb98;">u32</span>);

<span style="color: #00ffff;">impl</span> <span style="color: #98fb98;">Add</span>&lt;<span style="color: #98fb98;">Meters</span>&gt; <span style="color: #00ffff;">for</span> <span style="color: #98fb98;">Millimeters</span> {
    <span style="color: #00ffff;">type</span> <span style="color: #98fb98;">Output</span> = <span style="color: #98fb98;">Millimeters</span>;

    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">add</span>(<span style="color: #00ffff;">self</span>, <span style="color: #eedd82;">other</span>: <span style="color: #98fb98;">Meters</span>) -&gt; <span style="color: #98fb98;">Millimeters</span> {
        <span style="color: #98fb98;">Millimeters</span>(<span style="color: #00ffff;">self</span>.0 + (other.0 * 1000))
    }
}
</pre>
</div>

<pre class="example">
     为了使 Millimeters 和 Meters 能够相加，指定 impl Add&lt;Meters&gt; 来设定 RHS 类型参数的值而不是使用默认的 Self
</pre>
<p>
默认参数类型主要用于如下两个方面：
</p>
<ol class="org-ol">
<li>扩展类型而不破坏现有代码</li>
<li>在大部分用户都不需要的特定情况进行自定义</li>
</ol>

<pre class="example">
     标准库的 Add trait 就是第二个目的：大部分时候你会将两个相似的类型相加，不过它提供了自定义额外行为的能力。在 Add trait 定义中使用默认类型参数意味着大部分时候无需指定额外的参数。换句话说，一小部分实现的样板代码是不必要的，这样使用 trait 就更容易了

     第一个目的是相似的，但过程是反过来的：如果需要为现有 trait 增加类型参数，为其提供一个默认类型将允许在不破坏现有实现代码的基础上扩展 trait 的功能
</pre>
</div>
</div>

<div id="outline-container-orgf984395" class="outline-3">
<h3 id="orgf984395">完全限定语法与消歧义：调用相同名称的方法</h3>
<div class="outline-text-3" id="text-orgf984395">
<pre class="example">
Rust 既不能避免一个 trait 与另一个 trait 拥有相同名称的方法，也不能阻止为同一类型同时实现这两个 trait

甚至直接在类型上实现开始已经有的同名方法也是可能的！
</pre>
<p>
不过，当调用这些同名方法时，需要告诉 Rust 希望使用哪一个。下面定义了 trait Pilot 和 Wizard 都拥有方法 fly。接着在一个本身已经实现了名为 fly 方法的类型 Human 上实现这两个 trait。每一个 fly 方法都进行了不同的操作：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">trait</span> <span style="color: #98fb98;">Pilot</span> {
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">fly</span>(&amp;<span style="color: #00ffff;">self</span>);
}

<span style="color: #00ffff;">trait</span> <span style="color: #98fb98;">Wizard</span> {
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">fly</span>(&amp;<span style="color: #00ffff;">self</span>);
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Human</span>;

<span style="color: #00ffff;">impl</span> <span style="color: #98fb98;">Pilot</span> <span style="color: #00ffff;">for</span> <span style="color: #98fb98;">Human</span> {
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">fly</span>(&amp;<span style="color: #00ffff;">self</span>) {
        <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"This is your captain speaking."</span>);
    }
}

<span style="color: #00ffff;">impl</span> <span style="color: #98fb98;">Wizard</span> <span style="color: #00ffff;">for</span> <span style="color: #98fb98;">Human</span> {
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">fly</span>(&amp;<span style="color: #00ffff;">self</span>) {
        <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"Up!"</span>);
    }
}

<span style="color: #00ffff;">impl</span> <span style="color: #98fb98;">Human</span> {
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">fly</span>(&amp;<span style="color: #00ffff;">self</span>) {
        <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"*waving arms furiously*"</span>);
    }
}
</pre>
</div>

<p>
当调用 Human 实例的 fly 时，编译器默认调用直接是现在类型上的方法：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">person</span> = <span style="color: #98fb98;">Human</span>;
    person.fly();
}
</pre>
</div>

<pre class="example">
   运行这段代码会打印出 *waving arms furiously*，这表明 Rust 调用了直接实现在 Human 上的 fly 方法
</pre>
<p>
为了能够调用 Pilot trait 或 Wizard trait 的 fly 方法，需要使用更明显的语法以便能指定指的是哪个 fly 方法：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">person</span> = <span style="color: #98fb98;">Human</span>;
    <span style="color: #98fb98;">Pilot</span>::fly(&amp;person);
    <span style="color: #98fb98;">Wizard</span>::fly(&amp;person);
    person.fly();
}
</pre>
</div>

<p>
在方法名前指定 trait 名向 Rust 澄清了希望调用哪个 fly 实现。也可以选择写成 Human::fly(&amp;person)，这等同于示例 19-18 中的 person.fly()，不过如果无需消歧义的话这么写就有点长了。运行这段代码会打印出：
</p>

<div class="org-src-container">
<pre class="src src-sh">This is your captain speaking.
Up!
*waving arms furiously*
</pre>
</div>

<pre class="example">
   因为 fly 方法获取一个 self 参数，如果有两个 类型 都实现了同一 trait，Rust 可以根据 self 的类型计算出应该使用哪一个 trait 实现
</pre>

<p>
然而，关联函数是 trait 的一部分，但没有 self 参数。当同一作用域的两个类型实现了同一 trait，Rust 就不能计算出期望的是哪一个类型，除非使用 <span class="underline">完全限定语法</span> 。例如，下面的 Animal trait 来说，它有关联函数 baby_name，结构体 Dog 实现了 Animal，同时有关联函数 baby_name 直接定义于 Dog 之上：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">trait</span> <span style="color: #98fb98;">Animal</span> {
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">baby_name</span>() -&gt; <span style="color: #98fb98;">String</span>;
}

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Dog</span>;

<span style="color: #00ffff;">impl</span> <span style="color: #98fb98;">Dog</span> {
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">baby_name</span>() -&gt; <span style="color: #98fb98;">String</span> {
        <span style="color: #98fb98;">String</span>::from(<span style="color: #ffa07a;">"Spot"</span>)
    }
}

<span style="color: #00ffff;">impl</span> <span style="color: #98fb98;">Animal</span> <span style="color: #00ffff;">for</span> <span style="color: #98fb98;">Dog</span> {
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">baby_name</span>() -&gt; <span style="color: #98fb98;">String</span> {
        <span style="color: #98fb98;">String</span>::from(<span style="color: #ffa07a;">"puppy"</span>)
    }
}

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"A baby dog is called a </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, <span style="color: #98fb98;">Dog</span>::baby_name());
}
</pre>
</div>

<pre class="example">
这段代码用于一个动物收容所，他们将所有的小狗起名为 Spot，这实现为定义于 Dog 之上的关联函数 baby_name

Dog 类型还实现了 Animal trait，它描述了所有动物的共有的特征。小狗被称为 puppy，这表现为 Dog 的 Animal trait 实现中与 Animal trait 相关联的函数 baby_name
</pre>

<p>
在 main 调用了 Dog::baby_name 函数，它直接调用了定义于 Dog 之上的关联函数。这段代码会打印出：
</p>

<div class="org-src-container">
<pre class="src src-sh">A baby dog is called a Spot
</pre>
</div>

<p>
这并不是我们需要的。希望调用的是 Dog 上 Animal trait 实现那部分的 baby_name 函数，这样能够打印出 A baby dog is called a puppy。前面用到的技术在这并不管用：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"A baby dog is called a </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, <span style="color: #98fb98;">Animal</span>::baby_name());
}
</pre>
</div>

<p>
会得到一个编译错误：
</p>
<div class="org-src-container">
<pre class="src src-sh">error[E0283]: type annotations required: cannot resolve <span style="color: #fa8072;">`_: Animal`</span>
  --&gt; src/main.rs:20:43
   |
20 |     println!(<span style="color: #ffa07a;">"A baby dog is called a {}"</span>, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^
   |
   = note: required by <span style="color: #fa8072;">`Animal::baby_name`</span>
</pre>
</div>

<pre class="example">
     因为 Animal::baby_name 是关联函数而不是方法，因此它没有 self 参数，Rust 无法计算出所需的是哪一个 Animal::baby_name 实现
</pre>

<p>
为了消歧义并告诉 Rust 希望使用的是 Dog 的 Animal 实现，需要使用 <span class="underline">完全限定语法</span> ，这是调用函数时最为明确的方式：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"A baby dog is called a </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, &lt;<span style="color: #98fb98;">Dog</span> <span style="color: #00ffff;">as</span> <span style="color: #98fb98;">Animal</span>&gt;::baby_name());
}
</pre>
</div>

<p>
在尖括号中向 Rust 提供了类型注解，并通过在此函数调用中将 Dog 类型当作 Animal 对待，来指定希望调用的是 Dog 上 Animal trait 实现中的 baby_name 函数。现在这段代码会打印出期望的数据：
</p>

<div class="org-src-container">
<pre class="src src-sh">A baby dog is called a puppy
</pre>
</div>

<p>
通常，完全限定语法定义为：
</p>
<pre class="example">
&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</pre>

<p>
对于关联函数，其没有一个 receiver，故只会有其他参数的列表
</p>

<pre class="example">
     可以选择在任何函数或方法调用处使用完全限定语法。然而，允许省略任何 Rust 能够从程序中的其他信息中计算出的部分

     只有当存在多个同名实现而 Rust 需要帮助以便知道我们希望调用哪个实现时，才需要使用这个较为冗长的语法
</pre>
</div>
</div>

<div id="outline-container-org06a79c3" class="outline-3">
<h3 id="org06a79c3">父 trait</h3>
<div class="outline-text-3" id="text-org06a79c3">
<pre class="example">
     有时可能会需要某个 trait 使用另一个 trait 的功能。在这种情况下，需要能够依赖相关的 trait 也被实现

     这个所需的 trait 是实现的 trait 的 父 trait(supertrait)
</pre>
<p>
例如希望创建一个带有 outline_print 方法的 trait OutlinePrint，它会打印出带有星号框的值。也就是说，如果 Point 实现了 Display 并返回 (x, y)，调用以 1 作为 x 和 3 作为 y 的 Point 实例的 outline_print 会显示如下：
</p>

<pre class="example">
**********
*        *
* (1, 3) *
*        *
**********
</pre>

<p>
在 outline_print 的实现中，因为希望能够使用 Display trait 的功能，则需要说明 OutlinePrint 只能用于同时也实现了 Display 并提供了 OutlinePrint 需要的功能的类型。可以通过在 trait 定义中指定 OutlinePrint: Display 来做到这一点。这类似于为 trait 增加 trait bound。下面示例展示了一个 OutlinePrint trait 的实现：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::fmt;

<span style="color: #00ffff;">trait</span> <span style="color: #eedd82;">OutlinePrint</span>: <span style="color: #7fffd4;">fmt</span>::<span style="color: #98fb98;">Display</span> {
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">outline_print</span>(&amp;<span style="color: #00ffff;">self</span>) {
        <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">output</span> = <span style="color: #00ffff;">self</span>.to_string();
        <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">len</span> = output.len();
        <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"</span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, <span style="color: #ffa07a;">"*"</span>.repeat(len + 4));
        <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"*</span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">*"</span>, <span style="color: #ffa07a;">" "</span>.repeat(len + 2));
        <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"* </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;"> *"</span>, output);
        <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"*</span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">*"</span>, <span style="color: #ffa07a;">" "</span>.repeat(len + 2));
        <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"</span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, <span style="color: #ffa07a;">"*"</span>.repeat(len + 4));
    }
}
</pre>
</div>

<pre class="example">
     因为指定了 OutlinePrint 需要 Display trait，则可以在 outline_print 中使用 to_string， 其会为任何实现 Display 的类型自动实现

     如果不在 trait 名后增加 : Display 并尝试在 outline_print 中使用 to_string，则会得到一个错误说在当前作用域中没有找到用于 &amp;Self 类型的方法 to_string
</pre>
<p>
如果尝试在一个没有实现 Display 的类型上实现 OutlinePrint ：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Point</span> {
    <span style="color: #eedd82;">x</span>: <span style="color: #98fb98;">i32</span>,
    <span style="color: #eedd82;">y</span>: <span style="color: #98fb98;">i32</span>,
}

<span style="color: #00ffff;">impl</span> <span style="color: #98fb98;">OutlinePrint</span> <span style="color: #00ffff;">for</span> <span style="color: #98fb98;">Point</span> {}
</pre>
</div>

<p>
一旦在 Point 上实现 Display 并满足 OutlinePrint 要求的限制，比如这样：
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::fmt;

<span style="color: #00ffff;">impl</span> <span style="color: #7fffd4;">fmt</span>::<span style="color: #98fb98;">Display</span> <span style="color: #00ffff;">for</span> <span style="color: #98fb98;">Point</span> {
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">fmt</span>(&amp;<span style="color: #00ffff;">self</span>, <span style="color: #eedd82;">f</span>: &amp;<span style="color: #00ffff;">mut</span> <span style="color: #7fffd4;">fmt</span>::<span style="color: #98fb98;">Formatter</span>) -&gt; <span style="color: #7fffd4;">fmt</span>::<span style="color: #98fb98;">Result</span> {
        <span style="color: #b0c4de;">write!</span>(f, <span style="color: #ffa07a;">"(</span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">, </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">)"</span>, <span style="color: #00ffff;">self</span>.x, <span style="color: #00ffff;">self</span>.y)
    }
}
</pre>
</div>

<p>
那么在 Point 上实现 OutlinePrint trait 将能成功编译，并可以在 Point 实例上调用 outline_print 来显示位于星号框中的点的值：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">point</span> = <span style="color: #98fb98;">Point</span> { <span style="color: #eedd82;">x</span>: 1, <span style="color: #eedd82;">y</span>: 3 };
    point.outline_print();
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcdfe901" class="outline-3">
<h3 id="orgcdfe901">newtype 模式</h3>
<div class="outline-text-3" id="text-orgcdfe901">
<pre class="example">
前面“为类型实现 trait” 部分，提到了孤儿规则，它说明只要 trait 或类型对于当前 crate 是本地的话就可以在此类型上实现该 trait

一个绕开这个限制的方法是使用 newtype 模式，它涉及到在一个元组结构体，中创建一个新类型。这个元组结构体带有一个字段作为希望实现 trait 的类型的简单封装。接着这个封装类型对于 crate 是本地的，这样就可以在这个封装上实现 trait

Newtype 是一个源自Haskell 编程语言的概念，使用这个模式没有运行时性能惩罚，这个封装类型在编译时就被省略了

</pre>
<p>
例如，如果想要在 Vec&lt;T&gt; 上实现 Display，而孤儿规则阻止直接这么做，因为 Display trait 和 Vec&lt;T&gt; 都定义于我们的 crate 之外。可以创建一个包含 Vec&lt;T&gt; 实例的 Wrapper 结构体，接着可以在 Wrapper 上实现 Display 并使用 Vec&lt;T&gt; 的值：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::fmt;

<span style="color: #00ffff;">struct</span> <span style="color: #98fb98;">Wrapper</span>(<span style="color: #98fb98;">Vec</span>&lt;<span style="color: #98fb98;">String</span>&gt;);

<span style="color: #00ffff;">impl</span> <span style="color: #7fffd4;">fmt</span>::<span style="color: #98fb98;">Display</span> <span style="color: #00ffff;">for</span> <span style="color: #98fb98;">Wrapper</span> {
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">fmt</span>(&amp;<span style="color: #00ffff;">self</span>, <span style="color: #eedd82;">f</span>: &amp;<span style="color: #00ffff;">mut</span> <span style="color: #7fffd4;">fmt</span>::<span style="color: #98fb98;">Formatter</span>) -&gt; <span style="color: #7fffd4;">fmt</span>::<span style="color: #98fb98;">Result</span> {
        <span style="color: #b0c4de;">write!</span>(f, <span style="color: #ffa07a;">"[</span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">]"</span>, <span style="color: #00ffff;">self</span>.0.join(<span style="color: #ffa07a;">", "</span>))
    }
}

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">w</span> = <span style="color: #98fb98;">Wrapper</span>(<span style="color: #7fffd4;">vec!</span>[<span style="color: #98fb98;">String</span>::from(<span style="color: #ffa07a;">"hello"</span>), <span style="color: #98fb98;">String</span>::from(<span style="color: #ffa07a;">"world"</span>)]);
    <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"w = </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, w);
}
</pre>
</div>

<p>
Display 的实现使用 self.0 来访问其内部的 Vec&lt;T&gt;，因为 Wrapper 是元组结构体而 Vec&lt;T&gt; 是结构体总位于索引 0 的项，接着就可以使用 Wrapper 中 Display 的功能了
</p>

<pre class="example">
     因为 Wrapper 是一个新类型，它没有定义于其值之上的方法；必须直接在 Wrapper 上实现 Vec&lt;T&gt; 的所有方法，这样就可以代理到self.0 上。这允许完全像 Vec&lt;T&gt; 那样对待 Wrapper

     如果希望新类型拥有其内部类型的每一个方法，为封装类型实现 Deref trait，并返回其内部类型是一种解决方案

     如果不希望封装类型拥有所有内部类型的方法，比如为了“限制封装类型的行为”，则必须只自行实现所需的方法
</pre>
</div>
</div>
</div>


<div id="outline-container-org4107958" class="outline-2">
<h2 id="org4107958">高级类型</h2>
<div class="outline-text-2" id="text-org4107958">
<p>
Rust 的类型系统有一些曾经提到但没有讨论过的功能:
</p>
<ol class="org-ol">
<li>从一个关于为什么 newtype 与类型一样有用的更宽泛的讨论开始</li>
<li>接着会转向类型别名，一个类似于 newtype 但有着稍微不同的语义的功能</li>
<li>还会讨论 ! 类型和动态大小类型</li>
</ol>
</div>

<div id="outline-container-orgcae0aa7" class="outline-3">
<h3 id="orgcae0aa7">为了类型安全和抽象而使用 newtype 模式</h3>
<div class="outline-text-3" id="text-orgcae0aa7">
<p>
newtype 模式可以用于一些其他还未讨论的功能，包括静态的 <b>确保</b> <span class="underline">某值不被混淆</span> ，和用来 <b>表示</b> <span class="underline">一个值的单元</span>
</p>
<pre class="example">
     实际上前面中已经有一个这样的例子：Millimeters 和 Meters 结构体都在 newtype 中封装了 u32 值

     如果编写了一个有 Millimeters 类型参数的函数，不小心使用 Meters 或普通的 u32 值来调用该函数的程序是不能编译的
</pre>

<p>
另一个 newtype 模式的应用在于 <b>抽象</b> 掉一些 <span class="underline">类型的实现细节</span> 
</p>
<pre class="example">
   例如，封装类型可以暴露出与直接使用其内部私有类型时所不同的公有 API，以便限制其功能
</pre>

<p>
newtype 也可以 <b>隐藏</b> 其 <span class="underline">内部的泛型类型</span> 
</p>

<pre class="example">
例如，可以提供一个封装了 HashMap&lt;i32, String&gt; 的 People 类型，用来储存人名以及相应的 ID

使用 People 的代码只需与提供的公有 API 交互即可，比如向 People 集合增加名字字符串的方法，这样这些代码就无需知道在内部我们将一个 i32 ID 赋予了这个名字了

newtype 模式是一种实现 “封装隐藏了实现细节” 部分所讨论的隐藏实现细节的封装的轻量级方法
</pre>
</div>
</div>

<div id="outline-container-orgd671723" class="outline-3">
<h3 id="orgd671723">类型别名</h3>
<div class="outline-text-3" id="text-orgd671723">
<p>
连同 newtype 模式，Rust 还提供了声明 <b>类型别名</b> 的能力，使用 <span class="underline">type</span> 关键字来给予现有类型另一个名字。例如，可以像这样创建 i32 的别名 Kilometers：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">type</span> <span style="color: #98fb98;">Kilometers</span> = <span style="color: #98fb98;">i32</span>;
</pre>
</div>

<p>
这意味着 Kilometers 是 i32 的 <b>同义词</b> 不同于前面创建的 Millimeters 和 Meters 类型。Kilometers 不是一个新的、单独的类型。Kilometers 类型的值将被完全当作 i32 类型值来对待：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">type</span> <span style="color: #98fb98;">Kilometers</span> = <span style="color: #98fb98;">i32</span>;

<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">x</span>: <span style="color: #98fb98;">i32</span> = 5;
<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">y</span>: <span style="color: #98fb98;">Kilometers</span> = 5;

<span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"x + y = </span><span style="color: #ffa07a; font-style: italic;">{}</span><span style="color: #ffa07a;">"</span>, x + y);
</pre>
</div>

<pre class="example">
     因为 Kilometers 是 i32 的别名，他们是同一类型，可以将 i32 与 Kilometers 相加，也可以将 Kilometers 传递给获取 i32 参数的函数

     但通过这种手段无法获得上一部分讨论的 newtype 模式所提供的类型检查的好处
</pre>

<p>
类型别名的主要用途是 <b>减少重复</b> 。例如，可能会有这样很长的类型：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #98fb98;">Box</span>&lt;<span style="color: #00ffff;">dyn</span> <span style="color: #98fb98;">Fn</span>() + <span style="color: #98fb98;">Send</span> + '<span style="color: #00ffff;">static</span>&gt;
</pre>
</div>

<p>
在函数签名或类型注解中每次都书写这个类型将是枯燥且易于出错的。想象一下全是如此代码的项目：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">let</span> <span style="color: #eedd82;">f</span>: <span style="color: #98fb98;">Box</span>&lt;<span style="color: #00ffff;">dyn</span> <span style="color: #98fb98;">Fn</span>() + <span style="color: #98fb98;">Send</span> + '<span style="color: #00ffff;">static</span>&gt; = <span style="color: #98fb98;">Box</span>::new(|| <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"hi"</span>));

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">takes_long_type</span>(<span style="color: #eedd82;">f</span>: <span style="color: #98fb98;">Box</span>&lt;<span style="color: #00ffff;">dyn</span> <span style="color: #98fb98;">Fn</span>() + <span style="color: #98fb98;">Send</span> + '<span style="color: #00ffff;">static</span>&gt;) {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">--snip--</span>
}

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">returns_long_type</span>() -&gt; <span style="color: #98fb98;">Box</span>&lt;<span style="color: #00ffff;">dyn</span> <span style="color: #98fb98;">Fn</span>() + <span style="color: #98fb98;">Send</span> + '<span style="color: #00ffff;">static</span>&gt; {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">--snip--</span>
}
</pre>
</div>

<p>
类型别名通过减少项目中重复代码的数量来使其更加易于控制。这里为这个冗长的类型引入了一个叫做 Thunk 的别名，这样就可以将所有使用这个类型的地方替换为更短的 Thunk：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">type</span> <span style="color: #98fb98;">Thunk</span> = <span style="color: #98fb98;">Box</span>&lt;<span style="color: #00ffff;">dyn</span> <span style="color: #98fb98;">Fn</span>() + <span style="color: #98fb98;">Send</span> + '<span style="color: #00ffff;">static</span>&gt;;

<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">f</span>: <span style="color: #98fb98;">Thunk</span> = <span style="color: #98fb98;">Box</span>::new(|| <span style="color: #b0c4de;">println!</span>(<span style="color: #ffa07a;">"hi"</span>));

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">takes_long_type</span>(<span style="color: #eedd82;">f</span>: <span style="color: #98fb98;">Thunk</span>) {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">--snip--</span>
}

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">returns_long_type</span>() -&gt; <span style="color: #98fb98;">Thunk</span> {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">--snip--</span>
}
</pre>
</div>

<pre class="example">
     这样就读写起来就容易多了！

     为类型别名选择一个好名字也可以帮助表达意图（单词 thunk 表示会在之后被计算的代码，所以这是一个存放闭包的合适的名字）
</pre>

<p>
类型别名也经常与 <span class="underline">Result&lt;T, E&gt;</span> 结合使用来减少重复。考虑一下标准库中的 std::io 模块。I/O 操作通常会返回一个 Result&lt;T, E&gt;，因为这些操作可能会失败。标准库中的 std::io::Error 结构体代表了所有可能的 I/O 错误。std::io 中大部分函数会返回 Result&lt;T, E&gt;，其中 E 是 std::io::Error，比如 Write trait 中的这些函数：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">io</span>::<span style="color: #98fb98;">Error</span>;
<span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::fmt;

<span style="color: #00ffff;">pub</span> <span style="color: #00ffff;">trait</span> <span style="color: #98fb98;">Write</span> {
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">write</span>(&amp;<span style="color: #00ffff;">mut</span> <span style="color: #00ffff;">self</span>, <span style="color: #eedd82;">buf</span>: &amp;[<span style="color: #98fb98;">u8</span>]) -&gt; <span style="color: #98fb98;">Result</span>&lt;<span style="color: #98fb98;">usize</span>, <span style="color: #98fb98;">Error</span>&gt;;
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">flush</span>(&amp;<span style="color: #00ffff;">mut</span> <span style="color: #00ffff;">self</span>) -&gt; <span style="color: #98fb98;">Result</span>&lt;(), <span style="color: #98fb98;">Error</span>&gt;;

    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">write_all</span>(&amp;<span style="color: #00ffff;">mut</span> <span style="color: #00ffff;">self</span>, <span style="color: #eedd82;">buf</span>: &amp;[<span style="color: #98fb98;">u8</span>]) -&gt; <span style="color: #98fb98;">Result</span>&lt;(), <span style="color: #98fb98;">Error</span>&gt;;
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">write_fmt</span>(&amp;<span style="color: #00ffff;">mut</span> <span style="color: #00ffff;">self</span>, <span style="color: #eedd82;">fmt</span>: <span style="color: #7fffd4;">fmt</span>::<span style="color: #98fb98;">Arguments</span>) -&gt; <span style="color: #98fb98;">Result</span>&lt;(), <span style="color: #98fb98;">Error</span>&gt;;
}
</pre>
</div>

<p>
这里出现了很多的 Result&lt;&#x2026;, Error&gt;。为此，std::io 有这个类型别名声明：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">type</span> <span style="color: #98fb98;">Result</span>&lt;<span style="color: #98fb98;">T</span>&gt; = <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">result</span>::<span style="color: #98fb98;">Result</span>&lt;<span style="color: #98fb98;">T</span>, <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">io</span>::<span style="color: #98fb98;">Error</span>&gt;;
</pre>
</div>

<p>
因为这位于 std::io 中，可用的完全限定的别名是 std::io::Result&lt;T&gt;。Write trait 中的函数最终看起来像这样：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">pub</span> <span style="color: #00ffff;">trait</span> <span style="color: #98fb98;">Write</span> {
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">write</span>(&amp;<span style="color: #00ffff;">mut</span> <span style="color: #00ffff;">self</span>, <span style="color: #eedd82;">buf</span>: &amp;[<span style="color: #98fb98;">u8</span>]) -&gt; <span style="color: #98fb98;">Result</span>&lt;<span style="color: #98fb98;">usize</span>&gt;;
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">flush</span>(&amp;<span style="color: #00ffff;">mut</span> <span style="color: #00ffff;">self</span>) -&gt; <span style="color: #98fb98;">Result</span>&lt;()&gt;;

    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">write_all</span>(&amp;<span style="color: #00ffff;">mut</span> <span style="color: #00ffff;">self</span>, <span style="color: #eedd82;">buf</span>: &amp;[<span style="color: #98fb98;">u8</span>]) -&gt; <span style="color: #98fb98;">Result</span>&lt;()&gt;;
    <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">write_fmt</span>(&amp;<span style="color: #00ffff;">mut</span> <span style="color: #00ffff;">self</span>, <span style="color: #eedd82;">fmt</span>: <span style="color: #98fb98;">Arguments</span>) -&gt; <span style="color: #98fb98;">Result</span>&lt;()&gt;;
}
</pre>
</div>

<pre class="example">
类型别名在两个方面有帮助：

1. 易于编写 并 在整个 std::io 中提供了一致的接口
2. 因为这是一个别名，它只是另一个 Result&lt;T, E&gt;，这意味着可以在其上使用 Result&lt;T, E&gt; 的任何方法，以及像 ? 这样的特殊语法
</pre>
</div>
</div>

<div id="outline-container-orgd93cf0f" class="outline-3">
<h3 id="orgd93cf0f">从不返回的 never type</h3>
<div class="outline-text-3" id="text-orgd93cf0f">
<p>
Rust 有一个叫做 <span class="underline">!</span> 的特殊类型。在类型理论术语中，它被称为 empty type，因为它没有值。我们更倾向于称之为 <span class="underline">never type</span> 。这个名字描述了它的作用：在 <b>函数从不返回的时候充当返回值</b> 。例如：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">bar</span>() -&gt; ! {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">--snip--</span>
}
</pre>
</div>

<p>
函数 bar 从不返回，而从不返回的函数被称为 <span class="underline">发散函数</span> 。不能创建 ! 类型的值，所以 bar 也不可能返回值。不过一个不能创建值的类型有什么用呢？回想一下以前示例的代码：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">let</span> <span style="color: #eedd82;">guess</span>: <span style="color: #98fb98;">u32</span> = <span style="color: #00ffff;">match</span> guess.trim().parse() {
    <span style="color: #98fb98;">Ok</span>(num) =&gt; num,
    <span style="color: #98fb98;">Err</span>(_) =&gt; <span style="color: #00ffff;">continue</span>,
};
</pre>
</div>

<p>
当时我们忽略了代码中的一些细节。后来学习了 match 的分支必须返回相同的类型。如下代码不能工作：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">let</span> <span style="color: #eedd82;">guess</span> = <span style="color: #00ffff;">match</span> guess.trim().parse() {
    <span style="color: #98fb98;">Ok</span>(_) =&gt; 5,
    <span style="color: #98fb98;">Err</span>(_) =&gt; <span style="color: #ffa07a;">"hello"</span>,
}
</pre>
</div>

<pre class="example">
这里的 guess 必须既是整型 也是 字符串，而 Rust 要求 guess 只能是一个类型

那么 continue 返回了什么呢？为什么开头的示例中会允许一个分支返回 u32 而另一个分支却以 continue 结束呢？

continue 的值是 !。也就是说，当 Rust 要计算 guess 的类型时，它查看这两个分支。前者是 u32 值，而后者是 ! 值。因为 ! 并没有一个值，Rust 决定 guess 的类型是 u32。

描述 ! 的行为的正式方式是 never type 可以强转为任何其他类型。允许 match 的分支以 continue 结束是因为 continue 并不真正返回一个值；相反它把控制权交回上层循环，所以在 Err 的情况，事实上并未对 guess 赋值
</pre>

<p>
never type 的另一个用途是 <span class="underline">panic!</span> 。还记得 Option&lt;T&gt; 上的 unwrap 函数吗？它产生一个值或 panic。这里是它的定义：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">impl</span>&lt;<span style="color: #98fb98;">T</span>&gt; <span style="color: #98fb98;">Option</span>&lt;<span style="color: #98fb98;">T</span>&gt; {
    <span style="color: #00ffff;">pub</span> <span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">unwrap</span>(<span style="color: #00ffff;">self</span>) -&gt; <span style="color: #98fb98;">T</span> {
        <span style="color: #00ffff;">match</span> <span style="color: #00ffff;">self</span> {
            <span style="color: #98fb98;">Some</span>(val) =&gt; val,
            <span style="color: #98fb98;">None</span> =&gt; <span style="color: #7fffd4;">panic!</span>(<span style="color: #ffa07a;">"called `Option::unwrap()` on a `None` value"</span>),
        }
    }
}
</pre>
</div>

<pre class="example">
这里与前面的 match 发生了相同的情况：

Rust 知道 val 是 T 类型，panic! 是 ! 类型，所以整个 match 表达式的结果是 T 类型。这能工作是因为 panic! 并不产生一个值；它会终止程序

对于 None 的情况，unwrap 并不返回一个值，所以这些代码是有效
</pre>

<p>
最后一个有着 ! 类型的表达式是 <span class="underline">loop</span> ：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #b0c4de;">print!</span>(<span style="color: #ffa07a;">"forever "</span>);

<span style="color: #00ffff;">loop</span> {
    <span style="color: #b0c4de;">print!</span>(<span style="color: #ffa07a;">"and ever "</span>);
}
</pre>
</div>

<pre class="example">
     这里，循环永远也不结束，所以此表达式的值是 !

     但是如果引入 break 这就不为真了，因为循环在执行到 break 后就会终止
</pre>
</div>
</div>

<div id="outline-container-org2995db0" class="outline-3">
<h3 id="org2995db0">动态大小类型和 Sized trait</h3>
<div class="outline-text-3" id="text-org2995db0">
<pre class="example">
     因为 Rust 需要知道例如应该为特定类型的值分配多少空间

     这样的信息其类型系统的一个特定的角落可能令人迷惑：这就是 动态大小类型的概念

     这有时被称为 “DST” 或 “unsized types”，这些类型允许处理只有在运行时才知道大小的类型
</pre>
<p>
一个贯穿本书都在使用的动态大小类型的细节： <b>str</b> 。没错，不是 <span class="underline">&amp;str</span> ，而是 str 本身。str 是一个 DST；直到运行时都不知道字符串有多长。因为直到运行时都不能知道大其小，也就意味着 <b>不能创建 str 类型的变量</b> ，也 <b>不能获取 str 类型的参数</b> 。考虑一下这些代码，他们不能工作：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">let</span> <span style="color: #eedd82;">s1</span>: <span style="color: #98fb98;">str</span> = <span style="color: #ffa07a;">"Hello there!"</span>;
<span style="color: #00ffff;">let</span> <span style="color: #eedd82;">s2</span>: <span style="color: #98fb98;">str</span> = <span style="color: #ffa07a;">"How's it going?"</span>;
</pre>
</div>

<pre class="example">
Rust 需要知道应该为特定类型的值分配多少内存，同时所有同一类型的值必须使用相同数量的内存

如果允许编写这样的代码，也就意味着这两个 str 需要占用完全相同大小的空间，不过它们有着不同的长度。这也就是为什么不可能创建一个存放动态大小类型的变量的原因。

那么该怎么办？ 答案是 s1 和 s2 的类型是 &amp;str 而不是 str
</pre>

<p>
所以虽然 &amp;T 是一个储存了 T 所在的内存位置的单个值，&amp;str 则是 两个 值：str 的地址和其长度。这样，&amp;str 就有了一个在编译时可以知道的大小：它是 usize 长度的两倍。也就是说，我们总是知道 &amp;str 的大小，而无论其引用的字符串是多长。这里是 Rust 中动态大小类型的常规用法：他们有一些额外的元信息来储存动态信息的大小。这引出了动态大小类型的黄金规则： <b>必须将动态大小类型的值置于某种指针之后</b> 
</p>

<pre class="example">
     可以将 str 与所有类型的指针结合：比如 Box&lt;str&gt; 或 Rc&lt;str&gt;

     事实上，不过是另一个动态大小类型：trait。每一个 trait 都是一个可以通过 trait 名称来引用的动态大小类型

     在“为使用不同类型的值而设计的 trait 对象” 部分，提到了为了将 trait 用于 trait 对象，必须将他们放入指针之后，比如 &amp;Trait 或 Box&lt;Trait&gt;（Rc&lt;Trait&gt; 也可以）
</pre>

<p>
为了处理 DST，Rust 有一个特定的 trait 来决定一个类型的大小是否在编译时可知：这就是 <span class="underline">Sized trait</span> 。这个 trait 自动为编译器在编译时就知道大小的类型实现。另外，Rust <b>隐式的为每一个泛型函数增加了 Sized bound</b> 。也就是说，对于如下泛型函数定义：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">generic</span>&lt;<span style="color: #98fb98;">T</span>&gt;(<span style="color: #eedd82;">t</span>: <span style="color: #98fb98;">T</span>) {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">--snip--</span>
}
</pre>
</div>

<p>
实际上被当作如下处理：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">generic</span>&lt;<span style="color: #eedd82;">T</span>: <span style="color: #98fb98;">Sized</span>&gt;(<span style="color: #eedd82;">t</span>: <span style="color: #98fb98;">T</span>) {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">--snip--</span>
}
</pre>
</div>

<p>
泛型函数默认只能用于在编译时已知大小的类型。然而可以使用如下特殊语法来放宽这个限制：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">generic</span>&lt;<span style="color: #eedd82;">T</span>: <span style="color: #b0c4de; font-weight: bold;">?</span><span style="color: #98fb98;">Sized</span>&gt;(<span style="color: #eedd82;">t</span>: &amp;<span style="color: #98fb98;">T</span>) {
    <span style="color: #ff4500;">// </span><span style="color: #ff4500;">--snip--</span>
}
</pre>
</div>

<p>
<span class="underline">?Sized</span> trait bound 与 Sized 相对；也就是说，它可以解释为 <b>T 可能是也可能不是 Sized 的</b>
</p>

<pre class="example">
     这个语法只能用于 Sized ，而不能用于其他 trait

     另外注意将 t 参数的类型从 T 变为了 &amp;T：因为其类型可能不是 Sized 的，所以需要将其置于某种指针之后，在这个例子中选择了引用。
</pre>
</div>
</div>
</div>

<div id="outline-container-org767e606" class="outline-2">
<h2 id="org767e606">高级函数和闭包</h2>
</div>

<div id="outline-container-orgafb23f7" class="outline-2">
<h2 id="orgafb23f7">宏</h2>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>

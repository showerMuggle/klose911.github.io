#+TITLE: Kubernetes 中的用户与身份认证授权
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../../css/main.css" />
#+HTML_LINK_UP: authentication.html
#+HTML_LINK_HOME: security.html
#+OPTIONS: num:nil timestamp:nil ^:nil

#+BEGIN_EXAMPLE
  在安装集群的时候在 master 节点上生成了一堆证书、token，还在 kubelet 的配置中用到了 bootstrap token

  安装各种应用时，为了能够与 API server 通信创建了各种 service account

  在 Dashboard 中使用了 kubeconfig 或 token 登陆

  那么这些都属于什么认证方式？如何区分用户的？
#+END_EXAMPLE

重点查看 bearer token 和 HTTP 认证中的 token 如 [[file:authentication.org][身份认证]]
* 用户
  Kubernetes 集群中包含两类用户：
  + 由 Kubernetes 管理的 service account：
    + service account 是由 Kubernetes API 管理的帐户
    + 绑定到了特定的 namespace
    + 由 API server 自动创建，或者通过 API 调用手动创建
    + 关联了一套凭证，存储在 Secret，这些凭证同时被挂载到 pod 中，从而允许 pod 与 kubernetes API 之间的调用 
  + 普通用户：普通用户被假定为由外部独立服务管理
    #+BEGIN_EXAMPLE
      管理员分发私钥，用户存储（如 Keystone 或 Google 帐户），甚至包含用户名和密码列表的文件

      在这方面，Kubernetes 没有代表普通用户帐户的对象，无法通过 API 调用的方式向集群中添加普通用户
    #+END_EXAMPLE


  API 请求被绑定到普通用户或 serivce account 上，或者作为匿名请求对待

  #+BEGIN_EXAMPLE
    这意味着集群内部或外部的每个进程，无论从：
    1. 在工作站上输入 kubectl 的人类用户
    2. 节点上的 kubelet
    3. 控制平面的成员

    都必须在向 API Server 发出请求时进行身份验证，或者被视为匿名用户 
  #+END_EXAMPLE
* 策略
  Kubernetes 使用 _客户端证书_ 、 _bearer token_ 、 _身份验证代理_ 或者 _HTTP 基本身份验证_ 等 *身份认证插件* 来对 API 请求进行身份验证。当有 HTTP 请求发送到 API server 时，插件会尝试将以下属性关联到请求上：
  + *用户名* ：标识最终用户的字符串
    #+BEGIN_EXAMPLE
      常用值可能是 kube-admin 或 jane@example.com
    #+END_EXAMPLE
  + *UID* ：标识最终用户的字符串
    #+BEGIN_EXAMPLE
      比用户名更加一致且唯一
    #+END_EXAMPLE
  + *组* ：一组将用户和常规用户组相关联的字符串
  + 额外字段：包含其他有用认证信息的字符串列表的映射 

  #+BEGIN_EXAMPLE
    所有的值对于认证系统都是不透明的，只有 授权人 才能解释这些值的重要含义
  #+END_EXAMPLE

  可以一次性启用多种身份验证方式。通常使用至少以下两种认证方式：
  + 服务帐户的 service account token
  + 至少一种其他的用户认证的方式

  #+BEGIN_EXAMPLE
    当启用了多个认证模块时，第一个认证模块成功认证后将短路请求，不会进行第二个模块的认证

    API server 不会保证认证的顺序
  #+END_EXAMPLE

  _system:authenticated_ 组包含在所有已验证用户的组列表中 

  #+BEGIN_EXAMPLE
    与其他身份验证协议（LDAP、SAML、Kerberos、x509 方案等）的集成可以使用身份验证代理或身份验证 webhook来实现
  #+END_EXAMPLE
** X509 客户端证书
   通过将 _--client-ca-file=SOMEFILE_ 选项传递给 API server 来启用客户端证书认证：
   + 引用的文件必须包含一个或多个证书颁发机构，用于验证提交给 API server 的客户端证书
   + 如果客户端证书已提交并验证，则使用 _subject_ 的 _Common Name_ （CN）作为请求的 _用户名_ 
   + 客户端证书还可以使用证书的 _organization_ 字段来指示用户的 _组成员_ 身份
     #+BEGIN_EXAMPLE
       要为用户包含多个组成员身份，请在证书中包含多个 organization 字段
     #+END_EXAMPLE

   例如，使用 openssl 命令工具生成用于签名认证请求的证书：
   #+BEGIN_SRC sh 
  $ openssl req -new -key jbeda.pem -out jbeda-csr.pem -subj "/CN=jbeda/O=app1/O=app2"
   #+END_SRC

   #+BEGIN_EXAMPLE
     这将为一个用户名为 ”jbeda“ 的 CSR，属于两个组“app1”和“app2”
   #+END_EXAMPLE
** 静态 Token 文件
   当在命令行上指定 _--token-auth-file=SOMEFILE_ 选项时，API server 从文件读取 bearer token

   #+BEGIN_EXAMPLE
     目前，token 会无限期地持续下去，并且不重新启动 API server 的话就无法更改令牌列表 
   #+END_EXAMPLE

   token 文件是一个 csv 文件，每行至少包含三列：token、用户名、用户 uid，其次是可选的组名
   #+BEGIN_EXAMPLE
     token,user,uid,"group1,group2,group3"
   #+END_EXAMPLE

   请注意，如果有多个组，则该列必须使用双引号
*** 在请求中放置 Bearer Token
    当使用来自 http 客户端的 bearer token 时，API server 期望 Authorization header 中包含 Bearer token 的值。Bearer token 必须是一个字符串序列，只需使用 HTTP 的编码和引用功能就可以将其放入到 HTTP header 中

    #+BEGIN_EXAMPLE
      例如：如果 bearer token 是 31ada4fd-adec-460c-809a-9e56ceb75269
    #+END_EXAMPLE

    那么它将出现在 HTTP header 中，如下所示：

    #+BEGIN_SRC sh 
  Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269
    #+END_SRC
** Bootstrap Token
   为了简化新集群的初始化引导过程，Kubernetes 中包含了一个名为 Bootstrap Token 的动态管理的 bearer token：
   + 这些 token 使用 Secret 存储在 kube-system namespace 中，在那里它们可以被动态管理和创建
   + Controller Manager 中包含了一个 TokenCleaner 控制器，用于在 bootstrap token 过期时删除将其删除。

   这些 token 的形式是 _[a-z0-9]{6}.[a-z0-9]{16}_ ：
   1. 第一部分是 Token ID
   2. 第二部分是 Token Secret

   在 HTTP header 中指定的 token 如下所示：

   #+BEGIN_SRC sh 
  Authorization: Bearer 781292.db7bc3a58fc5f07e
   #+END_SRC

   在 API server 的启动参数中加上 _--experimental-bootstrap-token-auth_ 标志以启用 Bootstrap Token Authenticator

   #+BEGIN_EXAMPLE
     必须通过 Controller Manager 上的 --controllers 标志启用 TokenCleaner 控制器，如 --controllers=*,tokencleaner

     如果使用它来引导集群， kubeadm 会自己完成
   #+END_EXAMPLE

   用户被认证为 _system:bootstrap:<Token ID>_ 。被包含在 _system:bootstrappers_ 组中

   #+BEGIN_EXAMPLE
     命名和组是有意限制用户使用过去的 bootstap token

     可以使用用户名和组（kubeadm 使用）来制定适当的授权策略以支持引导集群
   #+END_EXAMPLE
** 静态密码文件
   通过将 _--basic-auth-file=SOMEFILE_ 选项传递给 API server 来启用基本身份验证

   #+BEGIN_EXAMPLE
     目前，基本身份验证凭证将无限期地保留，并且密码在不重新启动API服务器的情况下无法更改

     请注意，目前支持基本身份验证只是为了方便使用，而其他模式更安全 
   #+END_EXAMPLE

   基本身份认证是一个 csv 文件，至少包含3列：密码、用户名和用户 ID

   #+BEGIN_SRC sh 
  password,user,uid,"group1,group2,group3"
   #+END_SRC

   #+BEGIN_EXAMPLE
     可以指定包含以逗号分隔的组名称的可选第四列

     如果有多个组，则必须将第四列值用双引号括起来
   #+END_EXAMPLE

   当使用来自 HTTP 客户端的基本身份验证时，API server 需要Authorization header 中包含 Basic BASE64ENCODED(USER:PASSWORD) 的值
** Service Account Token
   Service account 是一个 *自动启用* 的 _验证器_ ，它使用签名的 bearer token 来验证请求。该插件包括两个可选的标志：
   + _--service-account-key-file_ : 一个包含签名 bearer token 的 PEM 编码文件
     #+BEGIN_EXAMPLE
       如果未指定，将使用 API server 的 TLS 私钥
     #+END_EXAMPLE
   + _--service-account-lookup_ : 如果启用，从 API 中删除掉的 token 将被撤销

   Service account:
   + 通常 API server 自动创建，
   + 通过 ServiceAccount 注入控制器 关联到集群中运行的 Pod 上
   + Bearer token 挂载到 pod 中，并允许集群进程与 API server 通信
   + 可以使用 PodSpec 的 serviceAccountName 字段显式地与Pod关联 

   #+BEGIN_EXAMPLE
     注意： serviceAccountName 通常被省略，因为这会自动生成
   #+END_EXAMPLE

   #+BEGIN_SRC yaml 
  apiVersion: apps/v1beta2
  kind: Deployment
  metadata:
    name: nginx-deployment
    namespace: default
  spec:
    replicas: 3
    template:
      metadata:
      # ...
      spec:
	containers:
	- name: nginx
	  image: nginx:1.7.9
	  serviceAccountName: bob-the-bot
   #+END_SRC

   #+BEGIN_EXAMPLE
     Service account bearer token 在集群外使用也是完全有效的，并且可以用于为希望与 Kubernetes 通信的长期运行作业创建身份
   #+END_EXAMPLE

   要手动创建 service account，只需要使用 _kubectl create serviceaccount_ (NAME) 命令。这将在当前的 namespace 和相关连的 secret 中创建一个 service account:

   #+BEGIN_SRC sh 
  $ kubectl create serviceaccount jenkins
  serviceaccount "jenkins" created
  $ kubectl get serviceaccounts jenkins -o yaml
  apiVersion: v1
  kind: ServiceAccount
  metadata:
    # ...
  secrets:
  - name: jenkins-token-1yvwg
   #+END_SRC

   创建出的 secret 中拥有 API server 的公共 CA 和前面的 JSON Web Token（JWT）:

   #+BEGIN_SRC sh 
  $ kubectl get secret jenkins-token-1yvwg -o yaml
  apiVersion: v1
  data:
    ca.crt: (APISERVER'S CA BASE64 ENCODED)
    namespace: ZGVmYXVsdA==
    token: (BEARER TOKEN BASE64 ENCODED)
  kind: Secret
  metadata:
    # ...
  type: kubernetes.io/service-account-token
   #+END_SRC

   #+BEGIN_EXAMPLE
     注意：所有值是基于 base64 编码的，因为 secret 总是基于 base64 编码
   #+END_EXAMPLE

   经过签名的 JWT 可以用作 bearer token 与给定的 service account 进行身份验证

   #+BEGIN_EXAMPLE
     通常情况下，这些 secret 被挂载到 pod 中，以便对集群内的 API server 进行访问，但也可以从集群外访问
   #+END_EXAMPLE

   Service account 被验证后：
   + 用户名: _system:serviceaccount:(NAMESPACE):(SERVICEACCOUNT)_ 
   + 被指定到组 _system:serviceaccounts_ 和 _system:serviceaccounts:(NAMESPACE)_ 

   #+BEGIN_EXAMPLE
     由于 service account 的 token 存储在 secret 中，所以具有对这些 secret 的读取权限的任何用户都可以作为 service account 进行身份验证

     授予 service account 权限和读取 secret 功能时要谨慎
   #+END_EXAMPLE

#+TITLE: Kubectl命令
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../../css/main.css" />
#+HTML_LINK_HOME: command.html
#+OPTIONS: num:nil timestamp:nil ^:nil

Kubernetes提供的kubectl命令是与集群交互最直接的方式，kubectl命令参考图如下：


#+ATTR_HTML: image :width 70% 
[[file:../../pic/kubernetes-kubectl-cheatsheet.png]]

Kubectl的子命令主要分为8个类别：
+ 基础命令（初学者都会使用的）
+ 基础命令（中级）
+ 部署命令
+ 集群管理命令
+ 故障排查和调试命令
+ 高级命令
+ 设置命令
+ 其他命令

#+BEGIN_EXAMPLE
  熟悉这些命令有助于操作和管理kubernetes集群
#+END_EXAMPLE

* 配置
** 命令行提示

   #+ATTR_HTML: image :width 70% 
   [[file:../../pic/tools-to-supercharge-kubectl.jpg]]

   + [[file:https:/github.com/ahmetb/kubectx][kubectx]]：用于切换kubernetes context
   + [[file:https:/github.com/jonmosco/kube-ps1][kube-ps1]]：为命令行终端增加$PROMPT字段
   + [[file:https:/github.com/cloudnativelabs/kube-shell][kube-shell]]：交互式带命令提示的kubectl终端

     全部配置完成后的kubectl终端如下图所示：

   #+ATTR_HTML: image :width 70% 
   [[file:../../pic/supercharged-kubectl.jpg]]
*** kube-shell
    #+begin_example
      开源项目kube-shell可以为kubectl提供自动的命令提示和补全，使用起来特别方便
    #+end_example
    Kube-shell有以下特性：
    + 命令提示，给出命令的使用说明
    + 自动补全，列出可选命令并可以通过tab键自动补全，支持模糊搜索
    + 高亮
    + 使用tab键可以列出可选的对象
    + vim模式

      安装：
      #+begin_src sh 
	pip install kube-shell --user -U
      #+end_src

** 身份认证
   Kubernetes中存在三种安全认证方式：
   + CA证书：API server与其它几个组件之间都是通过这种方式认证的
   + HTTP base：在API server的启动参数中指定的--token-auth-file=/etc/kubernetes/token.csv文件中明文的用户、组、密码和UID配置
   + bearer token：HTTP请求中header中传递的Autorization:Bearer token，这个token通常保存在创建角色跟serviceaccount绑定的时候生成的secret中

   kubectl通过读取 _kubeconfig_ 文件中的配置信息在向API server发送请求的时候同时传递认证信息，同时支持CA证书和bearer token的认证方式

** 命令自动补全
   #+begin_example
       建议使用oh-my-zsh，增加对kubectl命令自动补全支持

   #+end_example
   修改~/.zshrc文件，增加如下两行：

   #+begin_example
     plugins=(kubectl)
     source <(kubectl completion zsh)
   #+end_example

   保存后重启终端即可生效

* docker用户过渡到kubectl命令行
  kubectl，被设计成 docker-cli 用户所熟悉的样子，但是它们之间又存在一些必要的差异。接下来将展示每个 docker 子命令和 kubectl 与其等效的命令
  #+begin_example
    在使用 kubernetes 集群的时候，docker 命令通常情况是不需要用到的，只有在调试程序或者容器的时候用到

    基本上使用 kubectl 命令即可，所以在操作 kubernetes 的时候抛弃原先使用 docker 时的一些观念
  #+end_example

  
** docker run
   #+begin_example
     如何运行一个 nginx Deployment 并将其暴露出来？ 查看 kubectl run 
   #+end_example

   使用 docker 命令：

   #+begin_src sh 
     $ docker run -d --restart=always -e DOMAIN=cluster --name nginx-app -p 80:80 nginx
     a9ec34d9878748d2f33dc20cb25c714ff21da8d40558b45bfaec9955859075d0
     $ docker ps
     CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                         NAMES
     a9ec34d98787        nginx               "nginx -g 'daemon of   2 seconds ago       Up 2 seconds        0.0.0.0:80->80/tcp, 443/tcp   nginx-app
   #+end_src

   使用 kubectl 命令：

   #+begin_src sh 
     # start the pod running nginx
     $ kubectl run --image=nginx nginx-app --port=80 --env="DOMAIN=cluster"
     deployment "nginx-app" created
   #+end_src

   使用kubectl run 命令将创建一个名为 "nginx-app" 的 Deployment，这将保证有 N 个运行 nginx 的 pod（N 代表 spec 中声明的 replica 数，默认为 1）

   #+begin_example
     如果您运行的是老版本，将会创建一个 replication controller

     如果想沿用旧的行为，使用 --generation=run/v1 参数，这样就会创建 replication controller
   #+end_example

   接下来创建一个 service，使用 selector 匹配具有相应的 selector 的 Deployment：
   #+begin_src sh 
     # expose a port through with a service
     $ kubectl expose deployment nginx-app --port=80 --name=nginx-http
     service "nginx-http" exposed
   #+end_src

   默认情况下镜像会在后台运行，与docker run -d ... 类似，如果想在前台运行，使用：

   #+begin_example
     kubectl run [-i] [--tty] --attach <name> --image=<image>
   #+end_example

   与 docker run ... 不同的是，如果指定了 --attach ，将连接到 stdin，stdout 和 stderr，而不能控制具体连接到哪个输出流（docker -a ...）。

   #+begin_example
     因为使用 Deployment 启动了容器，如果终止了连接到的进程（例如 ctrl-c），容器将会重启，这跟 docker run -it不同

     如果销毁该 Deployment（和它的 pod），必须需要运行 kubectl delete deployment <name>
   #+end_example

** docker ps 
   #+begin_example
     如何列出哪些正在运行？查看 kubectl get
   #+end_example

   使用 docker 命令：

   #+begin_src sh 
     $ docker ps
     CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                         NAMES
     a9ec34d98787        nginx               "nginx -g 'daemon of   About an hour ago   Up About an hour    0.0.0.0:80->80/tcp, 443/tcp   nginx-app
   #+end_src

   使用 kubectl 命令：

   #+begin_src sh 
     $ kubectl get po
     NAME              READY     STATUS    RESTARTS   AGE
     nginx-app-5jyvm   1/1       Running   0          1h
   #+end_src

** docker attach

   #+begin_example
     如何连接到已经运行在容器中的进程？查看 kubectl attach
   #+end_example

   使用 docker 命令：

   #+begin_src sh 
     $ docker ps
     CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                         NAMES
     a9ec34d98787        nginx               "nginx -g 'daemon of   8 minutes ago       Up 8 minutes        0.0.0.0:80->80/tcp, 443/tcp   nginx-app
     $ docker attach a9ec34d98787
     ...
   #+end_src

   使用 kubectl 命令：

   #+begin_src sh 
     $ kubectl get pods
     NAME              READY     STATUS    RESTARTS   AGE
     nginx-app-5jyvm   1/1       Running   0          10m
     $ kubectl attach -it nginx-app-5jyvm
   #+end_src

** docker exec
   #+begin_example
     如何在容器中执行命令？查看 kubectl exec
   #+end_example

   使用 docker 命令：

   #+begin_src sh 
     $ docker ps
     CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                         NAMES
     a9ec34d98787        nginx               "nginx -g 'daemon of   8 minutes ago       Up 8 minutes        0.0.0.0:80->80/tcp, 443/tcp   nginx-app
     $ docker exec a9ec34d98787 cat /etc/hostname
     a9ec34d98787
   #+end_src

   使用 kubectl 命令：

   #+begin_src sh 
     $ kubectl get po
     NAME              READY     STATUS    RESTARTS   AGE
     nginx-app-5jyvm   1/1       Running   0          10m
     $ kubectl exec nginx-app-5jyvm -- cat /etc/hostname
     nginx-app-5jyvm
   #+end_src

   #+begin_example
     执行交互式命令怎么办？
   #+end_example

   使用 docker 命令：

   #+begin_src sh 
     $ docker exec -ti a9ec34d98787 /bin/sh
     # exit
   #+end_src

   使用 kubectl 命令：

   #+begin_src sh 
     $ kubectl exec -ti nginx-app-5jyvm -- /bin/sh      
     # exit
   #+end_src

   #+begin_example
     更多信息请查看 获取运行中容器的 Shell 环境 https://kubernetes.io/docs/tasks/debug-application-cluster/get-shell-running-container/
   #+end_example

** docker logs
   #+begin_example
     如何查看运行中进程的 stdout/stderr？查看 kubectl logs
   #+end_example

   使用 docker 命令：
   #+begin_src sh 
     $ docker logs -f a9e
     192.168.9.1 - - [14/Jul/2015:01:04:02 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.35.0" "-"
     192.168.9.1 - - [14/Jul/2015:01:04:03 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.35.0" "-"
   #+end_src

   使用 kubectl 命令：

   #+begin_src sh 
     $ kubectl logs -f nginx-app-zibvs
     10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.26.0" "-"
     10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.26.0" "-"
   #+end_src

   默认情况下如果 pod 中的进程退出 pod 也不会终止，相反它将会重启该进程

   #+begin_example
     这类似于 docker run 时的 --restart=always 选项， 这是和容器之间的主要差别

     在 docker 中，进程的每个调用的输出都是被连接起来的，但是对于 kubernetes，每个调用都是分开的
   #+end_example

   要查看以前在 kubernetes 中执行的输出，请执行以下操作：

   #+begin_src sh 
     $ kubectl logs --previous nginx-app-zibvs
     10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.26.0" "-"
     10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] "GET / HTTP/1.1" 200 612 "-" "curl/7.26.0" "-"
   #+end_src

** docker stop 和 docker rm
   #+begin_example
     如何停止和删除运行中的进程？查看 kubectl delete
   #+end_example

   使用 docker 命令：
   #+begin_src sh 
     $ docker ps
     CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                         NAMES
     a9ec34d98787        nginx               "nginx -g 'daemon of   22 hours ago        Up 22 hours         0.0.0.0:80->80/tcp, 443/tcp   nginx-app
     $ docker stop a9ec34d98787
     a9ec34d98787
     $ docker rm a9ec34d98787
     a9ec34d98787
   #+end_src

   使用 kubectl 命令：

   #+begin_src sh 
     $ kubectl get deployment nginx-app
     NAME        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
     nginx-app   1         1         1            1           2m
     $ kubectl get po -l run=nginx-app
     NAME                         READY     STATUS    RESTARTS   AGE
     nginx-app-2883164633-aklf7   1/1       Running   0          2m
     $ kubectl delete deployment nginx-app
     deployment "nginx-app" deleted
     $ kubectl get po -l run=nginx-app
     # Return nothing
   #+end_src

   #+begin_example
     请注意，不直接删除 pod

     使用 kubectl 命令，要删除拥有该 pod 的 Deployment。如果直接删除pod，Deployment 将会重新创建该 pod
   #+end_example

** docker login
   在 kubectl 中没有对 docker login 的直接模拟

   #+begin_example
     如果有兴趣在私有镜像仓库中使用 Kubernetes，请参阅 使用私有镜像仓库 https://kubernetes.io/docs/concepts/containers/images/#using-a-private-registry
   #+end_example

** 

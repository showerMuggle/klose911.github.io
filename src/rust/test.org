#+TITLE: 测试
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: generic.html   
#+HTML_LINK_HOME: rust.html
#+OPTIONS: num:nil timestamp:nil ^:nil

#+BEGIN_EXAMPLE
  Edsger W. Dijkstra 在其 1972 年的文章"The Humble Programmer"中说到"Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence"

  这并不意味着我们不该尽可能地测试软件！
#+END_EXAMPLE

程序的正确性意味着代码如期望的那样运行。Rust 是一个相当注重正确性的编程语言，不过正确性是一个难以证明的复杂主题。Rust 的类型系统在此问题上下了很大的功夫，不过它不可能捕获所有种类的错误。为此，Rust 也在语言本身包含了编写软件测试的支持

#+BEGIN_EXAMPLE
  例如，可以编写一个叫做 add_two 的将传递给它的值加二的函数。它的签名有一个整型参数并返回一个整型值

  当实现和编译这个函数时，Rust 会进行所有目前我们已经见过的类型检查和借用检查，例如，这些检查会确保我们不会传递 String 或无效的引用给这个函数

  Rust 所不能检查的是这个函数是否会准确的完成我们期望的工作：返回参数加二后的值，而不是比如说参数加 10 或减 50 的值！这也就是测试出场的地方

  我们可以编写测试断言，比如说，当传递 3 给 add_two 函数时，返回值是 5。无论何时对代码进行修改，都可以运行测试来确保任何现存的正确行为没有被改变
#+END_EXAMPLE

测试是一项复杂的技能：虽然不能在一个章节的篇幅中介绍如何编写好的测试的每个细节，但还是会讨论 Rust 测试功能的机制。我们会讲到编写测试时会用到的 _注解_ 和 _宏_ ，运行测试的 _默认行为_ 和选项，以及如何将测试 _组织_ 成单元测试和集成测试
* 如何编写测试
Rust 中的测试函数是用来 *验证* 非测试代码是否按照期望的方式运行的。测试函数体通常执行如下三种操作：
1. 设置任何所需的数据或状态
2. 运行需要测试的代码
3. 断言其结果是所期望的

看看 Rust 提供的专门用来编写测试的功能： _test 属性_ 、一些 _宏_ 和 _should_panic 属性_ 
** 测试函数剖析
作为最简单例子，Rust 中的测试就是一个带有 _test 属性_ 注解的 _函数_ 。属性是关于 Rust 代码片段的元数据
#+BEGIN_EXAMPLE
前面的结构体中用到的 derive 属性就是一个例子
#+END_EXAMPLE
为了将一个函数变成测试函数，需要在 _fn 行_ 之前加上 _#[test]_ 。当使用 _cargo test_ 命令运行测试时，Rust 会构建一个测试执行程序用来调用标记了 test 属性的函数，并报告每一个测试是通过还是失败

#+BEGIN_EXAMPLE
  当使用 Cargo 新建一个库项目时，它会自动生成一个测试模块和一个测试函数

  这有助于开始编写测试，因为这样每次开始新项目时不必去查找测试函数的具体结构和语法了

  当然也可以额外增加任意多的测试函数以及测试模块！
#+END_EXAMPLE

创建一个新的库项目 adder，adder 库中 src/lib.rs 的内容应该看起来：

#+BEGIN_SRC rust 
  #[cfg(test)]
  mod tests {
      #[test]
      fn it_works() {
	  assert_eq!(2 + 2, 4);
      }
  }
#+END_SRC

#+BEGIN_EXAMPLE
现在暂时忽略 tests 模块和 #[cfg(test)] 注解，并只关注函数来了解其如何工作
#+END_EXAMPLE

注意： fn 行之前的 _#[test]_ ：这个属性表明这是一个测试函数，这样测试执行者就知道将其作为测试处理
#+BEGIN_EXAMPLE
因为也可以在 tests 模块中拥有非测试的函数来帮助我们建立通用场景或进行常见操作，所以需要使用 #[test] 属性标明哪些函数是测试
#+END_EXAMPLE

函数体通过使用 _assert_eq! 宏_ 来断言 2 加 2 等于 4。一个典型的测试的格式，就是像这个例子中的断言一样

接下来运行就可以看到测试通过。 _cargo test_ 命令会运行项目中所有的测试，如下所示：

#+BEGIN_SRC sh 
  $ cargo test
     Compiling adder v0.1.0 (file:///projects/adder)
      Finished dev [unoptimized + debuginfo] target(s) in 0.22 secs
       Running target/debug/deps/adder-ce99bcc2479f4607

  running 1 test
  test tests::it_works ... ok

  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Doc-tests adder

  running 0 tests

  test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
#+END_SRC

Cargo 编译并运行了测试。在 Compiling、Finished 和 Running 这几行之后：
+ 首先看到 running 1 test 这一行
+ 下一行显示了生成的 _测试函数的名称_ ，它是 _it_works_ ，以及测试的运行结果 _ok_ 
+ 接着可以看到 _全体测试运行结果_ 的 *摘要* ：
  + _test result: ok._ 意味着 *所有测试都通过* 了
  + _1 passed; 0 failed_ 表示 *通过* 或 *失败* 的测试数量
  + 因为之前并 *没有将任何测试标记为忽略* ，所以摘要中会显示 _0 ignored_
  + 也 *没有过滤* 需要运行的测试，所以摘要中会显示 _0 filtered out_
  + _0 measured_ 统计是针对 *性能测试* 的
+ 测试输出中的以 _Doc-tests adder_ 开头的这一部分是所有 *文档测试* 的结果

#+BEGIN_EXAMPLE
  现在并没有任何文档测试，不过 Rust 会编译任何在 API 文档中的代码示例

  这个功能帮助我们使文档和代码保持同步
#+END_EXAMPLE

改变测试的名称并看看这如何改变测试的输出。给 it_works 函数起个不同的名字，比如 exploration，像这样：

#+BEGIN_SRC rust 
  #[cfg(test)]
  mod tests {
      #[test]
      fn exploration() {
	  assert_eq!(2 + 2, 4);
      }
  }
#+END_SRC
并再次运行 cargo test。现在输出中将出现 exploration 而不是 it_works：
#+BEGIN_SRC sh 
  running 1 test
  test tests::exploration ... ok

  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Doc-tests adder

  running 0 tests

  test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
#+END_SRC

再增加另一个测试，不过这一次是一个会失败的测试：
+ 当测试函数中出现 _panic_ 时测试就 *失败* 了
+ 每一个测试都在一个新线程中运行，当主线程发现测试线程异常了，就将对应测试标记为失败
#+BEGIN_EXAMPLE
已经知道最简单的造成 panic 的方法：调用 panic! 宏
#+END_EXAMPLE
写入新测试 another 后， src/lib.rs 现在看起来如示例所示：

#+BEGIN_SRC rust 
  #[cfg(test)]
  mod tests {
      #[test]
      fn exploration() {
	  assert_eq!(2 + 2, 4);
      }

      #[test]
      fn another() {
	  panic!("Make this test fail");
      }
  }
#+END_SRC

再次 cargo test 运行测试。输出它表明 exploration 测试通过了而 another 失败了：

#+BEGIN_SRC sh 
  running 2 tests
  test tests::exploration ... ok
  test tests::another ... FAILED

  failures:

  ---- tests::another stdout ----
  thread 'tests::another' panicked at 'Make this test fail', src/lib.rs:10:9
  note: Run with `RUST_BACKTRACE=1` for a backtrace.

  failures:
      tests::another

  test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

  error: test failed
#+END_SRC

_test tests::another_ 这一行是 _FAILED_ 而不是 ok 了。在单独测试结果和摘要之间多了两个新的部分：
+ 第一个部分：显示了测试 _失败的详细原因_ 
#+BEGIN_EXAMPLE
  在这个例子中，another 因为在src/lib.rs 的第 10 行 panicked at 'Make this test fail' 而失败
#+END_EXAMPLE
+ 第二个部分：列出了 _所有失败的测试_ 

#+BEGIN_EXAMPLE
  这在有很多测试和很多失败测试的详细输出时很有帮助

  可以通过使用失败测试的名称来只运行这个测试，以便调试
#+END_EXAMPLE

最后是 _摘要行_ ：总体上讲，测试结果是 _FAILED_ 。有一个测试通过和一个测试失败

#+BEGIN_EXAMPLE
  现在见过不同场景中测试结果是什么样子的了，再来看看除 panic! 之外的一些在测试中有帮助的宏吧
#+END_EXAMPLE
** 使用 assert! 宏来检查结果

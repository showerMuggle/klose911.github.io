#+TITLE: Service
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../../css/main.css" />
#+HTML_LINK_HOME: index.html
#+OPTIONS: num:nil timestamp:nil ^:nil

Kubernetes Pod 是有生命周期的，它们可以被创建，也可以被销毁，然而一旦被销毁生命就永远结束。 通过 ReplicationController 能够动态地创建和销毁 Pod

#+BEGIN_EXAMPLE
  每个 Pod 都会获取它自己的 IP 地址，即使这些 IP 地址不总是稳定可依赖的

  这会导致一个问题：在 Kubernetes 集群中，如果一组 Pod（称为 backend）为其它 Pod （称为 frontend）提供服务，那么那些 frontend 该如何发现，并连接到这组 Pod 中的哪些 backend 呢？
#+END_EXAMPLE
* 概念
Kubernetes Service 定义了这样一种抽象：
+ 一个 *Pod* 的 _逻辑分组_ 
+ 一种可以 *访问* 它们的 _策略_ ，通常称为微服务
  + 这一组 Pod 能够被 Service 访问到，通常是通过 _Label Selector_ 实现的 

#+BEGIN_EXAMPLE
  举个例子，考虑一个图片处理 backend，它运行了3个副本，这些副本是可互换的，而 frontend 不需要关心它们调用了哪个 backend 副本

  然而组成这一组 backend 程序的 Pod 实际上可能会发生变化，frontend 客户端不应该也没必要知道，而且也不需要跟踪这一组 backend 的状态

  Service 定义的抽象能够解耦这种关联
#+END_EXAMPLE

+ 对 Kubernetes 集群中的应用，Kubernetes 提供了简单的 _Endpoints API_ ，只要 Service 中的一组 _Pod_ 发生 *变更* ， _应用程序_ 就会 *被更新* 
+ 对非 Kubernetes 集群中的应用，Kubernetes 提供了基于 _VIP_ 的 *网桥* 的方式 *访问* _Service_ ，再由 Service  *重定向* 到 backend Pod
* 定义
一个 Service 在 Kubernetes 中是一个 _REST 对象_ ，和 Pod 类似。 像所有的 REST 对象一样， Service 定义可以基于 POST 方式，请求 apiserver 创建新的实例

#+BEGIN_EXAMPLE
  例如，假定有一组 Pod，它们对外暴露了 9376 端口，同时还被打上 "app=MyApp" 标签
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  kind: Service
  apiVersion: v1
  metadata:
    name: my-service
  spec:
    selector:
      app: MyApp
    ports:
      - protocol: TCP
	port: 80
	targetPort: 9376
#+END_EXAMPLE

上述配置将创建一个名称为 _my-service_ 的 *Service 对象* ，它会将请求代理到使用 _TCP_ 端口 _9376_ ，并且具有标签 _app=MyApp_ 的 Pod 上：
+ 这个 Service 将被指派一个 IP 地址（通常称为 _Cluster IP_ ），它会被 _服务的代理_ 使用
+ 该 Service 的 selector 将会持续评估，处理结果将被 _POST_ 到一个名称为 _my-service_ 的 *Endpoints 对象* 上 

#+BEGIN_EXAMPLE
  Service 能够将一个接收端口映射到任意的 targetPort，默认情况下，targetPort 将被设置为与 port 字段相同的值

  更有趣的是，targetPort 可以是一个字符串，引用了 backend Pod 的一个端口的名称，但是，实际指派给该端口名称的端口号，在每个 backend Pod 中可能并不相同

  对于部署和设计 Service ，这种方式会提供更大的灵活性。例如，可以在 backend 软件下一个版本中，修改 Pod 暴露的端口，并不会中断客户端的调用
#+END_EXAMPLE

Kubernetes Service 支持 _TCP_ 和 _UDP_ 协议，默认 TCP 协议 
** 没有 selector 的 Service
Service 抽象了该如何访问 Kubernetes Pod，但也能够抽象其它类型的 backend，例如：
+ 希望在生产环境中使用外部的数据库集群，但测试环境使用自己的数据库
+ 希望服务指向另一个 Namespace 中或其它集群中的服务
+ 正在将工作负载转移到 Kubernetes 集群，和运行在 Kubernetes 集群之外的 backend 

在任何这些场景中，都能够定义没有 selector 的 Service ：

#+BEGIN_EXAMPLE
  kind: Service
  apiVersion: v1
  metadata:
    name: my-service
  spec:
    ports:
      - protocol: TCP
	port: 80
	targetPort: 9376
#+END_EXAMPLE

由于这个 Service 没有 selector，就不会创建相关的 Endpoints 对象。可以手动将 Service 映射到指定的 Endpoints：

#+BEGIN_EXAMPLE
  kind: Endpoints
  apiVersion: v1
  metadata:
    name: my-service
  subsets:
    - addresses:
	- ip: 1.2.3.4
      ports:
	- port: 9376
#+END_EXAMPLE

  注意：Endpoint IP 地址不能是 loopback（ _127.0.0.0/8_ ）、 link-local（ _169.254.0.0/16_ ）、或者 link-local 多播（ _224.0.0.0/24_ ）

#+BEGIN_EXAMPLE
  访问没有 selector 的 Service，与有 selector 的 Service 的原理相同

  请求将被路由到用户定义的 Endpoint（该示例中为 1.2.3.4:9376）
#+END_EXAMPLE

_ExternalName_ Service 是 Service 的特例，它没有 selector，也没有定义任何的端口和 Endpoint。相反地，对于运行在集群外部的服务，它通过返回 _该外部服务的别名_ 这种方式来提供服务：

#+BEGIN_EXAMPLE
  kind: Service
  apiVersion: v1
  metadata:
    name: my-service
    namespace: prod
  spec:
    type: ExternalName
    externalName: my.database.example.com
#+END_EXAMPLE

当查询主机 my-service.prod.svc.CLUSTER时，集群的 DNS 服务将返回一个值为 _my.database.example.com_ 的 _CNAME 记录_ 。访问这个服务的工作方式与其它的相同，唯一不同的是重定向发生在 DNS 层，而且不会进行代理或转发

#+BEGIN_EXAMPLE
  如果后续决定要将数据库迁移到 Kubernetes 集群中，可以启动对应的 Pod，增加合适的 Selector 或 Endpoint，修改 Service 的 type
#+END_EXAMPLE
* VIP 和 Service 代理

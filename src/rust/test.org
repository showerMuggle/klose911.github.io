#+TITLE: 测试
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: generic.html   
#+HTML_LINK_HOME: rust.html
#+OPTIONS: num:nil timestamp:nil ^:nil

#+BEGIN_EXAMPLE
  Edsger W. Dijkstra 在其 1972 年的文章"The Humble Programmer"中说到"Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence"

  这并不意味着我们不该尽可能地测试软件！
#+END_EXAMPLE

程序的正确性意味着代码如期望的那样运行。Rust 是一个相当注重正确性的编程语言，不过正确性是一个难以证明的复杂主题。Rust 的类型系统在此问题上下了很大的功夫，不过它不可能捕获所有种类的错误。为此，Rust 也在语言本身包含了编写软件测试的支持

#+BEGIN_EXAMPLE
  例如，可以编写一个叫做 add_two 的将传递给它的值加二的函数。它的签名有一个整型参数并返回一个整型值

  当实现和编译这个函数时，Rust 会进行所有目前我们已经见过的类型检查和借用检查，例如，这些检查会确保我们不会传递 String 或无效的引用给这个函数

  Rust 所不能检查的是这个函数是否会准确的完成我们期望的工作：返回参数加二后的值，而不是比如说参数加 10 或减 50 的值！这也就是测试出场的地方

  我们可以编写测试断言，比如说，当传递 3 给 add_two 函数时，返回值是 5。无论何时对代码进行修改，都可以运行测试来确保任何现存的正确行为没有被改变
#+END_EXAMPLE

测试是一项复杂的技能：虽然不能在一个章节的篇幅中介绍如何编写好的测试的每个细节，但还是会讨论 Rust 测试功能的机制。我们会讲到编写测试时会用到的 _注解_ 和 _宏_ ，运行测试的 _默认行为_ 和选项，以及如何将测试 _组织_ 成单元测试和集成测试
* 如何编写测试
Rust 中的测试函数是用来 *验证* 非测试代码是否按照期望的方式运行的。测试函数体通常执行如下三种操作：
1. 设置任何所需的数据或状态
2. 运行需要测试的代码
3. 断言其结果是所期望的

看看 Rust 提供的专门用来编写测试的功能： _test 属性_ 、一些 _宏_ 和 _should_panic 属性_ 
** 测试函数剖析
作为最简单例子，Rust 中的测试就是一个带有 _test 属性_ 注解的 _函数_ 。属性是关于 Rust 代码片段的元数据
#+BEGIN_EXAMPLE
前面的结构体中用到的 derive 属性就是一个例子
#+END_EXAMPLE
为了将一个函数变成测试函数，需要在 _fn 行_ 之前加上 _#[test]_ 。当使用 _cargo test_ 命令运行测试时，Rust 会构建一个测试执行程序用来调用标记了 test 属性的函数，并报告每一个测试是通过还是失败

#+BEGIN_EXAMPLE
  当使用 Cargo 新建一个库项目时，它会自动生成一个测试模块和一个测试函数

  这有助于开始编写测试，因为这样每次开始新项目时不必去查找测试函数的具体结构和语法了

  当然也可以额外增加任意多的测试函数以及测试模块！
#+END_EXAMPLE

创建一个新的库项目 adder，adder 库中 src/lib.rs 的内容应该看起来：

#+BEGIN_SRC rust 
  #[cfg(test)]
  mod tests {
      #[test]
      fn it_works() {
	  assert_eq!(2 + 2, 4);
      }
  }
#+END_SRC

#+BEGIN_EXAMPLE
现在暂时忽略 tests 模块和 #[cfg(test)] 注解，并只关注函数来了解其如何工作
#+END_EXAMPLE

注意： fn 行之前的 _#[test]_ ：这个属性表明这是一个测试函数，这样测试执行者就知道将其作为测试处理
#+BEGIN_EXAMPLE
因为也可以在 tests 模块中拥有非测试的函数来帮助我们建立通用场景或进行常见操作，所以需要使用 #[test] 属性标明哪些函数是测试
#+END_EXAMPLE

函数体通过使用 _assert_eq! 宏_ 来断言 2 加 2 等于 4。一个典型的测试的格式，就是像这个例子中的断言一样

接下来运行就可以看到测试通过。 _cargo test_ 命令会运行项目中所有的测试，如下所示：

#+BEGIN_SRC sh 
  $ cargo test
     Compiling adder v0.1.0 (file:///projects/adder)
      Finished dev [unoptimized + debuginfo] target(s) in 0.22 secs
       Running target/debug/deps/adder-ce99bcc2479f4607

  running 1 test
  test tests::it_works ... ok

  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Doc-tests adder

  running 0 tests

  test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
#+END_SRC

Cargo 编译并运行了测试。在 Compiling、Finished 和 Running 这几行之后：
+ 首先看到 running 1 test 这一行
+ 下一行显示了生成的 _测试函数的名称_ ，它是 _it_works_ ，以及测试的运行结果 _ok_ 
+ 接着可以看到 _全体测试运行结果_ 的 *摘要* ：
  + _test result: ok._ 意味着 *所有测试都通过* 了
  + _1 passed; 0 failed_ 表示 *通过* 或 *失败* 的测试数量
  + 因为之前并 *没有将任何测试标记为忽略* ，所以摘要中会显示 _0 ignored_
  + 也 *没有过滤* 需要运行的测试，所以摘要中会显示 _0 filtered out_
  + _0 measured_ 统计是针对 *性能测试* 的
+ 测试输出中的以 _Doc-tests adder_ 开头的这一部分是所有 *文档测试* 的结果

#+BEGIN_EXAMPLE
  现在并没有任何文档测试，不过 Rust 会编译任何在 API 文档中的代码示例

  这个功能帮助我们使文档和代码保持同步
#+END_EXAMPLE

改变测试的名称并看看这如何改变测试的输出。给 it_works 函数起个不同的名字，比如 exploration，像这样：

#+BEGIN_SRC rust 
  #[cfg(test)]
  mod tests {
      #[test]
      fn exploration() {
	  assert_eq!(2 + 2, 4);
      }
  }
#+END_SRC
并再次运行 cargo test。现在输出中将出现 exploration 而不是 it_works：
#+BEGIN_SRC sh 
  running 1 test
  test tests::exploration ... ok

  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Doc-tests adder

  running 0 tests

  test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
#+END_SRC

再增加另一个测试，不过这一次是一个会失败的测试：
+ 当测试函数中出现 _panic_ 时测试就 *失败* 了
+ 每一个测试都在一个新线程中运行，当主线程发现测试线程异常了，就将对应测试标记为失败
#+BEGIN_EXAMPLE
已经知道最简单的造成 panic 的方法：调用 panic! 宏
#+END_EXAMPLE
写入新测试 another 后， src/lib.rs 现在看起来如示例所示：

#+BEGIN_SRC rust 
  #[cfg(test)]
  mod tests {
      #[test]
      fn exploration() {
	  assert_eq!(2 + 2, 4);
      }

      #[test]
      fn another() {
	  panic!("Make this test fail");
      }
  }
#+END_SRC

再次 cargo test 运行测试。输出它表明 exploration 测试通过了而 another 失败了：

#+BEGIN_SRC sh 
  running 2 tests
  test tests::exploration ... ok
  test tests::another ... FAILED

  failures:

  ---- tests::another stdout ----
  thread 'tests::another' panicked at 'Make this test fail', src/lib.rs:10:9
  note: Run with `RUST_BACKTRACE=1` for a backtrace.

  failures:
      tests::another

  test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

  error: test failed
#+END_SRC

_test tests::another_ 这一行是 _FAILED_ 而不是 ok 了。在单独测试结果和摘要之间多了两个新的部分：
+ 第一个部分：显示了测试 _失败的详细原因_ 
#+BEGIN_EXAMPLE
  在这个例子中，another 因为在src/lib.rs 的第 10 行 panicked at 'Make this test fail' 而失败
#+END_EXAMPLE
+ 第二个部分：列出了 _所有失败的测试_ 

#+BEGIN_EXAMPLE
  这在有很多测试和很多失败测试的详细输出时很有帮助

  可以通过使用失败测试的名称来只运行这个测试，以便调试
#+END_EXAMPLE

最后是 _摘要行_ ：总体上讲，测试结果是 _FAILED_ 。有一个测试通过和一个测试失败

#+BEGIN_EXAMPLE
  现在见过不同场景中测试结果是什么样子的了，再来看看除 panic! 之外的一些在测试中有帮助的宏吧
#+END_EXAMPLE
** 使用 assert! 宏来检查结果
_assert! 宏_ 由 _标准库_ 提供，在希望确保测试中一些条件为 true 时非常有用。需要向 assert! 宏提供一个求值为 _布尔值_ 的参数：
+ 如果值是 true，assert! 什么也不做，同时测试会通过
+ 如果值为 false，assert! 调用 panic! 宏，这会导致测试失败

#+BEGIN_EXAMPLE
  assert! 宏用来检查代码是否以期望的方式运行
#+END_EXAMPLE

前面有一个 Rectangle 结构体和一个 can_hold 方法，这里将他们放进 src/lib.rs：

#+BEGIN_SRC rust 
  #[derive(Debug)]
  struct Rectangle {
      width: u32,
      height: u32,
  }

  impl Rectangle {
      fn can_hold(&self, other: &Rectangle) -> bool {
	  self.width > other.width && self.height > other.height
      }
  }
#+END_SRC

在下面代码中，编写一个 larger_can_hold_smaller 方法来测试，这里创建一个长为 8 宽为 7 的 Rectangle 实例，并假设它可以放得下另一个长为 5 宽为 1 的 Rectangle 实例：

#+BEGIN_SRC rust 
  fn main() {}
  #[cfg(test)]
  mod tests {
      use super::*;

      #[test]
      fn larger_can_hold_smaller() {
	  let larger = Rectangle { width: 8, height: 7 };
	  let smaller = Rectangle { width: 5, height: 1 };

	  assert!(larger.can_hold(&smaller));
      }
  }
#+END_SRC

注意：在 tests 模块中新增加了一行：_use super::*;_ 。tests 是一个普通的模块，它遵循模块的可见性规则：
+ 因为这是一个内部模块，要测试外部模块中的代码，需要将其引入到内部模块的作用域中
+ 这里选择使用 glob 全局导入，以便在 tests 模块中使用所有在外部模块定义的内容

#+BEGIN_EXAMPLE
  将测试命名为 larger_can_hold_smaller，并创建所需的两个 Rectangle 实例

  接着调用 assert! 宏并传递 larger.can_hold(&smaller) 调用的结果作为参数

  这个表达式预期会返回 true，所以测试应该通过。让我们拭目以待！
#+END_EXAMPLE

运行 cargo test: 
#+BEGIN_SRC sh 
  running 1 test
  test tests::larger_can_hold_smaller ... ok

  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
#+END_SRC

再来增加另一个测试，这一回断言一个更小的矩形不能放下一个更大的矩形：

#+BEGIN_SRC rust 
  #[cfg(test)]
  mod tests {
      use super::*;

      #[test]
      fn larger_can_hold_smaller() {
	  // --snip--
      }

      #[test]
      fn smaller_cannot_hold_larger() {
	  let larger = Rectangle { width: 8, height: 7 };
	  let smaller = Rectangle { width: 5, height: 1 };

	  assert!(!smaller.can_hold(&larger));
      }
  }
#+END_SRC

#+BEGIN_EXAMPLE
  因为这里 can_hold 函数的正确结果是 false ，所以将这个结果取反后传递给 assert! 宏

  同样can_hold 返回 false 时测试就会通过：
#+END_EXAMPLE

#+BEGIN_SRC sh 
  running 2 tests
  test tests::smaller_cannot_hold_larger ... ok
  test tests::larger_can_hold_smaller ... ok

  test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
#+END_SRC

现在看看如果引入一个 bug 的话测试结果会发生什么。将 can_hold 方法中比较长度时本应使用大于号的地方改成小于号：

#+BEGIN_SRC rust 
  // --snip--

  impl Rectangle {
      fn can_hold(&self, other: &Rectangle) -> bool {
	  self.width < other.width && self.height > other.height
      }
  }
#+END_SRC

现在运行测试会产生：

#+BEGIN_SRC sh 
  running 2 tests
  test tests::smaller_cannot_hold_larger ... ok
  test tests::larger_can_hold_smaller ... FAILED

  failures:

  ---- tests::larger_can_hold_smaller stdout ----
  thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed:
  larger.can_hold(&smaller)', src/lib.rs:22:9
  note: Run with `RUST_BACKTRACE=1` for a backtrace.

  failures:
      tests::larger_can_hold_smaller

  test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
#+END_SRC

#+BEGIN_EXAMPLE
  测试捕获了 bug！

  因为 larger.length 是 8 而 smaller.length 是 5，can_hold 中的长度比较现在因为 8 不小于 5 而返回 false
#+END_EXAMPLE
*** 使用 assert_eq! 和 assert_ne! 宏来测试相等
#+BEGIN_EXAMPLE
  测试功能的一个常用方法是将需要“测试代码的值”与“期望值”做比较，并检查是否相等

  这可以通过向 assert! 宏传递一个使用 == 运算符的表达式来做到

  不过这个操作实在是太常见了
#+END_EXAMPLE
标准库提供了一对宏来更方便的处理这些操作 _assert_eq!_ 和 _assert_ne!_ ：
+ 这两个宏分别 *比较* 两个值是 _相等_ 还是 _不相等_
+ 当断言失败时他们也会打印出这两个值具体是什么，以便于观察测试 为什么 失败

#+BEGIN_EXAMPLE
assert! 只会打印出它从 == 表达式中得到了 false 值，而不是导致 false 的两个值
#+END_EXAMPLE

下面编写一个对其参数加二并返回结果的函数 add_two。接着使用 assert_eq! 宏测试这个函数：

#+BEGIN_SRC rust 
  pub fn add_two(a: i32) -> i32 {
      a + 2
  }

  #[cfg(test)]
  mod tests {
      use super::*;

      #[test]
      fn it_adds_two() {
	  assert_eq!(4, add_two(2));
      }
  }
#+END_SRC

测试通过了：

#+BEGIN_SRC sh 
  running 1 test
  test tests::it_adds_two ... ok

  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
#+END_SRC

#+BEGIN_EXAMPLE
  传递给 assert_eq! 宏的第一个参数 4 ，等于调用 add_two(2) 的结果

  测试中的这一行 test tests::it_adds_two ... ok 中 ok 表明测试通过！
#+END_EXAMPLE

在代码中引入一个 bug 来看看使用 assert_eq! 的测试失败是什么样的。修改 add_two 函数的实现使其加 3：

#+BEGIN_SRC rust 
  pub fn add_two(a: i32) -> i32 {
      a + 3
  }
#+END_SRC

再次运行测试：

#+BEGIN_SRC sh 
  running 1 test
  test tests::it_adds_two ... FAILED

  failures:

  ---- tests::it_adds_two stdout ----
  thread 'tests::it_adds_two' panicked at 'assertion failed: `(left == right)`
    left: `4`,
   right: `5`', src/lib.rs:11:9
  note: Run with `RUST_BACKTRACE=1` for a backtrace.

  failures:
      tests::it_adds_two

  test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
#+END_SRC

#+BEGIN_EXAMPLE
  测试捕获到了 bug！

  it_adds_two 测试失败，显示信息 assertion failed: `(left == right)` 并表明 left 是 4 而 right 是 5

  这个信息有助于开始调试：它说 assert_eq! 的 left 参数是 4，而 right 参数，也就是 add_two(2) 的结果，是 5

#+END_EXAMPLE

在一些语言和测试框架中，断言两个值相等的函数的参数叫做 _expected_ 和 _actual_ ，而且指定参数的顺序是很关键的。然而在 Rust 中，他们则叫做 _left_ 和 _right_ ，同时指定期望的值和被测试代码产生的 *值的顺序并不重要* 

#+BEGIN_EXAMPLE
  这个测试中的断言也可以写成 assert_eq!(add_two(2), 4)

  这时失败信息会变成 assertion failed: `(left == right)` 其中 left 是 5 而 right 是 4
#+END_EXAMPLE

assert_ne! 宏在传递给它的两个值不相等时通过，而在相等时失败

#+BEGIN_EXAMPLE
  在代码按预期运行，不确定值“会”是什么，不过能确定值绝对“不会”是什么的时候，这个宏最有用处

  例如，如果一个函数保证会以某种方式改变其输出，不过这种改变方式是由运行测试时是星期几来决定的，这时最好的断言可能就是函数的输出不等于其输入
#+END_EXAMPLE

assert_eq! 和 assert_ne! 宏在底层分别使用了 _==_ 和 _!=_ 。当断言失败时，这些宏会使用调试格式打印出其参数，这意味着 _被比较的值_ 必需 *实现* 了 _PartialEq_ 和 _Debug_ trait 

#+BEGIN_EXAMPLE
  所有的基本类型和大部分标准库类型都实现了这些 trait

  对于自定义的结构体和枚举，需要实现 PartialEq 才能断言他们的值是否相等，需要实现 Debug 才能在断言失败时打印他们的值

  因为这两个 trait 都是派生 trait，如在讨论“结构体和枚举时”所提到的，通常可以直接在结构体或枚举上添加 #[derive(PartialEq, Debug)] 注解
#+END_EXAMPLE
*** 自定义失败信息
可以向 assert!、assert_eq! 和 assert_ne! 宏传递一个 _可选的失败信息参数_ ，在测试失败时将自定义失败信息一同打印出来。任何在 assert! 的一个必需参数和 assert_eq! 和 assert_ne! 的两个必需参数之后指定的参数都会传递给 _format! 宏_ 

#+BEGIN_EXAMPLE
自定义信息有助于记录断言的意义；当测试失败时就能更好的理解代码出了什么问题
#+END_EXAMPLE

例如，比如说有一个根据人名进行问候的函数，希望测试将传递给函数的人名显示在输出中：

#+BEGIN_SRC rust 
  pub fn greeting(name: &str) -> String {
      format!("Hello {}!", name)
  }

  #[cfg(test)]
  mod tests {
      use super::*;

      #[test]
      fn greeting_contains_name() {
	  let result = greeting("Carol");
	  assert!(result.contains("Carol"));
      }
  }
#+END_SRC

#+BEGIN_EXAMPLE
  这个程序的需求还没有被确定，因此问候文本开头的 Hello 文本很可能会改变

  然而并不想在需求改变时不得不更新测试，所以相比检查 greeting 函数返回的确切值，仅仅断言输出的文本中包含输入参数
#+END_EXAMPLE

通过将 greeting 改为不包含 name 来在代码中引入一个 bug 来测试失败时是怎样的：

#+BEGIN_SRC rust 
  pub fn greeting(name: &str) -> String {
      String::from("Hello!")
  }
#+END_SRC

运行测试：
#+BEGIN_SRC sh 
  running 1 test
  test tests::greeting_contains_name ... FAILED

  failures:

  ---- tests::greeting_contains_name stdout ----
  thread 'tests::greeting_contains_name' panicked at 'assertion failed:
  result.contains("Carol")', src/lib.rs:12:9
  note: Run with `RUST_BACKTRACE=1` for a backtrace.

  failures:
      tests::greeting_contains_name
#+END_SRC

#+BEGIN_EXAMPLE
  结果仅仅告诉了断言失败了和失败的行号

  一个更有用的失败信息应该打印出 greeting 函数的值
#+END_EXAMPLE

为测试函数增加一个自定义失败信息参数：带占位符的格式字符串，以及 greeting 函数的值：

#+BEGIN_SRC rust 
  #[test]
  fn greeting_contains_name() {
      let result = greeting("Carol");
      assert!(
	  result.contains("Carol"),
	  "Greeting did not contain name, value was `{}`", result
      );
  }
#+END_SRC

再次运行测试，将会看到更有价值的信息：

#+BEGIN_SRC sh 
  running 1 test
  test tests::greeting_contains_name ... FAILED

  failures:

  ---- tests::greeting_contains_name stdout ----
  thread 'tests::greeting_contains_name' panicked at 'Greeting did not contain name, value was `Hello!`', src/lib.rs:19:2
  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


  failures:
      tests::greeting_contains_name

  test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
#+END_SRC

#+BEGIN_EXAMPLE
  在测试输出中看到所取得的确切的值，这会帮助理解真正发生了什么，而不是期望发生什么
#+END_EXAMPLE

** 使用 should_panic 检查 panic
除了检查代码是否返回期望的正确的值之外，检查代码是否 *按照期望处理错误* 也是很重要的

#+BEGIN_EXAMPLE
  例如，考虑前面创建的 Guess 类型。其他使用 Guess 的代码都是基于 Guess 实例仅有的值范围在 1 到 100 的前提

  可以编写一个测试来确保创建一个超出范围的值的 Guess 实例会 panic
#+END_EXAMPLE

通过对函数增加另一个属性 _should_panic_ 来实现这些：
+ 函数中的代码 panic 时会通过
+ 其中的代码没有 panic 时失败

下面展示了一个检查 Guess::new 是否按照期望出错的测试：

#+BEGIN_SRC rust 
  pub struct Guess {
      value: i32,
  }

  impl Guess {
      pub fn new(value: i32) -> Guess {
	  if value < 1 || value > 100 {
	      panic!("Guess value must be between 1 and 100, got {}.", value);
	  }

	  Guess {
	      value
	  }
      }
  }

  #[cfg(test)]
  mod tests {
      use super::*;

      #[test]
      #[should_panic]
      fn greater_than_100() {
	  Guess::new(200);
      }
  }
#+END_SRC

_#[should_panic]_ 属性位于 _#[test]_ 之后，对应的测试函数之前。运行测试后：

#+BEGIN_SRC sh 
  running 1 test
  test tests::greater_than_100 ... ok

  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
#+END_SRC

在代码中引入 bug，移除 new 函数在值大于 100 时会 panic 的条件：

#+BEGIN_SRC rust 
  // --snip--

  impl Guess {
      pub fn new(value: i32) -> Guess {
	  if value < 1  {
	      panic!("Guess value must be between 1 and 100, got {}.", value);
	  }

	  Guess {
	      value
	  }
      }
  }
#+END_SRC

再次运行测试：
#+BEGIN_SRC sh 
  running 1 test
  test tests::greater_than_100 ... FAILED

  failures:

  failures:
      tests::greater_than_100

  test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
#+END_SRC

#+BEGIN_EXAMPLE
  这回并没有得到非常有用的信息，不过一旦观察测试函数，会发现它标注了 #[should_panic]

  这个错误意味着代码中测试函数 Guess::new(200) 并没有产生 panic
#+END_EXAMPLE

有时 should_panic 测试结果可能会非常含糊不清，因为它只是告诉我们代码并没有产生 panic。should_panic 甚至在一些不是期望的原因而导致 panic 时也会通过。为了使 should_panic 测试结果更精确，可以给 should_panic 属性增加一个可选的 expected 参数。测试工具会确保错误信息中包含其提供的文本。例如，修改过的 Guess，这里 new 函数根据其值是过大还或者过小而提供不同的 panic 信息： 

#+BEGIN_SRC rust 
  impl Guess {
      pub fn new(value: i32) -> Guess {
	  if value < 1 {
	      panic!("Guess value must be greater than or equal to 1, got {}.",
		     value);
	  } else if value > 100 {
	      panic!("Guess value must be less than or equal to 100, got {}.",
		     value);
	  }

	  Guess {
	      value
	  }
      }
  }

  #[cfg(test)]
  mod tests {
      use super::*;

      #[test]
      #[should_panic(expected = "Guess value must be less than or equal to 100")]
      fn greater_than_100() {
	  Guess::new(200);
      }
  }
#+END_SRC

#+BEGIN_EXAMPLE
  这个测试会通过，因为 should_panic 属性中 expected 参数提供的值是 Guess::new 函数 panic 信息的子串

  可以指定期望的整个 panic 信息，在这个例子中是 Guess value must be less than or equal to 100, got 200. 。

  expected 信息的选择取决于 panic 信息有多独特或动态，和希望测试有多准确

  在这个例子中，错误信息的子字符串足以确保函数在 else if value > 100 的情况下运行
#+END_EXAMPLE

为了观察带有 expected 信息的 should_panic 测试失败时会发生什么，再次引入一个 bug，将 if value < 1 和 else if value > 100 的代码块对换：

#+BEGIN_SRC rust 
  if value < 1 {
      panic!("Guess value must be less than or equal to 100, got {}.", value);
  } else if value > 100 {
      panic!("Guess value must be greater than or equal to 1, got {}.", value);
  }
#+END_SRC

这一次运行 should_panic 测试，它会失败：

#+BEGIN_SRC sh 
  running 1 test
  test tests::greater_than_100 ... FAILED

  failures:

  ---- tests::greater_than_100 stdout ----
  thread 'tests::greater_than_100' panicked at 'Guess value must be
  greater than or equal to 1, got 200.', src/lib.rs:11:13
  note: Run with `RUST_BACKTRACE=1` for a backtrace.
  note: Panic did not include expected string 'Guess value must be less than or
  equal to 100'

  failures:
      tests::greater_than_100

  test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
#+END_SRC

#+BEGIN_EXAMPLE
  失败信息表明测试确实如期望 panic 了，不过 panic 信息中并没有包含 expected 信息 'Guess value must be less than or equal to 100'

  而我们得到的 panic 信息是 'Guess value must be greater than or equal to 1, got 200.'。这样就可以开始寻找 bug 在哪了！
#+END_EXAMPLE

** 将 Result<T, E> 用于测试
目前为止，编写的测试在失败时就会 panic。也可以使用 _Result<T, E>_ 编写测试！这里是第一个例子采用了 Result：

#+BEGIN_SRC rust 
  #[cfg(test)]
  mod tests {
      #[test]
      fn it_works() -> Result<(), String> {
	  if 2 + 2 == 4 {
	      Ok(())
	  } else {
	      Err(String::from("two plus two does not equal four"))
	  }
      }
  }
#+END_SRC

现在 it_works 函数的返回值类型为 _Result<(), String>_ 。在函数体中，不同于调用 assert_eq! 宏，而是：
+ 在测试通过时返回 _Ok(())_
+ 测试失败时返回带有 _String 的 Err_ 

#+BEGIN_EXAMPLE
  编写测试来返回 Result<T, E> 就可以在函数体中使用“问号”运算符，如此可以方便的编写任何运算符会返回 Err 成员的测试
#+END_EXAMPLE

*不能* 对这些使用 Result<T, E> 的测试使用 _#[should_panic] 注解_ 。相反应该在测试失败时 _直接返回 Err 值_ 

* 运行测试

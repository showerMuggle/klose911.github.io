#+TITLE: ConfigMap
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../../css/main.css" />
#+HTML_LINK_UP: secret.html
#+HTML_LINK_HOME: storage.html
#+OPTIONS: num:nil timestamp:nil ^:nil

#+begin_example
  其实ConfigMap功能在Kubernetes1.2版本的时候就有了

  许多应用程序会从配置文件、命令行参数或环境变量中读取配置信息

  这些配置信息需要与docker image解耦，总不能每修改一个配置就重做一个image吧？
#+end_example

ConfigMap API提供了向 _容器_ 中 *注入* _配置信息_ 的机制，ConfigMap可以被用来保存 _单个属性_ ，也可以用来保存整个 _配置文件_ 或者 _JSON二进制大对象_  

* 概述
  _ConfigMap_ API资源用来保存 _key-value pair_ *配置数据* ，这个数据可以在 _pods_ 里使用，或者被用来为像 _controller_ 一样的系统组件存储配置数据

  #+begin_example
    虽然ConfigMap跟Secrets类似，但是ConfigMap更方便的处理不含敏感信息的字符串

    注意：ConfigMaps不是属性配置文件的替代品，ConfigMaps只是作为多个properties文件的引用

    可以把它理解为Linux系统中的/etc目录，专门用来存储配置文件的目录
  #+end_example

  比如使用ConfigMap配置来创建Kubernetes Volumes，ConfigMap中的每个 _data_ 项都会成为一个 *新文件* ：
  #+begin_example
    kind: ConfigMap
    apiVersion: v1
    metadata:
      creationTimestamp: 2016-02-18T19:14:38Z
      name: example-config
      namespace: default
    data:
      example.property.1: hello
      example.property.2: world
      example.property.file: |-
	property.1=value-1
	property.2=value-2
	property.3=value-3
  #+end_example

  data一栏包括了配置数据，ConfigMap可以被用来保存单个属性，也可以用来保存一个配置文件。 配置数据可以通过很多种方式在Pods里被使用。ConfigMaps可以被用来：
  + 设置 _环境变量_ 的值
  + 在容器里设置 _命令行参数_ 
  + 在数据卷里面创建 _config文件_

  #+begin_example
    用户和系统组件两者都可以在ConfigMap里面存储配置数据
  #+end_example

  从kubectl create configmap -h的帮助信息中就可以对ConfigMap究竟如何创建略知一二了：

  #+begin_src sh 
    Examples:
    # Create a new configmap named my-config based on folder bar
    kubectl create configmap my-config --from-file=path/to/bar

    # Create a new configmap named my-config with specified keys instead of file basenames on disk
    kubectl create configmap my-config --from-file=key1=/path/to/bar/file1.txt --from-file=key2=/path/to/bar/file2.txt

    # Create a new configmap named my-config with key1=config1 and key2=config2
    kubectl create configmap my-config --from-literal=key1=config1 --from-literal=key2=config2
  #+end_src

* 创建
  可以使用该命令，用给定值、文件或目录来创建ConfigMap：
  #+begin_example
    kubectl create configmap
  #+end_example

** 目录
   比如已经有了一些配置文件，其中包含了想要设置的ConfigMap的值：

   #+begin_src sh 
     $ ls docs/user-guide/configmap/kubectl/
     game.properties
     ui.properties

     $ cat docs/user-guide/configmap/kubectl/game.properties
     enemies=aliens
     lives=3
     enemies.cheat=true
     enemies.cheat.level=noGoodRotten
     secret.code.passphrase=UUDDLRLRBABAS
     secret.code.allowed=true
     secret.code.lives=30

     $ cat docs/user-guide/configmap/kubectl/ui.properties
     color.good=purple
     color.bad=yellow
     allow.textmode=true
     how.nice.to.look=fairlyNice
   #+end_src

   使用下面的命令可以创建一个包含目录中所有文件的ConfigMap：

   #+begin_src sh 
     $ kubectl create configmap game-config --from-file=docs/user-guide/configmap/kubectl
   #+end_src

   _--from-file_ 指定在目录下的所有文件都会被用在ConfigMap里面创建一个键值对，键的名字就是文件名，值就是文件的内容。来看一下这个命令创建的ConfigMap：

   #+begin_src sh 
     $ kubectl describe configmaps game-config
     Name:           game-config
     Namespace:      default
     Labels:         <none>
     Annotations:    <none>

     Data
     ====
     game.properties:        158 bytes
     ui.properties:          83 bytes
   #+end_src

   可以看到那两个key是从kubectl指定的目录中的文件名

   #+begin_example
     这些key的内容可能会很大，所以在kubectl describe的输出中，只能够看到键的名字和他们的大小
   #+end_example

   如果想要看到键的值的话，可以使用kubectl get：

   #+begin_example
     apiVersion: v1
     data:
       game.properties: |
	 enemies=aliens
	 lives=3
	 enemies.cheat=true
	 enemies.cheat.level=noGoodRotten
	 secret.code.passphrase=UUDDLRLRBABAS
	 secret.code.allowed=true
	 secret.code.lives=30
       ui.properties: |
	 color.good=purple
	 color.bad=yellow
	 allow.textmode=true
	 how.nice.to.look=fairlyNice
     kind: ConfigMap
     metadata:
       creationTimestamp: 2016-02-18T18:34:05Z
       name: game-config
       namespace: default
       resourceVersion: "407"
       selfLink: /api/v1/namespaces/default/configmaps/game-config
       uid: 30944725-d66e-11e5-8cd0-68f728db1985
   #+end_example

** 文件
   #+begin_example
     刚才使用目录创建的时候--from-file指定的是一个目录
   #+end_example
   只要指定为一个文件就可以从单个文件中创建ConfigMap：

   #+begin_src sh 
     $ kubectl create configmap game-config-2 --from-file=docs/user-guide/configmap/kubectl/game.properties 

     $ kubectl get configmaps game-config-2 -o yaml
   #+end_src

   #+begin_example
     apiVersion: v1
     data:
       game-special-key: |
	 enemies=aliens
	 lives=3
	 enemies.cheat=true
	 enemies.cheat.level=noGoodRotten
	 secret.code.passphrase=UUDDLRLRBABAS
	 secret.code.allowed=true
	 secret.code.lives=30
     kind: ConfigMap
     metadata:
       creationTimestamp: 2016-02-18T18:54:22Z
       name: game-config-3
       namespace: default
       resourceVersion: "530"
       selfLink: /api/v1/namespaces/default/configmaps/game-config-3
       uid: 05f8da22-d671-11e5-8cd0-68f728db1985
   #+end_example

   _--from-file_ 这个参数可以使用多次

   #+begin_example
     可以使用两次分别指定上个实例中的那两个配置文件，效果就跟指定整个目录是一样的
   #+end_example

** 字面值 

   使用文字值创建，利用 _--from-literal_ 参数传递配置信息，该参数可以使用多次，格式如下；

   #+begin_src sh 
     $ kubectl create configmap special-config --from-literal=special.how=very --from-literal=special.type=charm

     $ kubectl get configmaps special-config -o yaml
   #+end_src

   #+begin_example
     apiVersion: v1
     data:
       special.how: very
       special.type: charm
     kind: ConfigMap
     metadata:
       creationTimestamp: 2016-02-18T19:14:38Z
       name: special-config
       namespace: default
       resourceVersion: "651"
       selfLink: /api/v1/namespaces/default/configmaps/special-config
       uid: dadce046-d673-11e5-8cd0-68f728db1985
   #+end_example

* 使用
  
** 替代环境变量
   ConfigMap可以被用来填入环境变量：
   #+begin_example
     apiVersion: v1
     kind: ConfigMap
     metadata:
       name: special-config
       namespace: default
     data:
       special.how: very
       special.type: charm
   #+end_example

   #+begin_example
     apiVersion: v1
     kind: ConfigMap
     metadata:
       name: env-config
       namespace: default
     data:
       log_level: INFO
   #+end_example

   在Pod中这样使用ConfigMap：

   #+begin_example

     apiVersion: v1
     kind: Pod
     metadata:
       name: dapi-test-pod
     spec:
       containers:
	 - name: test-container
	   image: gcr.io/google_containers/busybox
	   command: [ "/bin/sh", "-c", "env" ]
	   env:
	     - name: SPECIAL_LEVEL_KEY
	       valueFrom:
		 configMapKeyRef:
		   name: special-config
		   key: special.how
	     - name: SPECIAL_TYPE_KEY
	       valueFrom:
		 configMapKeyRef:
		   name: special-config
		   key: special.type
	   envFrom:
	     - configMapRef:
		 name: env-config
       restartPolicy: Never
   #+end_example

   这个Pod运行后会输出如下几行：

   #+begin_src sh 
     SPECIAL_LEVEL_KEY=very
     SPECIAL_TYPE_KEY=charm
     log_level=INFO
   #+end_src

** 设置命令行参数
   ConfigMap也可以被使用来设置容器中的命令或者参数值。它使用的是Kubernetes的 _$(VAR_NAME)_ 替换语法：

   #+begin_example
     apiVersion: v1
     kind: ConfigMap
     metadata:
       name: special-config
       namespace: default
     data:
       special.how: very
       special.type: charm
   #+end_example

   为了将ConfigMap中的值注入到命令行的参数里面，还要像前面那个例子一样使用环境变量替换语法$(VAR_NAME)

   #+begin_example
     apiVersion: v1
     kind: Pod
     metadata:
       name: dapi-test-pod
     spec:
       containers:
	 - name: test-container
	   image: gcr.io/google_containers/busybox
	   command: [ "/bin/sh", "-c", "echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)" ]
	   env:
	     - name: SPECIAL_LEVEL_KEY
	       valueFrom:
		 configMapKeyRef:
		   name: special-config
		   key: special.how
	     - name: SPECIAL_TYPE_KEY
	       valueFrom:
		 configMapKeyRef:
		   name: special-config
		   key: special.type
       restartPolicy: Never
   #+end_example
   运行这个Pod后会输出：

   #+begin_src sh 
     very charm
   #+end_src
   
   #+begin_example
     其实这个东西就是给Docker容器设置环境变量，通过：

     1. docker run的时候指定-e参数修改镜像里的环境变量
     2. docker的CMD命令再利用该$(VAR_NAME)通过sed来修改配置文件或者作为命令行启动参数
   #+end_example

** 数据卷插件使用ConfigMap
   
   在数据卷里面使用这个ConfigMap，有不同的选项。最基本的就是将 _文件_ *填入* _数据卷_ ，在这个文件中，键就是文件名，键值就是文件内容：

   #+begin_example
     apiVersion: v1
     kind: Pod
     metadata:
       name: dapi-test-pod
     spec:
       containers:
	 - name: test-container
	   image: gcr.io/google_containers/busybox
	   command: [ "/bin/sh", "-c", "cat /etc/config/special.how" ]
	   volumeMounts:
	   - name: config-volume
	     mountPath: /etc/config
       volumes:
	 - name: config-volume
	   configMap:
	     name: special-config
       restartPolicy: Never
   #+end_example

   运行这个Pod的输出：

   #+begin_src sh 
     very
   #+end_src

   也可以在ConfigMap值被映射的数据卷里控制路径：

   #+begin_example
     apiVersion: v1
     kind: Pod
     metadata:
       name: dapi-test-pod
     spec:
       containers:
	 - name: test-container
	   image: gcr.io/google_containers/busybox
	   command: [ "/bin/sh","-c","cat /etc/config/path/to/special-key" ]
	   volumeMounts:
	   - name: config-volume
	     mountPath: /etc/config
       volumes:
	 - name: config-volume
	   configMap:
	     name: special-config
	     items:
	     - key: special.how
	       path: path/to/special-key
       restartPolicy: Never
   #+end_example

   输出结果仍然是：
   #+begin_src 
very
   #+end_src

* 热更新

#+TITLE: 面向对象
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: concurrency.html   
#+HTML_LINK_HOME: rust.html
#+OPTIONS: num:nil timestamp:nil ^:nil

#+BEGIN_EXAMPLE
  面向对象编程是一种模式化编程方式

  对象来源于 20 世纪 60 年代的 Simula 编程语言。这些对象影响了 Alan Kay 的编程架构中对象之间的消息传递。他在 1967 年创造了 面向对象编程 这个术语来描述这种架构

  关于 OOP 是什么有很多相互矛盾的定义；在一些定义下，Rust 是面向对象的；在其他定义下，Rust 不是
#+END_EXAMPLE
在本章中，会探索一些被普遍认为是面向对象的特性和这些特性是如何体现在 Rust 语言习惯中的。接着会展示如何在 Rust 中实现面向对象设计模式，并讨论这么做与利用 Rust 自身的一些优势实现的方案相比有什么取舍
* 面向对象语言的特征
#+BEGIN_EXAMPLE
  关于一个语言被称为面向对象所需的功能，在编程社区内并未达成一致意见

  Rust 被很多不同的编程范式影响，包括面向对象编程和函数式编程的特性

  面向对象编程语言所共享的一些特性往往是对象、封装和继承

  先看一下每一个概念的含义以及 Rust 是否支持他们
#+END_EXAMPLE
** 对象包含数据和行为

#+BEGIN_EXAMPLE
  由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 编写的书 Design Patterns: Elements of Reusable Object-Oriented Software 被俗称为 The Gang of Four，它是面向对象编程模式的目录。它这样定义面向对象编程：

  面向对象的程序是由对象组成的。一个“对象”包含数据和操作这些数据的过程。这些过程通常被称为“方法”或“操作”
#+END_EXAMPLE

在这个定义下，Rust 是面向对象的：结构体和枚举包含数据而 impl 块提供了在结构体和枚举之上的方法

#+BEGIN_EXAMPLE
虽然带有方法的结构体和枚举并不被 称为 对象，但是他们提供了与对象相同的功能
#+END_EXAMPLE
** 封装隐藏了实现细节

#+BEGIN_EXAMPLE
  另一个通常与面向对象编程相关的方面是”封装“的思想：对象的实现细节不能被使用对象的代码获取到

  所以唯一与对象交互的方式是通过对象提供的公有 API；使用对象的代码无法深入到对象内部并直接改变数据或者行为

  封装使得改变和重构对象的内部时无需改变使用对象的代码
#+END_EXAMPLE

可以使用 _pub_ 关键字来决定 _模块_ 、 _类型_ 、 _函数_ 和 _方法_ 是公有的，而默认情况下其他一切都是私有的。比如，可以定义一个包含一个 i32 类型 vector 的结构体 AveragedCollection。结构体也可以有一个字段，该字段保存了 vector 中所有值的平均值。这样，希望知道结构体中的 vector 的平均值的人可以随时获取它，而无需自己计算。换句话说，AveragedCollection 会缓存平均值结果：

#+BEGIN_SRC rust 
  pub struct AveragedCollection {
      list: Vec<i32>,
      average: f64,
  }
#+END_SRC


注意，结构体自身被标记为 pub，这样其他代码就可以使用这个结构体，但是在 _结构体内部的字段_ 仍然是 *私有* 的。这是非常重要的，因为希望保证变量被增加到列表或者被从列表删除时，也会同时更新平均值。可以通过在结构体上实现 add、remove 和 average 方法来做到这一点：

#+BEGIN_SRC rust 
  impl AveragedCollection {
      pub fn add(&mut self, value: i32) {
	  self.list.push(value);
	  self.update_average();
      }

      pub fn remove(&mut self) -> Option<i32> {
	  let result = self.list.pop();
	  match result {
	      Some(value) => {
		  self.update_average();
		  Some(value)
	      },
	      None => None,
	  }
      }

      pub fn average(&self) -> f64 {
	  self.average
      }

      fn update_average(&mut self) {
	  let total: i32 = self.list.iter().sum();
	  self.average = total as f64 / self.list.len() as f64;
      }
  }
#+END_SRC

+ *公有* 方法 _add_ 、 _remove_ 和 _average_ 是修改 AveragedCollection 实例的唯一方式。当使用 add 方法把一个元素加入到 list 或者使用 remove 方法来删除时，这些方法的实现同时会调用私有的 update_average 方法来更新 average 字段
+ _list_ 和 _average_ 是 *私有* 的，所以没有其他方式来使得外部的代码直接向 list 增加或者删除元素，否则 list 改变时可能会导致 average 字段不同步。average 方法返回 average 字段的值，这使得外部的代码只能读取 average 而不能修改它

#+BEGIN_EXAMPLE
  因为已经封装好了 AveragedCollection 的实现细节，将来可以轻松改变类似数据结构这些方面的内容

  例如，可以使用 HashSet<i32> 代替 Vec<i32> 作为 list 字段的类型。只要 add、remove 和 average 公有函数的签名保持不变，使用 AveragedCollection 的代码就无需改变

  相反如果使得 list 为公有，就未必都会如此了： HashSet<i32> 和 Vec<i32> 使用不同的方法增加或移除项，所以如果要想直接修改 list 的话，外部的代码可能不得不做出修改
#+END_EXAMPLE
如果封装是一个语言被认为是面向对象语言所必要的方面的话，那么 Rust 满足这个要求。在代码中不同的部分使用 pub 与否可以封装其实现细节
** 继承，作为类型系统与代码共享
#+BEGIN_EXAMPLE
  继承是一个很多编程语言都提供的机制，一个对象可以定义为继承另一个对象的定义，这使其可以获得父对象的数据和行为，而无需重新定义
#+END_EXAMPLE

如果一个语言必须有继承才能被称为面向对象语言的话，那么 Rust 就不是面向对象的。无法定义一个结构体继承父结构体的成员和方法

#+BEGIN_EXAMPLE
  近来继承作为一种语言设计的解决方案在很多语言中失宠了，因为其时常带有共享多于所需的代码的风险

  子类不应总是共享其父类的所有特征，但是继承却始终如此。如此会使程序设计更为不灵活，并引入无意义的子类方法调用，或由于方法实际并不适用于子类而造成错误的可能性

  某些语言还只允许子类继承一个父类，进一步限制了程序设计的灵活性
#+END_EXAMPLE
使用继承有两个主要的原因：
1. 为了重用代码：一旦为一个类型实现了特定行为，继承可以对一个不同的类型重用这个实现。相反 Rust 代码可以使用默认 _trait_ 方法实现来进行共享
2. 表现为子类型可以用于父类型被使用的地方。这也被称为多态，这意味着如果多种对象共享特定的属性，则可以相互替代使用。很多人将多态描述为继承的同义词。不过它是一个有关可以用于多种类型的代码的更广泛的概念。对于继承来说，这些类型通常是子类。Rust 则通过泛型来对不同的可能类型进行抽象，并通过 _trait bounds_ 对这些类型所必须提供的内容施加约束
* 为使用不同类型的值而设计的 trait 对象

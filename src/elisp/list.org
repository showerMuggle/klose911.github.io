#+TITLE: 列表
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: data_type.html   
#+HTML_LINK_HOME: elisp.html
#+OPTIONS: num:nil timestamp:nil ^:nil

* cons cell 

如果从概念上来说，cons cell 其实非常简单的，就是两个有顺序的元素。第一个叫 CAR，第二个就 CDR
#+BEGIN_EXAMPLE
  CAR 和 CDR 名字来自于 Lisp。它最初在IBM 704机器上的实现。在这种机器有一种取址模式，使人可以访问一个存储地址中的“地址（address）”部分和“减量（decrement）”部分

  CAR 指令用于取出地址部分，表示(Contents of Address part of Register)，CDR 指令用于取出地址的减量部分(Contents of the Decrement part of Register)
#+END_EXAMPLE
cons cell 也就是 construction of cells
+ _car_ 函数：取得 cons cell 的 CAR 部分
+ _cdr_ 取得cons cell 的 CDR 部分

#+BEGIN_EXAMPLE
  cons cell 如此简单，但是它却能衍生出许多高级的数据结构，比如链表，树，关联表等等
#+END_EXAMPLE

cons cell 的读入语法是用 _._ 分开两个部分，比如：

#+BEGIN_SRC lisp 
  '(1 . 2)                                ; => (1 . 2)
  '(?a . 1)                               ; => (97 . 1)
  '(1 . "a")                              ; => (1 . "a")
  '(1 . nil)                              ; => (1)
  '(nil . nil)                            ; => (nil)
#+END_SRC

#+BEGIN_EXAMPLE
  注意到前面的表达式中都有一个 ' 号，这是什么意思呢？其实理解了 eval-last-sexp 的作用就能明白了

  eval-last-sexp 其实包含了两个步骤，一是读入前一个 S-表达式，二是对读入的 S-表达式求值

  如果读入的 S-表达式是一个 cons cell 的话，求值时会把这个 cons cell 的第一个元素作为一个函数来调用。而事实上，前面这些例子的第一个元素都不是一个函数，这样就会产生一个错误 invalid-function

  之所以前面没有遇到这个问题，那是因为前面数字和字符串是一类特殊的 S-表达式，它们求值后和求值前是不变，称为自求值表达式（self-evaluating form）
#+END_EXAMPLE
_'_ 号其实是一个特殊的函数 _quote_ ，它的作用是将它的参数返回而不作求值

#+BEGIN_EXAMPLE
'(1 . 2) 等价于 (quote (1 . 2))
#+END_EXAMPLE

为了证明 cons cell 的读入语法确实就是它的输出形式，可以看下面这个语句：

#+BEGIN_SRC lisp 
  (read "(1 . 2)")                        ; => (1 . 2)
#+END_SRC

* 列表
列表包括了 cons cell。但是列表中有一个特殊的元素： *空表* _nil_ 

#+BEGIN_SRC lisp 
  nil                                     ; => nil
  '()                                     ; => nil
#+END_SRC

空表不是一个 cons cell，因为它没有 CAR 和 CDR 两个部分，事实上空表里没有任何内容。但是为了编程的方便，可以认为 nil 的 CAR 和 CDR 都是 nil：

#+BEGIN_SRC lisp 
  (car nil)                               ; => nil
  (cdr nil)                               ; => nil
#+END_SRC

按列表最后一个 cons cell 的 _CDR 部分_ 的类型分，可以把列表分为三类：
1. 如果它是 nil 的话，这个列表也称为 _真列表_ 
2. 如果既不是 nil 也不是一个 cons cell，则这个列表称为 _点列表_
3. 它指向列表中之前的一个 cons cell，则称为 _环形列表_  

#+BEGIN_SRC lisp 
  '(1 2 3)                                  ; => (1 2 3)
  '(1 2 . 3)                                ; => (1 2 . 3)
  '(1 . #1=(2 3 . #1#))                     ; => (1 2 3 . #1)
#+END_SRC

#+BEGIN_EXAMPLE
  可以看出前两种列表的读入语法和输出形式都是相同的，而环形列表的读入语法是很古怪的，输出形式不能作为环形列表的读入形式
#+END_EXAMPLE

如果把真列表最后一个 cons cell 的 nil 省略不写，也就是 (1 . nil) 简写成 (1)，把 ( obj1 . ( obj2 . list)) 简写成 (obj1 obj2 . list)，那么列表最后可以写成一个用括号括起的元素列表：

#+BEGIN_SRC lisp 
  '(1 . (2 . (3 . nil)))                  ; => (1 2 3)
#+END_SRC

#+BEGIN_EXAMPLE
  尽管这样写是清爽多了，但是，看一个列表时还是在脑子里反映的前面的形式，这样在和复杂的 cons cell 打交道时就不会搞不清楚这个 cons cell 的 CDR 是一个列表呢，还是一个元素或者是嵌套的列表 
#+END_EXAMPLE

* 测试
测试一个对象是否是 cons cell 用 _consp_ ，是否是列表用 _listp_ 

#+BEGIN_SRC lisp 
  (consp '(1 . 2))                        ; => t
  (consp '(1 . (2 . nil)))                ; => t
  (consp nil)                             ; => nil
  (listp '(1 . 2))                        ; => t
  (listp '(1 . (2 . nil)))                ; => t
  (listp nil)                             ; => t
#+END_SRC

#+BEGIN_EXAMPLE
  没有内建的方法测试一个列表是不是一个真列表

  通常如果一个函数需要一个真列表作为参数，都是在运行时发出错误，而不是进行参数检查，因为检查一个列表是真列表的代价比较高
#+END_EXAMPLE

测试一个对象是否是 nil 用 _null_ 函数。只有当对象是空表时，null 才返回空值 

* 构造
生成一个 cons cell 可以用 _cons_ 函数。比如：

#+BEGIN_SRC lisp 
  (cons 1 2)                              ; => (1 . 2)
  (cons 1 '())                            ; => (1)
#+END_SRC

这也是在 _列表_ 前面 *增加* _元素_ 的方法。比如：

#+BEGIN_SRC lisp 
  (setq foo '(a b))                       ; => (a b)
  (cons 'x foo)                           ; => (x a b)
#+END_SRC

#+BEGIN_EXAMPLE
  注意：例子的 foo 值并没有改变，返回的是一个新建的列表
#+END_EXAMPLE

一个宏 _push_ 可以加入元素的同时改变列表的值：

#+BEGIN_SRC lisp 
  (push 'x foo)                           ; => (x a b)
  foo                                     ; => (x a b)
#+END_SRC

生成一个列表的函数是 _list_ 。比如： 

#+BEGIN_SRC lisp 
  (list 1 2 3)                            ; => (1 2 3)
#+END_SRC

#+BEGIN_EXAMPLE
  可能这时有一个疑惑，前面产生一个列表，常用 quote（也就是 ' 符号）这个函数，它和这个 cons 和 list 函数有什么区别呢？
#+END_EXAMPLE
其实区别是很明显的：
+ quote 是把参数直接返回不进行求值
+ list 和 cons 是对参数求值后再生成一个列表或者 cons cell

#+BEGIN_SRC lisp 
  '((+ 1 2) 3)                            ; => ((+ 1 2) 3)
  (list (+ 1 2) 3)                        ; => (3 3)
#+END_SRC

#+BEGIN_EXAMPLE
  前一个生成的列表的 CAR 部分是 (+ 1 2) 这个列表，而后一个是先对 (+ 1 2) 求值得到 3 后再生成列表
#+END_EXAMPLE

前面提到在列表前端增加元素的方法是用 cons，在列表后端增加元素的函数是用 _append_ 。比如：

#+BEGIN_SRC lisp 
  (append '(a b) '(c))                    ; => (a b c)
#+END_SRC

append 的功能可以认为它是把第一个参数最后一个列表的 nil 换成第二个参数
#+BEGIN_SRC lisp 
  比如前面这个例子，第一个参数写成 cons cell 表示方式是(a . (b . nil))，把这个 nil 替换成 (c) 就成了 (a . (b . (c)))
#+END_SRC

对于多个参数的情况也是一样的，依次把下一个参数替换新列表最后一个 nil 就是最后的结果了：

#+BEGIN_SRC lisp 
  (append '(a b) '(c) '(d))               ; => (a b c d)
#+END_SRC

一般来说 append 的参数都要是列表，但是最后一个参数可以不是一个列表，这也不违背前面说的，因为 cons cell 的 CDR 部分本来就可以是任何对象：

#+BEGIN_SRC lisp 
  (append '(a b) 'c)                      ; => (a b . c)
#+END_SRC
这样得到的结果就不再是一个真列表了，如果再进行 append 操作就会产生一个错误

#+BEGIN_EXAMPLE
  如果写过 c 的链表类型，可能就知道如果链表只保留一个指针，那么链表只能在一端增加元素

  elisp 的列表类型也是类似的，用 cons 在列表前增加元素比用 append 要快得多
#+END_EXAMPLE

append 的参数不限于列表，还可以是 _字符串_ 或者 _向量_ 。前面字符串里已经提到可以把一个字符串转换成一个字符列表，同样可能把向量转换成一个列表：

#+BEGIN_SRC lisp 
  (append [a b] "cd" nil)                 ; => (a b 99 100)
#+END_SRC

* 数组

* 堆栈

* 集合

* 关联表

#+TITLE: Deployment
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../../css/main.css" />
#+HTML_LINK_UP: controller.html   
#+HTML_LINK_HOME: controller.html
#+OPTIONS: num:nil timestamp:nil ^:nil

Deployment 为 _Pod_ 和 _ReplicaSet_ 提供了一个 *声明式* 定义方法，用来替代以前的 ReplicationController 来方便的管理应用。典型的应用场景包括：
+ 定义 Deployment 来 *创建* _Pod_ 和 _ReplicaSet_
+ _滚动升级_ 和 _回滚_ 应用
+ _扩容_ 和 _缩容_
+ _暂停_ 和 _继续_ Deployment

比如一个简单的 nginx 应用可以定义为：

#+BEGIN_EXAMPLE
  apiVersion: extensions/v1beta1
  kind: Deployment
  metadata:
    name: nginx-deployment
  spec:
    replicas: 3
    template:
      metadata:
	labels:
	  app: nginx
      spec:
	containers:
	- name: nginx
	  image: nginx:1.7.9
	  ports:
	  - containerPort: 80
#+END_EXAMPLE

扩容：

#+BEGIN_SRC sh 
  kubectl scale deployment nginx-deployment --replicas 10
#+END_SRC

如果集群支持 horizontal pod autoscaling 的话，还可以为 Deployment 设置自动扩展：

#+BEGIN_SRC sh 
  kubectl autoscale deployment nginx-deployment --min=10 --max=15 --cpu-percent=80
#+END_SRC

更新镜像也比较简单：

#+BEGIN_SRC sh 
  kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1
#+END_SRC

回滚：

#+BEGIN_SRC sh 
  kubectl rollout undo deployment/nginx-deployment
#+END_SRC
* Deployment 结构示意图

  #+ATTR_HTML: image :width 70% 
  [[file:../../pic/deployment-cheatsheet.png]]
* 概念
  Deployment 为 Pod 和 Replica Set（下一代 Replication Controller）提供声明式更新

  #+BEGIN_EXAMPLE
    只需要在 Deployment 中描述您想要的目标状态是什么，Deployment controller 就会将 Pod 和 ReplicaSet 的实际状态改变到目标状态
  #+END_EXAMPLE

  可以定义一个全新的 Deployment 来创建 ReplicaSet 或者删除已有的 Deployment 并创建一个新的来替换

  #+BEGIN_EXAMPLE
    注意：不该手动管理由 Deployment 创建的 ReplicaSet，否则就篡越了 Deployment controller 的职责

  #+END_EXAMPLE

  典型的用例如下：
  + 使用 Deployment 来创建 ReplicaSet。ReplicaSet 在后台创建 pod。检查启动状态，看它是成功还是失败
  + 然后，通过更新 Deployment 的 _PodTemplateSpec_ 字段来声明 Pod 的新状态。这会创建一个新的 ReplicaSet，Deployment 会按照控制的速率将 pod 从旧的 ReplicaSet 移动到新的 ReplicaSet 中
  + 如果当前状态不稳定，回滚到之前的 Deployment _revision_ 。每次回滚都会更新 Deployment 的 revision
  + 扩容 Deployment 以满足更高的负载
  + 暂停 Deployment 来应用 PodTemplateSpec 的多个修复，然后恢复上线
  + 根据 Deployment 的状态判断上线是否 hang 住了
  + 清除旧的不必要的 ReplicaSet 
* 创建
  #+BEGIN_EXAMPLE
    下面是一个 Deployment 示例，它创建了一个 ReplicaSet 来启动 3 个 nginx pod
  #+END_EXAMPLE

  下载示例文件并执行命令：

  #+BEGIN_SRC sh 
  $ kubectl create -f https://kubernetes.io/docs/user-guide/nginx-deployment.yaml --record
  deployment "nginx-deployment" created
  #+END_SRC

  #+BEGIN_EXAMPLE
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: nginx-deployment
      labels:
	app: nginx
    spec:
      replicas: 3
      selector:
	matchLabels:
	  app: nginx
      template:
	metadata:
	  labels:
	    app: nginx
	spec:
	  containers:
	  - name: nginx
	    image: nginx:1.7.9
	    ports:
	    - containerPort: 80
  #+END_EXAMPLE

  将 kubectl 的 _--record_ 的 flag 设置为true 可以在 _annotation_ 中 *记录* 当前命令 _创建_ 或者 _升级_ 了该资源

  #+BEGIN_EXAMPLE
    这在未来会很有用，例如，查看在每个 Deployment revision 中执行了哪些命令
  #+END_EXAMPLE

  然后立即执行 get 将获得如下结果：

  #+BEGIN_SRC sh 
  $ kubectl get deployments
  NAME               READY   UP-TO-DATE   AVAILABLE   AGE
  nginx-deployment   3/0     0            0           1s
  #+END_SRC

  输出结果表明：
  + 希望的 repalica 数（根据 deployment 中的 _.spec.replicas_ 配置）是 3 
  + 当前 replica 数（ _.status.replicas_ ）是 0,
  + 最新的 replica 数（ _.status.updatedReplicas_ ）是 0
  + 可用的 replica 数（ _.status.availableReplicas_ ）是 0 

  过几秒后再执行 get 命令，将获得如下输出：
  #+BEGIN_SRC sh 
  $ kubectl get deployments
  NAME               READY   UP-TO-DATE   AVAILABLE   AGE
  nginx-deployment   3/3     3            3           18s
  #+END_SRC

  #+BEGIN_EXAMPLE
    可以看到 Deployment 已经创建了 3 个 replica，所有的 replica 都已经是最新的了（包含最新的 pod template），可用的（根据 Deployment 中的.spec.minReadySeconds声明，处于已就绪状态的 pod 的最少个数）
  #+END_EXAMPLE
  执行kubectl get rs和kubectl get pods会显示 _Replica Set_ 和 _Pod_ 已创建：

  #+BEGIN_SRC sh 
  $ kubectl get rs 
  NAME                          DESIRED   CURRENT   READY   AGE
  nginx-deployment-5d59d67564   3         3         3       5m45s
  #+END_SRC

  注意： ReplicaSet 的名字总是 _<Deployment 的名字>_ - _<pod template 的 hash 值>_ 

  #+BEGIN_SRC sh 
  $ kubectl get pods 
  NAME                                READY   STATUS    RESTARTS   AGE
  nginx-deployment-5d59d67564-7hk6b   2/2     Running   0          6m52s
  nginx-deployment-5d59d67564-h9l2x   2/2     Running   0          6m52s
  nginx-deployment-5d59d67564-tqnh5   2/2     Running   0          6m52s
  #+END_SRC

  #+BEGIN_EXAMPLE
    刚创建的 Replica Set 将保证总是有 3 个 nginx 的 pod 存在
  #+END_EXAMPLE

  注意： 必须在 _Deployment_ 中的 _selector_ 指定 *正确的 pod template label* 
  #+BEGIN_EXAMPLE
    在该示例中是 app = nginx
  #+END_EXAMPLE
  不要跟其他的 controller 的 selector 中指定的 pod template label 搞混了（包括 Deployment、Replica Set、Replication Controller 等）
  #+BEGIN_EXAMPLE
    Kubernetes 本身并不会阻止任意指定 pod template label，但是如果真的这么做了，这些 controller 之间会相互打架，并可能导致不正确的行为
  #+END_EXAMPLE
** Pod-template-hash label
   注意示例中的 pod label 里的 pod-template-hash label：
   + 当 Deployment 创建或者接管 ReplicaSet 时，Deployment controller 会自动为 Pod 添加 pod-template-hash label
   #+BEGIN_EXAMPLE
     这样做的目的是防止 Deployment 的子 ReplicaSet 的 pod 名字重复
   #+END_EXAMPLE
   + 通过将 ReplicaSet 的 _PodTemplate_ 进行 *哈希散列* ，使用生成的哈希值作为 label 的值，并添加到 _ReplicaSet selector_ 里、 _pod template label_ 和 _ReplicaSet 管理中的 Pod 上_ 
   #+BEGIN_EXAMPLE
     注意：这个 label 不是用户指定的！
   #+END_EXAMPLE
* 更新
  #+BEGIN_EXAMPLE
    注意：Deployment 的 rollout 当且仅当 Deployment 的 pod template（例如 .spec.template）中的 label 更新或者镜像更改时被触发

    其他更新，例如扩容 Deployment 不会触发 rollout
  #+END_EXAMPLE

  假如现在想要让 nginx pod 使用 nginx:1.16.1 的镜像来代替原来的 nginx:1.14.2 的镜像 
  #+BEGIN_SRC sh 
  $ kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
  deployment "nginx-deployment" image updated
  #+END_SRC

  可以使用edit命令来编辑 Deployment，修改.spec.template.spec.containers [0].image

  #+BEGIN_SRC sh 
  $ kubectl edit deployment/nginx-deployment
  deployment "nginx-deployment" edited
  #+END_SRC

  查看 rollout 的状态，只要执行：

  #+BEGIN_SRC sh 
  $ kubectl rollout status deployment/nginx-deployment 
  Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
  deployment "nginx-deployment" successfully rolled out
  #+END_SRC

  Rollout 成功后，getDeployment：

  #+BEGIN_SRC sh 
  $ kubectl get deployments
  NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
  nginx-deployment   3         3         3            3           36s
  #+END_SRC

  #+BEGIN_EXAMPLE
    UP-TO-DATE 的 replica 的数目已经达到了配置中要求的数目

    CURRENT 的 replica 数表示 Deployment 管理的 replica 数量

    AVAILABLE 的 replica 数是当前可用的 replica 数量
  #+END_EXAMPLE

  通过执行 _kubectl get rs_ 可以看到 Deployment 更新了 Pod，通过创建一个新的 ReplicaSet 并扩容了 3 个 replica，同时将原来的 ReplicaSet 缩容到了 0 个 replica

  #+BEGIN_SRC sh 
  $ kubectl get rs 
  NAME                          DESIRED   CURRENT   READY   AGE
  nginx-deployment-559d658b74   3         3         3       2m43s
  nginx-deployment-5d59d67564   0         0         0       3m49s
  #+END_SRC

  执行get pods只会看到当前的新的 pod：

  #+BEGIN_SRC sh 
  $ kubectl get pods 
  NAME                                READY   STATUS    RESTARTS   AGE
  nginx-deployment-559d658b74-f7r7t   2/2     Running   0          3m30s
  nginx-deployment-559d658b74-kvdql   2/2     Running   0          3m26s
  nginx-deployment-559d658b74-swzqk   2/2     Running   0          3m34s
  #+END_SRC

  + Deployment保证在升级时只有一定数量的 Pod 是 down 的。默认的，它会确保至少有比期望的 Pod 数量少一个是 up 状态（最多一个不可用）
  + Deployment 同时也可以确保只创建出超过期望数量的一定数量的 Pod。默认的，它会确保最多比期望的 Pod 数量多一个的 Pod 是 up 的（最多 1 个 surge ） 

  #+BEGIN_EXAMPLE
    例如，如果看下上面的 Deployment，会发现，开始创建一个新的 Pod，然后删除一些旧的 Pod 再创建一个新的，当新的 Pod 创建出来之前不会杀掉旧的 Pod

    这样能够确保可用的 Pod 数量至少有 2 个，Pod 的总数最多 4 个
  #+END_EXAMPLE

  #+BEGIN_SRC sh 
  $ kubectl describe deployments
  Name:           nginx-deployment
  Namespace:      default
  CreationTimestamp:  Tue, 15 Mar 2016 12:01:06 -0700
  Labels:         app=nginx
  Selector:       app=nginx
  Replicas:       3 updated | 3 total | 3 available | 0 unavailable
  StrategyType:       RollingUpdate
  MinReadySeconds:    0
  RollingUpdateStrategy:  1 max unavailable, 1 max surge
  OldReplicaSets:     <none>
  NewReplicaSet:      nginx-deployment-1564180365 (3/3 replicas created)
  Events:
    FirstSeen LastSeen    Count   From                     SubobjectPath   Type        Reason              Message
    --------- --------    -----   ----                     -------------   --------    ------              -------
    36s       36s         1       {deployment-controller}                 Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-2035384211 to 3
    23s       23s         1       {deployment-controller}                 Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 1
    23s       23s         1       {deployment-controller}                 Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 2
    23s       23s         1       {deployment-controller}                 Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 2
    21s       21s         1       {deployment-controller}                 Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 0
    21s       21s         1       {deployment-controller}                 Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 3
  #+END_SRC

  1. 刚开始创建这个 Deployment 的时候，创建了一个 ReplicaSet（nginx-deployment-2035384211），并直接扩容到了 3 个 replica
  2. 当更新这个 Deployment 的时候，它会创建一个新的 ReplicaSet（nginx-deployment-1564180365），将它扩容到 1 个 replica，然后缩容原先的 ReplicaSet 到 2 个 replica，此时满足至少 2 个 Pod 是可用状态，同一时刻最多有 4 个 Pod 处于创建的状态
  3. 接着继续使用相同的 rolling update 策略扩容新的 ReplicaSet 和缩容旧的 ReplicaSet
  4. 最终，将会在新的 ReplicaSet 中有 3 个可用的 replica，旧的 ReplicaSet 的 replica 数目变成 0

  #+BEGIN_EXAMPLE
    在未来的 Kuberentes 版本中，将从 1-1 变成 25%-25%
  #+END_EXAMPLE
** Rollover 
   #+BEGIN_EXAMPLE
     每当 Deployment controller 观测到有新的 deployment 被创建时，如果没有已存在的 ReplicaSet 来创建期望个数的 Pod 的话，就会创建出一个新的 ReplicaSet 来做这件事

     已存在的 ReplicaSet 控制 label 与 .spec.selector 匹配但是 template 跟 .spec.template 不匹配的 Pod 缩容

     最终，新的 ReplicaSet 将会扩容出 .spec.replicas 指定数目的 Pod，旧的 ReplicaSet 会缩容到 0
   #+END_EXAMPLE

   如果更新了一个的已存在并正在进行中的 Deployment，每次更新 Deployment 都会创建一个新的 ReplicaSet 并扩容它，同时 *回滚* 之前扩容的 ReplicaSet（将它添加到旧的 ReplicaSet 列表中，开始缩容）

   #+BEGIN_EXAMPLE
     例如，假如创建了一个有 5 个 niginx:1.7.9 replica 的 Deployment，但是当还只有 3 个 nginx:1.7.9 的 replica 创建出来的时候就开始更新含有 5 个 nginx:1.9.1 replica 的 Deployment

     在这种情况下，Deployment 会立即杀掉已创建的 3 个 nginx:1.7.9 的 Pod，并开始创建 nginx:1.9.1 的 Pod

     它不会等到所有的 5 个 nginx:1.7.9 的 Pod 都创建完成后才开始改变航道
   #+END_EXAMPLE
** Label Selector 更新

   #+BEGIN_EXAMPLE
     通常不鼓励更新 label selector，建议事先规划好您的 selector
   #+END_EXAMPLE
   任何情况下，只要想要执行 label selector 的更新，请一定要谨慎并确认已经预料到所有可能因此导致的后果：
   + 增添 selector 需要同时在 Deployment 的 spec 中更新新的 label，否则将返回校验错误
     #+BEGIN_EXAMPLE
       此更改是不可覆盖的，这意味着新的 selector 不会选择使用旧 selector 创建的 ReplicaSet 和 Pod，从而导致所有旧版本的 ReplicaSet 都被丢弃，并创建新的 ReplicaSet
     #+END_EXAMPLE
   + 更新 selector，即更改 selector key 的当前值，将导致跟增添 selector 同样的后果
   + 删除 selector，即删除 Deployment selector 中的已有的 key，不需要对 Pod template label 做任何更改，现有的 ReplicaSet 也不会成为孤儿
     #+BEGIN_EXAMPLE
       但是请注意，删除的 label 仍然存在于现有的 Pod 和 ReplicaSet 中
     #+END_EXAMPLE
* 回退


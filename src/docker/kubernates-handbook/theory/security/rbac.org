#+TITLE: 基于角色的访问控制
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../../css/main.css" />
#+HTML_LINK_UP: service_account.html
#+HTML_LINK_HOME: security.html
#+OPTIONS: num:nil timestamp:nil ^:nil

基于角色的访问控制（ _Role-Based Access Control_ ）使用 _rbac.authorization.k8s.io_ API Group 实现 *授权* 决策，允许管理员通过 Kubernetes API 动态配置策略

#+BEGIN_EXAMPLE
  要启用 RBAC，请使用 --authorization-mode=RBAC 启动 API Server
#+END_EXAMPLE
* API 

  接下来将介绍 RBAC API 所定义的四种顶级类型

  #+BEGIN_EXAMPLE
    用户可以像使用其他 Kubernetes API 资源一样 （例如通过 kubectl、API 调用等）与这些资源进行交互

    例如，命令 kubectl create -f (resource).yml 可以被用于以下所有的例子
  #+END_EXAMPLE
** Role 与 ClusterRole
   在 RBAC API 中，一个 _角色_ 包含了一套表示 _一组权限_ 的规则：
   + 权限以纯粹的 *累加* 形式累积（没有” 否定” 的规则）
     + 角色可以由 _namespace_ 内的 *Role* 对象定义
     + 整个 _Kubernetes 集群_ 范围内有效的角色则通过 *ClusterRole* 对象实现 

   一个 Role 对象只能用于授予对某一单一命名空间中资源的访问权限

   #+BEGIN_SRC yaml 
  kind: Role
  metadata:
    namespace: default
    name: pod-reader
  rules:
  - apiGroups: [""] # 空字符串"" 表明使用 core API group
    resources: ["pods"]
    verbs: ["get", "watch", "list"]
   #+END_SRC

   #+BEGIN_EXAMPLE
     以上示例描述了 _default_ 命名空间中的一个 Role 对象的定义，用于授予对 pod 的读访问权限
   #+END_EXAMPLE

   ClusterRole 对象可以授予与 Role 对象相同的权限，但由于它们属于集群范围对象， 用它们授予对以下几种资源的访问权限：
   + 集群范围资源
     #+BEGIN_EXAMPLE
       例如节点，即 node
     #+END_EXAMPLE
   + 非资源类型 endpoint
     #+BEGIN_EXAMPLE
       例如”/healthz”
     #+END_EXAMPLE
   + 跨所有命名空间的命名空间范围资源
     #+BEGIN_EXAMPLE
       例如 pod，需要运行命令 kubectl get pods --all-namespaces 来查询集群中所有的 pod
     #+END_EXAMPLE

   #+BEGIN_SRC yaml
  kind: ClusterRole
  apiVersion: rbac.authorization.k8s.io/v1
  metadata:
    # 鉴于 ClusterRole 是集群范围对象，所以这里不需要定义 "namespace" 字段
    name: secret-reader
  rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "watch", "list"]
   #+END_SRC

   #+BEGIN_EXAMPLE
     示例中的 ClusterRole 定义可用于授予用户对某一特定命名空间，或者所有命名空间中的 secret（取决于其 绑定 方式）的读访问权限
   #+END_EXAMPLE
** RoleBinding 与 ClusterRoleBinding
   角色绑定将一个角色中定义的各种权限授予一个或者一组用户：
   + 角色绑定包含了一组相关主体：
     + 用户 User
     + 用户组 Group
     + 服务账户 Service Account
     + 对被授予角色的引用
   + 在命名空间中可以通过 RoleBinding 对象授予权限
   + 集群范围的权限授予则通过 ClusterRoleBinding 对象完成 

   RoleBinding 可以引用在同一命名空间内定义的 Role 对象
   #+BEGIN_SRC yaml 
  kind: RoleBinding
  apiVersion: rbac.authorization.k8s.io/v1
  metadata:
    name: read-pods
    namespace: default
  subjects:
  - kind: User
    name: jane
    apiGroup: rbac.authorization.k8s.io
  roleRef:
    kind: Role
    name: pod-reader
    apiGroup: rbac.authorization.k8s.io
   #+END_SRC

   #+BEGIN_EXAMPLE
     示例中定义的 RoleBinding 对象在 ”default” 命名空间中将 ”pod-reader” 角色授予用户”jane”

     这一授权将允许用户”jane” 从”default” 命名空间中读取 pod
   #+END_EXAMPLE

   RoleBinding 对象也可以引用一个 ClusterRole 对象

   #+BEGIN_EXAMPLE
     这一点允许管理员在整个集群范围内首先定义一组通用的角色，然后再在不同的命名空间中复用这些角色
   #+END_EXAMPLE

   #+BEGIN_SRC yaml 
  # 以下角色绑定允许用户 "dave" 读取 "development" 命名空间中的 secret。
  kind: RoleBinding
  apiVersion: rbac.authorization.k8s.io/v1
  metadata:
    name: read-secrets
    namespace: development # 这里表明仅授权读取 "development" 命名空间中的资源。
  subjects:
  - kind: User
    name: dave
    apiGroup: rbac.authorization.k8s.io
  roleRef:
    kind: ClusterRole
    name: secret-reader
    apiGroup: rbac.authorization.k8s.io
   #+END_SRC

   #+BEGIN_EXAMPLE
     尽管示例中的 RoleBinding 引用的是一个 ClusterRole 对象，但是用户”dave”（即角色绑定主体）还是只能读取”development” 命名空间中的 secret（即 RoleBinding 所在的命名空间）
   #+END_EXAMPLE

   也可以使用ClusterRoleBinding在集群级别和所有命名空间中授予权限

   #+BEGIN_SRC yaml 
  kind: ClusterRoleBinding
  apiVersion: rbac.authorization.k8s.io/v1
  metadata:
    name: read-secrets-global
  subjects:
  - kind: Group
    name: manager
    apiGroup: rbac.authorization.k8s.io
  roleRef:
    kind: ClusterRole
    name: secret-reader
    apiGroup: rbac.authorization.k8s.io
   #+END_SRC

   #+BEGIN_EXAMPLE
     示例中所定义的ClusterRoleBinding允许在用户组”manager” 中的任何用户都可以读取集群中任何命名空间中的 secret
   #+END_EXAMPLE
** 对资源的引用
   大多数资源由代表其 _名字的字符串_ 表示
   #+BEGIN_EXAMPLE
     例如”pods”，就像它们出现在相关 API endpoint 的 URL 中一样
   #+END_EXAMPLE

   然而，有一些 Kubernetes API 还 包含了 _子资源_ 

   #+BEGIN_EXAMPLE
     比如 pod 的 logs，在 Kubernetes 中 pod logs endpoint 的 URL 格式为：

     GET /api/v1/namespaces/{namespace}/pods/{name}/log
   #+END_EXAMPLE

   在这种情况下，”pods” 是 _命名空间资源_ ，而 ”log” 是 pods 的子资源。为了在 RBAC 角色中表示出这一点，需要使用 _斜线_ 来划分资源 与子资源。如果需要角色绑定主体读取 pods 以及 pod log，需要定义以下角色：

   #+BEGIN_SRC yaml 
  kind: Role
  apiVersion: rbac.authorization.k8s.io/v1beta1
  metadata:
    namespace: default
    name: pod-and-pod-logs-reader
  rules:
  - apiGroups: [""]
    resources: ["pods", "pods/log"]
    verbs: ["get", "list"]
   #+END_SRC

   通过 _resourceNames_ 列表，角色可以针对不同种类的请求根据资源名引用资源实例。当指定了resourceNames列表时，不同 _动作_ 种类的请求的权限将被 *限定* 到资源列表中所包含的资源实例上
   #+BEGIN_EXAMPLE
     如使用”get”、”delete”、”update” 以及”patch” 等动词的请求
   #+END_EXAMPLE

   #+BEGIN_SRC yaml 
  kind: Role
  apiVersion: rbac.authorization.k8s.io/v1
  metadata:
    namespace: default
    name: configmap-updater
  rules:
  - apiGroups: [""]
    resources: ["configmap"]
    resourceNames: ["my-configmap"]
    verbs: ["update", "get"]
   #+END_SRC

   #+BEGIN_EXAMPLE
     如果需要限定一个角色绑定主体只能”get” 或者”update” 一个 configmap 时，可以定义上面这个角色
   #+END_EXAMPLE

   注意：如果设置了 _resourceNames_ ，则请求所使用的动词 *不能* 是 _list_ 、 _watch_ 、 _create_ 或者 _deletecollection_ 

   #+BEGIN_EXAMPLE
     由于资源名不会出现在 create、list、watch 和 deletecollection 等 API 请求的 URL 中，所以这些请求动词不会被设置了 resourceNames 的规则所允许，因为规则中的resourceNames 部分不会匹配这些请求
   #+END_EXAMPLE
** 例子
*** 角色定义
    允许读取 core API Group 中定义的资源”pods”：

    #+BEGIN_SRC yaml 
  rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "watch"]
    #+END_SRC

    允许读写在”extensions” 和”apps” API Group 中定义的”deployments”：

    #+BEGIN_SRC yaml 
  rules:
  - apiGroups: ["extensions", "apps"]
    resources: ["deployments"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
    #+END_SRC

    允许读取一个名为”my-config” 的ConfigMap实例（需要将其通过RoleBinding绑定从而限制针对某一个命名空间中定义的一个ConfigMap实例的访问）：
    #+BEGIN_SRC yaml 
  rules:
  - apiGroups: [""]
    resources: ["configmaps"]
    resourceNames: ["my-config"]
    verbs: ["get"]
    #+END_SRC

    允许读取 core API Group 中的”nodes” 资源（由于Node是集群级别资源，所以此ClusterRole定义需要与一个ClusterRoleBinding绑定才能有效）：
    #+BEGIN_SRC yaml 
  rules:
  - apiGroups: [""]
    resources: ["nodes"]
    verbs: ["get", "list", "watch"]
    #+END_SRC

    允许对非资源 endpoint “/healthz” 及其所有子路径的”GET” 和”POST” 请求（此ClusterRole定义需要与一个ClusterRoleBinding绑定才能有效）：
    #+BEGIN_SRC yaml 
  rules:
  - nonResourceURLs: ["/healthz", "/healthz/*"] # 在非资源 URL 中，'*' 代表后缀通配符
    verbs: ["get", "post"]
    #+END_SRC

*** 角色绑定
    角色绑定主体 _Subject_ 可以是用户组 _Group_、用户 _User_ 或者服务账户 _Service Accounts_ 
    + 用户：字符串表示
      #+BEGIN_EXAMPLE
	可以是纯粹的用户名，例如”alice”、电子邮件风格的名字，如 “bob@example.com” 或者是用字符串表示的数字 id

	由 Kubernetes 管理员配置 认证模块 以产生所需格式的用户名，对于用户名，RBAC 授权系统不要求任何特定的格式

	然而，前缀 system: 是 为 Kubernetes 系统使用而保留的，所以管理员应该确保用户名不会意外地包含这个前缀
      #+END_EXAMPLE
    + 用户组：信息由授权模块提供
      #+BEGIN_EXAMPLE
	用户组与用户一样由字符串表示。Kubernetes 对用户组 字符串没有格式要求，但前缀 system: 同样是被系统保留的
      #+END_EXAMPLE
    + 服务账户
      #+BEGIN_EXAMPLE
	拥有包含 system:serviceaccount: 前缀的用户名，并属于拥有 system:serviceaccounts: 前缀的用户组 
      #+END_EXAMPLE

    一个名为”alice@example.com” 的用户：

    #+BEGIN_SRC yaml 
  subjects:
  - kind: User
    name: "alice@example.com"
    apiGroup: rbac.authorization.k8s.io
    #+END_SRC

    一个名为”frontend-admins” 的用户组：

    #+BEGIN_SRC yaml 
  subjects:
  - kind: Group
    name: "frontend-admins"
    apiGroup: rbac.authorization.k8s.io
    #+END_SRC

    kube-system 命名空间中的默认服务账户：

    #+BEGIN_SRC yaml 
  subjects:
  - kind: ServiceAccount
    name: default
    namespace: kube-system
    #+END_SRC

    名为”qa” 命名空间中的所有服务账户：

    #+BEGIN_SRC yaml 
  subjects:
  - kind: Group
    name: system:serviceaccounts:qa
    apiGroup: rbac.authorization.k8s.io
  ​```在集群中的所有服务账户：

  ​```yaml
  subjects:
  - kind: Group
    name: system:serviceaccounts
    apiGroup: rbac.authorization.k8s.io
    #+END_SRC

    所有认证过的用户：
    #+BEGIN_SRC yaml 
  subjects:
  - kind: Group
    name: system:authenticated
    apiGroup: rbac.authorization.k8s.io
  ​```所有未认证的用户（version 1.5+）：

  ​```yaml
  subjects:
  - kind: Group
    name: system:unauthenticated
    apiGroup: rbac.authorization.k8s.io
    #+END_SRC

    所有用户：
    #+BEGIN_SRC yaml 
  subjects:
  - kind: Group
    name: system:authenticated
    apiGroup: rbac.authorization.k8s.io
  - kind: Group
    name: system:unauthenticated
    apiGroup: rbac.authorization.k8s.io
    #+END_SRC

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>错误处理</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="collection.html"> UP </a>
 |
 <a accesskey="H" href="rust.html"> HOME </a>
</div><div id="content">
<h1 class="title">错误处理</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org77878c7">panic! 与不可恢复的错误</a>
<ul>
<li><a href="#org6a23a35">对应 panic 时的栈展开或终止</a></li>
<li><a href="#org9add5f8">panic! 宏</a></li>
<li><a href="#orge123f8f">使用 panic! 的 backtrace</a></li>
</ul>
</li>
<li><a href="#org73661a8">Result 与可恢复的错误</a>
<ul>
<li><a href="#orge25ef74">匹配不同的错误</a></li>
<li><a href="#orgd15e016">失败时 panic 的简写：unwrap 和 expect</a></li>
<li><a href="#org8c92845">传播错误</a>
<ul>
<li><a href="#org5b4fe20">传播错误的简写：? 运算符</a></li>
<li><a href="#org07c0752">? 运算符只可被用于返回 Result 的函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org03a4966">panic! 还是不 panic!</a></li>
</ul>
</div>
</div>
<pre class="example">
Rust 对可靠性的执着也延伸到了错误处理

错误对于软件来说是不可避免的，所以 Rust 有很多特性来处理出现错误的情况

在很多情况下，Rust 要求你承认出错的可能性，并在编译代码之前就采取行动

这些要求使得程序更为健壮，它们确保了你会在将代码部署到生产环境之前就发现错误并正确地处理它们！
</pre>

<p>
Rust 将错误组合成两个主要类别：
</p>
<ul class="org-ul">
<li>可恢复错误：通常代表向 <span class="underline">用户报告</span> 错误和 <span class="underline">重试操作</span> 是合理的情况，比如未找到文件</li>
<li>不可恢复错误：不可恢复错误通常是 <span class="underline">bug</span> 的同义词，比如尝试访问超过数组结尾的位置</li>
</ul>

<pre class="example">
大部分语言并不区分这两类错误，并采用类似异常这样方式统一处理他们

Rust 并没有异常。相反，对于可恢复错误有 Result&lt;T, E&gt; 值，以及 panic!，它在遇到不可恢复错误时停止程序执行

这一章会首先介绍 panic! 调用，接着会讲到如何返回 Result&lt;T, E&gt;，还将探讨决定是尝试从错误中恢复还是停止执行时的注意事项
</pre>
<div id="outline-container-org77878c7" class="outline-2">
<h2 id="org77878c7">panic! 与不可恢复的错误</h2>
<div class="outline-text-2" id="text-org77878c7">
<p>
突然有一天，代码出问题了，而你对此束手无策。对于这种情况，Rust 有 <span class="underline">panic!宏</span> 。当执行这个宏时：
</p>
<ol class="org-ol">
<li>程序会打印出一个错误信息</li>
<li>展开并清理栈数据</li>
<li>退出</li>
</ol>

<pre class="example">
    出现这种情况的场景通常是检测到一些类型的 bug，而且程序员并不清楚该如何处理它
</pre>
</div>
<div id="outline-container-org6a23a35" class="outline-3">
<h3 id="org6a23a35">对应 panic 时的栈展开或终止</h3>
<div class="outline-text-3" id="text-org6a23a35">
<p>
当出现 panic 时，程序默认会开始  <span class="underline">展开</span> ，这意味着 Rust 会 <span class="underline">回溯栈</span> 并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作
</p>

<p>
另一种选择是直接 <span class="underline">终止</span> ，这会不清理数据就退出程序。那么程序所使用的内存需要由操作系统来清理
</p>
<pre class="example">
     如果需要项目的最终二进制文件越小越好，panic 时通过在 Cargo.toml 的 [profile] 部分增加 panic = 'abort'，可以由展开切换为终止
</pre>
<p>
例如，如果想要在release模式中 panic 时直接终止：
</p>

<div class="org-src-container">
<pre class="src src-toml">[<span style="color: #98fb98;">profile.release</span>]
<span style="color: #eedd82;">panic</span> = <span style="color: #ffa07a;">'abort'</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org9add5f8" class="outline-3">
<h3 id="org9add5f8">panic! 宏</h3>
<div class="outline-text-3" id="text-org9add5f8">
<p>
在一个简单的程序中调用 panic!：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #7fffd4;">panic!</span>(<span style="color: #ffa07a;">"crash and burn"</span>);
}
</pre>
</div>
<p>
运行程序将会出现类似这样的输出：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ cargo run
   Compiling panic v0.1.0 (/mnt/c/Users/I514692/AppData/Roaming/Documents/programming/html/klose911.github.io/src/rust/src/error_handle/panic)
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00ffff;">in</span> 2.39s
     Running <span style="color: #fa8072;">`target/debug/panic`</span>
thread <span style="color: #ffa07a;">'main'</span> panicked at <span style="color: #ffa07a;">'crash and burn'</span>, src/main.rs:2:5
note: run with <span style="color: #fa8072;">`RUST_BACKTRACE=1`</span> environment variable to display a backtrace.
</pre>
</div>

<p>
这里包含 panic! 调用造成的错误信息：
</p>
<ul class="org-ul">
<li>显示了 panic 提供的信息</li>
<li>指明了源码中 panic 出现的位置：src/main.rs:2:5
<ul class="org-ul">
<li>src/main.rs 文件的第二行第五个字符</li>
</ul></li>
</ul>

<pre class="example">
     在这个例子中，被指明的那一行是代码的一部分，而且查看这一行的话就会发现 panic! 宏的调用

     在其他情况下，panic! 可能会出现在我们的代码所调用的代码中。错误信息报告的文件名和行号可能指向别人代码中的 panic! 宏调用，而不是我们代码中最终导致 panic! 的那一行

     这时候可以使用 panic! 被调用的函数的 backtrace 来寻找代码中出问题的地方
</pre>
</div>
</div>
<div id="outline-container-orge123f8f" class="outline-3">
<h3 id="orge123f8f">使用 panic! 的 backtrace</h3>
<div class="outline-text-3" id="text-orge123f8f">
<p>
看看另一个因为我们代码中的 bug 引起的别的库中 panic! 的例子，而不是直接的宏调用。下面是一个尝试通过索引访问 vector 中元素的例子：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">v</span> = <span style="color: #7fffd4;">vec!</span>[1, 2, 3];

    v[99];
}
</pre>
</div>

<p>
报错信息如下：
</p>
<div class="org-src-container">
<pre class="src src-sh">thread <span style="color: #ffa07a;">'main'</span> panicked at <span style="color: #ffa07a;">'index out of bounds: the len is 3 but the index is 99'</span>, /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libcore/slice/mod.rs:2796:10
note: run with <span style="color: #fa8072;">`RUST_BACKTRACE=1`</span> environment variable to display a backtrace.
</pre>
</div>

<pre class="example">
     这指向了一个不是自己编写的文件，libcore/slice/mod.rs。其为 Rust 源码中 slice 的实现

     这是当对 vector v 使用 [] 时 libcore/slice/mod.rs 中会执行的代码，也是真正出现 panic! 的地方
</pre>

<p>
接下来的几行提醒我们可以设置 <span class="underline">RUST_BACKTRACE</span>  环境变量来得到一个 backtrace： 这是一个执行到目前位置所有被调用的函数的列表
</p>

<pre class="example">
Rust 的 backtrace 跟其他语言中的一样：

阅读 backtrace 的关键是从头开始读直到发现你编写的文件。这就是问题的发源地

这一行往上是你的代码所调用的代码；往下则是调用你的代码的代码

这些行可能包含核心 Rust 代码，标准库代码或用到的 crate 代码
</pre>
<p>
将 RUST_BACKTRACE 环境变量设置为任何不是 0 的值来获取 backtrace 看看：
</p>

<div class="org-src-container">
<pre class="src src-sh">$ <span style="color: #eedd82;">RUST_BACKTRACE</span>=1 cargo run
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00ffff;">in</span> 0.00s
     Running <span style="color: #fa8072;">`target/debug/panic`</span>
thread <span style="color: #ffa07a;">'main'</span> panicked at <span style="color: #ffa07a;">'index out of bounds: the len is 3 but the index is 99'</span>, libcore/slice/mod.rs:2448:10
stack backtrace:
   0: std::sys::unix::backtrace::tracing::imp::unwind_backtrace
             at libstd/sys/unix/backtrace/tracing/gcc_s.rs:49
   1: std::sys_common::backtrace::print
             at libstd/sys_common/backtrace.rs:71
             at libstd/sys_common/backtrace.rs:59
   2: std::panicking::default_hook::{{closure}}
             at libstd/panicking.rs:211
   3: std::panicking::default_hook
             at libstd/panicking.rs:227
   4: &lt;std::panicking::begin_panic::PanicPayload&lt;A&gt; as core::panic::BoxMeUp&gt;::get
             at libstd/panicking.rs:476
   5: std::panicking::continue_panic_fmt
             at libstd/panicking.rs:390
   6: std::panicking::try::do_call
             at libstd/panicking.rs:325
   7: core::ptr::drop_in_place
             at libcore/panicking.rs:77
   8: core::ptr::drop_in_place
             at libcore/panicking.rs:59
   9: &lt;usize as core::slice::SliceIndex&lt;[T]&gt;&gt;::index
             at libcore/slice/mod.rs:2448
  10: core::slice::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at libcore/slice/mod.rs:2316
  11: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at liballoc/vec.rs:1653
  12: panic::main
             at src/main.rs:4
  13: std::rt::lang_start::{{closure}}
             at libstd/rt.rs:74
  14: std::panicking::try::do_call
             at libstd/rt.rs:59
             at libstd/panicking.rs:310
  15: macho_symbol_search
             at libpanic_unwind/lib.rs:102
  16: std::alloc::default_alloc_error_hook
             at libstd/panicking.rs:289
             at libstd/panic.rs:392
             at libstd/rt.rs:58
  17: std::rt::lang_start
             at libstd/rt.rs:74
  18: panic::main
</pre>
</div>

<p>
这里有大量的输出：
</p>
<ul class="org-ul">
<li>实际看到的输出可能因 <span class="underline">不同的操作系统</span> 和 <span class="underline">Rust 版本</span> 而有所不同</li>
<li>为了获取带有这些信息的 backtrace，必须 <b>启用 debug</b>  标识
<ul class="org-ul">
<li>当 <b>不使用</b>  <span class="underline">&#x2013;release</span> 参数运行 cargo build 或 cargo run 时 debug 标识会默认启用，就像这里一样</li>
</ul></li>
</ul>

<pre class="example">
     输出中，backtrace 的 12 行指向了我们项目中造成问题的行：src/main.rs 的第 4 行

     如果你不希望程序 panic，第一个提到我们编写的代码行的位置是你应该开始调查的，以便查明是什么值如何在这个地方引起了 panic

     在示例中，我们故意编写会 panic 的代码来演示如何使用 backtrace，修复这个 panic 的方法就是不要尝试在一个只包含三个项的 vector 中请求索引是 100 的元素

     当将来你的代码出现了 panic，你需要搞清楚在这特定的场景下代码中执行了什么操作和什么值导致了 panic，以及应当如何处理才能避免这个问题
</pre>
</div>
</div>
</div>
<div id="outline-container-org73661a8" class="outline-2">
<h2 id="org73661a8">Result 与可恢复的错误</h2>
<div class="outline-text-2" id="text-org73661a8">
<pre class="example">
    大部分错误并没有严重到需要程序完全停止执行。有时，一个函数会因为一个容易理解并做出反应的原因失败

    例如，如果因为打开一个并不存在的文件而失败，此时可能想要创建这个文件，而不是终止进程
</pre>

<p>
回忆一下 <span class="underline">Result</span> 枚举，它定义有如下两个成员， <span class="underline">Ok</span> 和 <span class="underline">Err</span> ： 
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">enum</span> <span style="color: #98fb98;">Result</span>&lt;<span style="color: #98fb98;">T</span>, <span style="color: #98fb98;">E</span>&gt; {
    <span style="color: #98fb98;">Ok</span>(<span style="color: #98fb98;">T</span>),
    <span style="color: #98fb98;">Err</span>(<span style="color: #98fb98;">E</span>),
}
</pre>
</div>

<p>
<span class="underline">T</span> 和 <span class="underline">E</span> 是泛型类型参数；
</p>
<ul class="org-ul">
<li>T : <span class="underline">成功</span> 时返回的 <span class="underline">Ok</span> 成员中的 <span class="underline">数据的类型</span></li>
<li>E : <span class="underline">失败</span> 时返回的 <span class="underline">Err</span> 成员中的 <span class="underline">错误的类型</span></li>
</ul>

<pre class="example">
    因为 Result 有这些泛型类型参数，可以将 Result 类型和标准库中为其定义的函数用于很多不同的场景，这些情况中需要返回的成功值和失败值可能会各不相同
</pre>

<p>
调用一个返回 Result 的函数，因为它可能会失败：如下所示打开一个文件：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">fs</span>::<span style="color: #98fb98;">File</span>;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">f</span>:<span style="color: #98fb98;">u32</span> = <span style="color: #98fb98;">File</span> ::open(<span style="color: #ffa07a;">"hello.txt"</span>);
}
</pre>
</div>

<p>
试着编译下，会有下面的编译报错：
</p>
<div class="org-src-container">
<pre class="src src-sh">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     <span style="color: #b0c4de;">let</span> f: u32 = File ::open(<span style="color: #ffa07a;">"hello.txt"</span>);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
<span style="color: #fa8072;">`std::result::Result`</span>
  |
  = note: expected type <span style="color: #fa8072;">`u32`</span>
             found type <span style="color: #fa8072;">`std::result::Result&lt;std::fs::File, std::io::Error&gt;`</span>
</pre>
</div>

<pre class="example">
这就告诉我们 File ::open 函数的返回值类型是 Result&lt;T, E&gt;

这里泛型参数 T 放入了成功值的类型 std::fs::File，它是一个文件句柄
E 被用在失败值上时 E 的类型是 std::io::Error

</pre>
<p>
这个返回值类型说明 File ::open 调用：
</p>
<ul class="org-ul">
<li>可能会成功并返回一个可以进行读写的文件句柄，变量 f 的值将会是一个包含文件句柄的 Ok 实例</li>
<li>这个函数也可能会失败，f 的值会是一个包含更多关于出现了何种错误信息的 Err 实例。例如：
<ul class="org-ul">
<li>文件可能并不存在</li>
<li>可能没有访问文件的权限</li>
</ul></li>
</ul>

<pre class="example">
File ::open 需要一个方式告诉我们是成功还是失败，并同时提供给我们文件句柄或错误信息

而这些信息正是 Result 枚举可以提供的

</pre>
<p>
根据 File ::open 返回值进行不同处理的逻辑。下面示例展示了一个使用基本工具处理 Result 的例子：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">fs</span>::<span style="color: #98fb98;">File</span>;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">f</span> = <span style="color: #98fb98;">File</span> ::open(<span style="color: #ffa07a;">"hello.txt"</span>);

    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">f</span> = <span style="color: #00ffff;">match</span> f {
        <span style="color: #98fb98;">Ok</span>(file) =&gt; file,
        <span style="color: #98fb98;">Err</span>(error) =&gt; {
            <span style="color: #7fffd4;">panic!</span>(<span style="color: #ffa07a;">"Problem opening the file: {:?}"</span>, error)
        },
    };
}
</pre>
</div>

<pre class="example">
    注意：与 Option 枚举一样，Result 枚举和其成员也被导入到了 prelude 中，所以就不需要在 match 分支中的 Ok 和 Err 之前指定 Result::
</pre>

<ul class="org-ul">
<li>当结果是 Ok 时，返回 Ok 成员中的 file 值，然后将这个文件句柄赋值给变量 f。match 之后，可以利用这个文件句柄来进行读写</li>
<li>match 的另一个分支处理从 File ::open 得到 Err 值的情况。在这种情况下，选择调用 panic! 宏。如果当前目录没有一个叫做 hello.txt 的文件，当运行这段代码时会看到如下来自 panic! 宏的输出：</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">thread <span style="color: #ffa07a;">'main'</span> panicked at <span style="color: #ffa07a;">'Problem opening the file: Error { repr:</span>
<span style="color: #ffa07a;">Os { code: 2, message: "No such file or directory" } }'</span>, src/main.rs:9:12
</pre>
</div>
</div>
<div id="outline-container-orge25ef74" class="outline-3">
<h3 id="orge25ef74">匹配不同的错误</h3>
<div class="outline-text-3" id="text-orge25ef74">
<pre class="example">
     上面的代码不管 File ::open 是因为什么原因失败都会 panic!

     真正希望的是对不同的错误原因采取不同的行为：
     如果 File ::open因为文件不存在而失败，希望创建这个文件并返回新文件的句柄

     如果 File ::open 因为任何其他原因失败，例如没有打开文件的权限，仍然希望像示例那样 panic!
</pre>

<p>
为 match 增加了另一个分支： 
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">fs</span>::<span style="color: #98fb98;">File</span>;
<span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">io</span>::<span style="color: #98fb98;">ErrorKind</span>;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">f</span> = <span style="color: #98fb98;">File</span> ::open(<span style="color: #ffa07a;">"hello.txt"</span>);

    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">f</span> = <span style="color: #00ffff;">match</span> f {
        <span style="color: #98fb98;">Ok</span>(file) =&gt; file,
        <span style="color: #98fb98;">Err</span>(error) =&gt; <span style="color: #00ffff;">match</span> error.kind() {
            <span style="color: #98fb98;">ErrorKind</span>::<span style="color: #98fb98;">NotFound</span> =&gt; <span style="color: #00ffff;">match</span> <span style="color: #98fb98;">File</span> ::create(<span style="color: #ffa07a;">"hello.txt"</span>) {
                <span style="color: #98fb98;">Ok</span>(fc) =&gt; fc,
                <span style="color: #98fb98;">Err</span>(e) =&gt; <span style="color: #7fffd4;">panic!</span>(<span style="color: #ffa07a;">"Problem creating the file: {:?}"</span>, e),
            },
            other_error =&gt; <span style="color: #7fffd4;">panic!</span>(<span style="color: #ffa07a;">"Problem opening the file: {:?}"</span>, other_error),
        },
    };
}
</pre>
</div>


<p>
File ::open 返回的 Err 成员中的值类型 <span class="underline">io::Error</span> ，它是一个标准库中提供的结构体：这个结构体有一个返回 <span class="underline">io::ErrorKind</span> 值的 <span class="underline">kind</span> 方法可供调用：
</p>
<ul class="org-ul">
<li>io::ErrorKind 是一个标准库提供的枚举，它的成员对应 <span class="underline">io</span> 操作可能导致的不同错误类型：
<ul class="org-ul">
<li>感兴趣的成员是 <span class="underline">ErrorKind::NotFound</span> ，它代表尝试 <b>打开的文件并不存在</b></li>
</ul></li>
</ul>

<pre class="example">
     希望在匹配守卫中检查的条件是 error.kind() 的返回值是 ErrorKind的 NotFound 成员

     如果是，则尝试通过 File ::create 创建文件
     然而因为 File ::create 也可能会失败，还需要增加一个内部 match 语句。当文件不能被打开，会打印出一个不同的错误信息

     外部 match 的最后一个分支保持不变，这样对任何除了文件不存在的错误会使程序 panic
</pre>

<p>
然而这里有很多的嵌套的 match 操作符，Result&lt;T, E&gt; 有很多接受 <span class="underline">闭包</span> 的方法，并采用 match 表达式实现。一个更老练的 Rustacean 可能会这么写：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">fs</span>::<span style="color: #98fb98;">File</span>;
<span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">io</span>::<span style="color: #98fb98;">ErrorKind</span>;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">f</span> = <span style="color: #98fb98;">File</span> ::open(<span style="color: #ffa07a;">"hello.txt"</span>).unwrap_or_else(|error| {
        <span style="color: #00ffff;">if</span> error.kind() == <span style="color: #98fb98;">ErrorKind</span>::<span style="color: #98fb98;">NotFound</span> {
            <span style="color: #98fb98;">File</span> ::create(<span style="color: #ffa07a;">"hello.txt"</span>).unwrap_or_else(|error| {
                <span style="color: #7fffd4;">panic!</span>(<span style="color: #ffa07a;">"Problem creating the file: {:?}"</span>, error);
            })
        } <span style="color: #00ffff;">else</span> {
            <span style="color: #7fffd4;">panic!</span>(<span style="color: #ffa07a;">"Problem opening the file: {:?}"</span>, error);
        }
    });
}

</pre>
</div>

<pre class="example">
     虽然这段代码和开始一样的行为，但比大量的 match 表达式且更容易阅读

     在处理错误时，还有很多这类方法可以消除大量嵌套的 match 表达式
</pre>
</div>
</div>

<div id="outline-container-orgd15e016" class="outline-3">
<h3 id="orgd15e016">失败时 panic 的简写：unwrap 和 expect</h3>
<div class="outline-text-3" id="text-orgd15e016">
<pre class="example">
match 能够胜任它的工作，不过它可能有点冗长并且不总是能很好的表明其意图
</pre>

<p>
Result&lt;T, E&gt; 类型定义了很多辅助方法来处理各种情况。其中之一叫做 <span class="underline">unwrap</span> ：
</p>
<ul class="org-ul">
<li>如果 Result 值是成员 Ok，unwrap 会返回 Ok 中的值</li>
<li>如果 Result 是成员 Err，unwrap 会调用 panic!</li>
</ul>

<p>
这里是一个实践 unwrap 的例子：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">fs</span>::<span style="color: #98fb98;">File</span>;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">f</span> = <span style="color: #98fb98;">File</span> ::open(<span style="color: #ffa07a;">"hello.txt"</span>).unwrap();
}
</pre>
</div>

<p>
如果调用这段代码时不存在 hello.txt 文件，将会看到一个 unwrap 调用 panic! 时提供的错误信息：
</p>

<div class="org-src-container">
<pre class="src src-sh">thread <span style="color: #ffa07a;">'main'</span> panicked at <span style="color: #ffa07a;">'called `Result::unwrap()` on an `Err` value: Error {repr: Os { code: 2, message: "No such file or directory" } }'</span>,src/libcore/result.rs:906:4
</pre>
</div>

<p>
另一个类似于 unwrap 的方法 <span class="underline">expect</span> ，它还允许选择 <span class="underline">panic! 的错误信息</span> ： 
</p>
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">fs</span>::<span style="color: #98fb98;">File</span>;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">f</span> = <span style="color: #98fb98;">File</span> ::open(<span style="color: #ffa07a;">"hello.txt"</span>).expect(<span style="color: #ffa07a;">"Failed to open hello.txt"</span>);
}
</pre>
</div>

<p>
expect 与 unwrap 的使用方式一样：返回文件句柄或调用 panic! 宏。expect 用来调用 panic! 的错误信息将会作为参数传递给 expect ，而不像unwrap 那样使用默认的 panic! 信息。它看起来像这样：
</p>

<div class="org-src-container">
<pre class="src src-sh">thread <span style="color: #ffa07a;">'main'</span> panicked at <span style="color: #ffa07a;">'Failed to open hello.txt: Error { repr: Os { code:2, message: "No such file or directory" } }'</span>, src/libcore/result.rs:906:4
</pre>
</div>

<pre class="example">
     这个错误信息以指定的文本开始，Failed to open hello.txt，将会更容易找到代码中的错误信息来自何处

     如果在多处使用 unwrap，则需要花更多的时间来分析到底是哪一个 unwrap 造成了 panic，因为所有的 unwrap 调用都打印相同的信息
</pre>
</div>
</div>

<div id="outline-container-org8c92845" class="outline-3">
<h3 id="org8c92845">传播错误</h3>
<div class="outline-text-3" id="text-org8c92845">
<p>
当编写一个实现会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让 <b>调用者知道这个错误</b> 并 <b>决定该如何处理</b> 。这被称为 <span class="underline">传播</span> 错误
</p>

<pre class="example">
     这样能更好的控制代码调用，因为比起实现代码所拥有的上下文，调用者可能拥有更多信息或逻辑来决定应该如何处理错误
</pre>

<p>
例如，下面的示例展示了一个从文件中读取用户名的函数。如果文件不存在或不能读取，这个函数会将这些错误返回给调用它的代码：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::io;
<span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">io</span>::<span style="color: #98fb98;">Read</span>;
<span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">fs</span>::<span style="color: #98fb98;">File</span>;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">read_username_from_file</span>() -&gt; <span style="color: #98fb98;">Result</span>&lt;<span style="color: #98fb98;">String</span>, <span style="color: #7fffd4;">io</span>::<span style="color: #98fb98;">Error</span>&gt; {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">f</span> = <span style="color: #98fb98;">File</span> ::open(<span style="color: #ffa07a;">"hello.txt"</span>);

    <span style="color: #00ffff;">let</span> <span style="color: #00ffff;">mut</span> <span style="color: #eedd82;">f</span> = <span style="color: #00ffff;">match</span> f {
        <span style="color: #98fb98;">Ok</span>(file) =&gt; file,
        <span style="color: #98fb98;">Err</span>(e) =&gt; <span style="color: #00ffff;">return</span> <span style="color: #98fb98;">Err</span>(e),
    };

    <span style="color: #00ffff;">let</span> <span style="color: #00ffff;">mut</span> <span style="color: #eedd82;">s</span> = <span style="color: #98fb98;">String</span>::new();

    <span style="color: #00ffff;">match</span> f.read_to_string(&amp;<span style="color: #00ffff;">mut</span> s) {
        <span style="color: #98fb98;">Ok</span>(_) =&gt; <span style="color: #98fb98;">Ok</span>(s),
        <span style="color: #98fb98;">Err</span>(e) =&gt; <span style="color: #98fb98;">Err</span>(e),
    }
}
</pre>
</div>

<p>
这个函数的返回值： <span class="underline">Result&lt;String, io::Error&gt;</span> 。这意味着函数返回一个 <span class="underline">Result&lt;T, E&gt;</span> 类型的值，其中：
</p>
<ul class="org-ul">
<li>T 的具体类型是 String：如果这个函数没有出任何错误成功返回，函数的调用者会收到一个包含“从文件中读取到用户名”的 Ok 值</li>
<li>E 的具体类型是 io::Error：如果函数遇到任何错误，函数的调用者会收到一个 Err 值，它储存了一个包含更多这个问题相关信息的 io::Error 实例</li>
</ul>

<pre class="example">
     这里选择 io::Error 作为函数的返回值是因为它正好是函数体中那两个可能会失败的操作的错误返回值：File ::open 函数和 read_to_string 方法
</pre>

<p>
函数体：
</p>
<ol class="org-ol">
<li>以 File ::open 函数开头</li>
<li>使用 match 处理返回值 Result
<ul class="org-ul">
<li>当 Err 时不再调用 panic!，而是提早返回并将 File ::open 返回的错误值作为函数的错误返回值传递给调用者</li>
<li>如果 File ::open 成功了，将文件句柄储存在变量 f 中并继续</li>
</ul></li>
<li>在变量 s 中创建了一个新 String</li>
<li>调用文件句柄 f 的 read_to_string 方法来将文件的内容读取到 s 中，read_to_string 方法也返回一个 Result 因为它也可能会失败：需要另一个 match 来处理这个 Result：
<ul class="org-ul">
<li>如果 read_to_string 成功了，那么这个函数就成功了，并返回文件中的用户名，它现在位于被封装进 Ok 的 s 中</li>
<li>如果read_to_string 失败了，则像之前处理 File ::open 的返回值的 match 那样返回错误值</li>
<li>并不需要显式的调用 return，因为这是函数的最后一个表达式</li>
</ul></li>
</ol>


<pre class="example">
调用这个函数的代码最终会得到一个包含用户名的 Ok 值，或者一个包含 io::Error 的 Err 值

然而我们无从得知调用者会如何处理这些值。如果他们得到了一个 Err 值，他们可能会选择：
1. panic! 并使程序崩溃
2. 使用一个默认的用户名
3. 从文件之外的地方寻找用户名
，，，

我们没有足够的信息知晓调用者具体会如何尝试，所以将所有的成功或失败信息向上传播，让他们选择合适的处理方法
</pre>

<p>
这种传播错误的模式在 Rust 是如此的常见，以至于 Rust 提供了 <span class="underline">?</span> 问号运算符来使其更易于处理
</p>
</div>

<div id="outline-container-org5b4fe20" class="outline-4">
<h4 id="org5b4fe20">传播错误的简写：? 运算符</h4>
<div class="outline-text-4" id="text-org5b4fe20">
<p>
使用了 <span class="underline">?</span> 运算符来实现上面的功能：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::io;
<span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">io</span>::<span style="color: #98fb98;">Read</span>;
<span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">fs</span>::<span style="color: #98fb98;">File</span>;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">read_username_from_file</span>() -&gt; <span style="color: #98fb98;">Result</span>&lt;<span style="color: #98fb98;">String</span>, <span style="color: #7fffd4;">io</span>::<span style="color: #98fb98;">Error</span>&gt; {
    <span style="color: #00ffff;">let</span> <span style="color: #00ffff;">mut</span> <span style="color: #eedd82;">f</span> = <span style="color: #98fb98;">File</span> ::open(<span style="color: #ffa07a;">"hello.txt"</span>)<span style="color: #b0c4de; font-weight: bold;">?</span>;
    <span style="color: #00ffff;">let</span> <span style="color: #00ffff;">mut</span> <span style="color: #eedd82;">s</span> = <span style="color: #98fb98;">String</span>::new();
    f.read_to_string(&amp;<span style="color: #00ffff;">mut</span> s)<span style="color: #b0c4de; font-weight: bold;">?</span>;
    <span style="color: #98fb98;">Ok</span>(s)
}
</pre>
</div>

<p>
Result 值之后的 ? 于上面 match 表达式有着完全相同的工作方式：
</p>
<ul class="org-ul">
<li>如果 Result 的值是 Ok，这个表达式将会返回 Ok 中的值而程序将 <span class="underline">继续执行</span></li>
<li>如果值是 Err，Err 中的值将作为 <span class="underline">整个函数的返回值</span> ，就好像使用了 return 关键字一样，这样错误值就被传播给了调用者</li>
</ul>


<pre class="example">
上面的示例中：

File ::open 调用结尾的 ? 将会把 Ok 中的值返回给变量 f
如果出现了错误，? 运算符会提早返回整个函数并将一些 Err 值传播给调用者

同理也适用于 read_to_string 调用结尾的 ?
</pre>

<p>
match 表达式与问号运算符所做的有一点不同： ? 运算符所使用的错误值被传递给了 from 函数，收到的错误类型被转换为定义为当前函数返回的错误类型
</p>

<pre class="example">
from 函数定义于标准库的 From trait 中，其用来将错误从一种类型转换为另一种类型

这在当一个函数返回一个错误类型来代表所有可能失败的方式时很有用：
即使其可能会因很多种原因失败。只要每一个错误类型都实现了 from 函数来定义如将其转换为返回的错误类型，? 运算符会自动处理这些转换
</pre>

<p>
? 运算符消除了大量样板代码并使得函数的实现更简单。甚至可以在 ? 之后直接使用 <span class="underline">链式</span> 方法调用来进一步缩短代码，如下所示： 
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::io;
<span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">io</span>::<span style="color: #98fb98;">Read</span>;
<span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">fs</span>::<span style="color: #98fb98;">File</span>;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">read_username_from_file</span>() -&gt; <span style="color: #98fb98;">Result</span>&lt;<span style="color: #98fb98;">String</span>, <span style="color: #7fffd4;">io</span>::<span style="color: #98fb98;">Error</span>&gt; {
    <span style="color: #00ffff;">let</span> <span style="color: #00ffff;">mut</span> <span style="color: #eedd82;">s</span> = <span style="color: #98fb98;">String</span>::new();

    <span style="color: #98fb98;">File</span> ::open(<span style="color: #ffa07a;">"hello.txt"</span>)<span style="color: #b0c4de; font-weight: bold;">?</span>.read_to_string(&amp;<span style="color: #00ffff;">mut</span> s)<span style="color: #b0c4de; font-weight: bold;">?</span>;

    <span style="color: #98fb98;">Ok</span>(s)
}
</pre>
</div>

<pre class="example">
      在 s 中创建新的 String 被放到了函数开头；这一部分没有变化

      对 File ::open("hello.txt")? 的结果直接链式调用了 read_to_string，而不再创建变量 f

      当然仍然需要 read_to_string 调用结尾的 ?，而且当 File ::open 和 read_to_string 都成功没有失败时返回包含用户名 s 的 Ok 值

      其功能是一样的，不过这是一个与众不同且更符合工程学的写法
</pre>

<p>
甚至还有一个更短的写法：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::io;
<span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::fs;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">read_username_from_file</span>() -&gt; <span style="color: #98fb98;">Result</span>&lt;<span style="color: #98fb98;">String</span>, <span style="color: #7fffd4;">io</span>::<span style="color: #98fb98;">Error</span>&gt; {
    <span style="color: #7fffd4;">fs</span>::read_to_string(<span style="color: #ffa07a;">"hello.txt"</span>)
}
</pre>
</div>

<p>
将文件读取到一个字符串是相当常见的操作，所以 Rust 提供了名为 <span class="underline">fs::read_to_string</span> 的函数，它会打开文件、新建一个 String、读取文件的内容，并将内容放入 String，接着返回它
</p>
</div>
</div>

<div id="outline-container-org07c0752" class="outline-4">
<h4 id="org07c0752">? 运算符只可被用于返回 Result 的函数</h4>
<div class="outline-text-4" id="text-org07c0752">
<p>
? 运算符可被用于返回值类型为 Result 的函数，因为他被定义为与示例中的 match 表达式有着完全相同的工作方式。match 的 <span class="underline">return Err(e)</span> 部分要求返回值类型是 <span class="underline">Result</span> ，所以函数的返回值必须是 Result 才能与这个 return 相兼容
</p>

<pre class="example">
    看看在 main 函数中使用 ? 运算符会发生什么?
</pre>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">fs</span>::<span style="color: #98fb98;">File</span>;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">f</span> = <span style="color: #98fb98;">File</span> ::open(<span style="color: #ffa07a;">"hello.txt"</span>)<span style="color: #b0c4de; font-weight: bold;">?</span>;
}
</pre>
</div>

<p>
当编译这些代码，会得到如下错误信息：
</p>
<div class="org-src-container">
<pre class="src src-sh">error[E0277]: the <span style="color: #fa8072;">`?`</span> operator can only be used<span style="color: #00ffff;"> in</span> a <span style="color: #00ffff;">function</span> <span style="color: #87cefa;">that</span> returns <span style="color: #fa8072;">`Result`</span> or <span style="color: #fa8072;">`Option`</span> (or another type that implements <span style="color: #fa8072;">`std:$</span>
<span style="color: #fa8072;">  --&gt; src/main.rs:43:13</span>
<span style="color: #fa8072;">   |</span>
<span style="color: #fa8072;">43 |     let f = File ::open("hello.txt")?;</span>
<span style="color: #fa8072;">   |             ^^^^^^^^^^^^^^^^^^^^^^^^ cannot use the `</span>?<span style="color: #fa8072;">` operator in a function that returns `</span>()<span style="color: #fa8072;">`</span>
<span style="color: #fa8072;">   |</span>
<span style="color: #fa8072;">   = help: the trait `</span>std::ops::Try<span style="color: #fa8072;">` is not implemented for `</span>()<span style="color: #fa8072;">`</span>
<span style="color: #fa8072;">   = note: required by `</span>std::ops::Try::from_error<span style="color: #fa8072;">`</span>
</pre>
</div>

<p>
错误指出只能在返回 Result 或者其它实现了 std::ops::Try 的类型的函数中使用 ? 运算符。当期望在不返回 Result 的函数中调用其他返回 Result 的函数时使用 ? 的话，有两种方法修复这个问题：
</p>
<ol class="org-ol">
<li>将函数返回值类型修改为 Result&lt;T, E&gt;，如果没有其它限制阻止你这么做的话</li>
<li>通过合适的方法使用 match 或 Result 的方法之一来处理 Result&lt;T, E&gt;</li>
</ol>

<p>
main 函数是特殊的，其必须返回什么类型是有限制的。main 函数的一个有效的返回值是 ()，另一个有效的返回值是 <span class="underline">Result&lt;T, E&gt;</span> ，如下所示：
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">error</span>::<span style="color: #98fb98;">Error</span>;
<span style="color: #00ffff;">use</span> <span style="color: #7fffd4;">std</span>::<span style="color: #7fffd4;">fs</span>::<span style="color: #98fb98;">File</span>;

<span style="color: #00ffff;">fn</span> <span style="color: #87cefa;">main</span>() -&gt; <span style="color: #98fb98;">Result</span>&lt;(), <span style="color: #98fb98;">Box</span>&lt;<span style="color: #00ffff;">dyn</span> <span style="color: #98fb98;">Error</span>&gt;&gt; {
    <span style="color: #00ffff;">let</span> <span style="color: #eedd82;">f</span> = <span style="color: #98fb98;">File</span> ::open(<span style="color: #ffa07a;">"hello.txt"</span>)<span style="color: #b0c4de; font-weight: bold;">?</span>;

    <span style="color: #98fb98;">Ok</span>(())
}
</pre>
</div>

<pre class="example">
Box&lt;dyn Error&gt; 被称为 “trait 对象”，目前可以理解 Box&lt;dyn Error&gt; 为使用 ? 时 main 允许返回的 “任何类型的错误”
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org03a4966" class="outline-2">
<h2 id="org03a4966">panic! 还是不 panic!</h2>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>一个 I/O 项目：构建一个命令行程序</title>
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Wu, Shanliang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/main.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="test.html"> UP </a>
 |
 <a accesskey="H" href="rust.html"> HOME </a>
</div><div id="content">
<h1 class="title">一个 I/O 项目：构建一个命令行程序</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">接受命令行参数</a>
<ul>
<li><a href="#sec-1-1">读取参数值</a></li>
<li><a href="#sec-1-2">将参数值保存进变量</a></li>
</ul>
</li>
<li><a href="#sec-2">读取文件</a></li>
<li><a href="#sec-3">重构改进模块性和错误处理</a>
<ul>
<li><a href="#sec-3-1">二进制项目的关注分离</a></li>
<li><a href="#sec-3-2">提取参数解析器</a></li>
<li><a href="#sec-3-3">组合配置值</a>
<ul>
<li><a href="#sec-3-3-1">创建一个 Config 的构造函数</a></li>
</ul>
</li>
<li><a href="#sec-3-4">修复错误处理</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
本章既是一个目前所学的很多技能的概括，也是一个更多标准库功能的探索。将构建一个与文件和命令行输入/输出交互的命令行工具来练习现在一些已经掌握的 Rust 技能
</p>

<pre class="example">
Rust 的运行速度、安全性、单二进制文件输出和跨平台支持使其成为创建命令行程序的绝佳选择，所以我们的项目将创建一个自己版本的经典命令行工具：grep

grep 是 “Globally search a Regular Expression and Print.” 的首字母缩写

grep 最简单的使用场景是在特定文件中搜索指定字符串。为此，grep 获取一个文件名和一个字符串作为参数，接着读取文件并找到其中包含字符串参数的行，然后打印出这些行
</pre>
<p>
在这个过程中，会展示如何让这个命令行工具利用很多命令行工具中用到的终端功能：
</p>
<ul class="org-ul">
<li>读取环境变量来使得用户可以配置工具的行为
</li>
<li>打印到标准错误控制流，而不是标准输出，这样用户可以选择将成功输出重定向到文件中的同时仍然在屏幕上显示错误信息
</li>
</ul>

<pre class="example">
  一位 Rust 社区的成员，Andrew Gallant，已经创建了一个功能完整且非常快速的 grep 版本，叫做 ripgrep

  相比之下，我们的 grep 版本将非常简单，但能帮助理解像 ripgrep 这样真实项目的背景知识
</pre>

<p>
这里将会结合之前所学的一些内容：
</p>
<ul class="org-ul">
<li>代码组织
</li>
<li>vector 和字符串
</li>
<li>错误处理
</li>
<li>合理的使用 trait 和生命周期
</li>
<li>测试
</li>
</ul>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">接受命令行参数</h2>
<div class="outline-text-2" id="text-1">
<p>
使用 cargo new 新建一个项目，称之为 minigrep 以便与可能已经安装在系统上的 grep 工具相区别：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ cargo new minigrep
     Created binary (application) <span style="color: #fa8072;">`minigrep`</span> project
</pre>
</div>

<p>
第一个任务是让 minigrep 能够接受两个命令行参数：
</p>
<ul class="org-ul">
<li>文件名
</li>
<li>要搜索的字符串
</li>
</ul>

<p>
也就是说希望能够使用 cargo run、要搜索的字符串和被搜索的文件的路径来运行程序，像这样：
</p>

<div class="org-src-container">

<pre class="src src-sh">$ cargo run searchstring example-filename.txt
</pre>
</div>

<p>
现在 cargo new 生成的程序忽略任何传递给它的参数
</p>

<pre class="example">
Crates.io 上有一些现成的库可以帮助接受命令行参数，不过我们正在学习这些内容，让我们自己来实现一个
</pre>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">读取参数值</h3>
<div class="outline-text-3" id="text-1-1">
<p>
为了确保 minigrep 能够获取传递给它的命令行参数的值，需要一个 Rust 标准库提供的函数，也就是 <span class="underline">std::env::args</span> ，这个函数返回一个传递给程序的 <span class="underline">命令行参数</span> 的 <span class="underline">迭代器</span> 
</p>
<pre class="example">
现在只需理解迭代器的两个细节：
1. 迭代器生成一系列的值
2. 可以在迭代器上调用 collect 方法将其转换为一个集合，比如包含所有迭代器产生元素的 vector
</pre>

<p>
下面代码来读取任何传递给 minigrep 的命令行参数并将其收集到一个 vector 中：
</p>

<div class="org-src-container">

<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::env;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">args</span>: <span style="color: #98f5ff;">Vec</span>&lt;<span style="color: #98f5ff;">String</span>&gt; = <span style="color: #ffd700;">env</span>::args().collect();
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"</span><span style="color: #deb887; font-style: italic;">{:?}</span><span style="color: #deb887;">"</span>, args);
}
</pre>
</div>

<p>
首先使用 <span class="underline">use</span> 语句来将 <span class="underline">std::env</span> 模块引入作用域以便可以使用它的 args 函数。注意 std::env::args 函数被嵌套进了两层模块中，这里有两个原因：
</p>
<ul class="org-ul">
<li>当所需函数嵌套了多于一层模块时，通常将父模块引入作用域，而不是其自身，这便于利用 std::env 中的其他函数
</li>
<li>这比仅仅使用 args 调用函数要更明确一些，因为 args 容易被错认成一个定义于当前模块的函数
</li>
</ul>

<pre class="example">
std::env::args 在其任何参数包含无效 Unicode 字符时会 panic！！！

如果需要接受包含无效 Unicode 字符的参数，使用 std::env::args_os 代替

这个函数返回 OsString 值而不是 String 值

这里出于简单考虑使用了 std::env::args，因为 OsString 值每个平台都不一样而且比 String 值处理起来更为复杂
</pre>
<p>
在 main 函数的第一行，调用了 <span class="underline">env::args</span> ，并立即使用 <span class="underline">collect</span> 来 <b>创建</b> 了一个包含 <b>迭代器</b> 所有值的 <span class="underline">vector</span>
</p>
<pre class="example">
collect 可以被用来创建很多类型的集合，所以这里显式注明 args 的类型来指定需要一个字符串 vector

虽然在 Rust 中很少会需要注明类型，然而 collect 是一个经常需要注明类型的函数，因为 Rust 不能推断出想要什么类型的集合
</pre>

<p>
最后，使用 <b>调试</b> 格式 <span class="underline">:?</span> 打印出 vector。现在尝试分别用两种方式（不包含参数和包含参数）运行代码：
</p>

<div class="org-src-container">

<pre class="src src-sh">$ cargo run 
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 0.00s
     Running <span style="color: #fa8072;">`target/debug/minigrep`</span>
[<span style="color: #deb887;">"target/debug/minigrep"</span>]

$ cargo run needle haystack 
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 0.00s
     Running <span style="color: #fa8072;">`target/debug/minigrep needle haystack`</span>
[<span style="color: #deb887;">"target/debug/minigrep"</span>, <span style="color: #deb887;">"needle"</span>, <span style="color: #deb887;">"haystack"</span>]
</pre>
</div>

<p>
注意 vector 的第一个值是 <span class="underline">target/debug/minigrep</span> ，它是我们 <b>二进制文件的名称</b> 
</p>

<pre class="example">
  这与 C 中的参数列表的行为相匹配，让程序使用在执行时调用它们的名称

  如果要在消息中打印它或者根据用于调用程序的命令行别名更改程序的行为，通常可以方便地访问程序名称

  不过考虑到本章的目的，我们将忽略它并只保存所需的两个参数
</pre>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">将参数值保存进变量</h3>
<div class="outline-text-3" id="text-1-2">
<pre class="example">
   打印出参数 vector 中的值展示了程序可以访问指定为命令行参数的值
</pre>
<p>
现在需要将这两个参数的值保存进变量这样就可以在程序的余下部分使用这些值了：
</p>

<div class="org-src-container">

<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::env;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">args</span>: <span style="color: #98f5ff;">Vec</span>&lt;<span style="color: #98f5ff;">String</span>&gt; = <span style="color: #ffd700;">env</span>::args().collect();

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">query</span> = &amp;args[1];
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">filename</span> = &amp;args[2];

    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Searching for </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, query);
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"In file </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, filename);
}
</pre>
</div>

<pre class="example">
正如之前打印出 vector 时所所看到的，程序的名称占据了 vector 的第一个值 args[0]，所以从索引 1 开始

minigrep 获取的第一个参数是需要搜索的字符串，所以将其将第一个参数的引用存放在变量 query 中

第二个参数将是文件名，所以将第二个参数的引用放入变量 filename 中
</pre>
<p>
使用参数 test 和 sample.txt 再次运行这个程序：
</p>

<div class="org-src-container">

<pre class="src src-sh">$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 0.0 secs
     Running <span style="color: #fa8072;">`target/debug/minigrep test sample.txt`</span>
Searching for test
In file sample.txt
</pre>
</div>

<pre class="example">
   之后会增加一些错误处理来应对类似用户没有提供参数的情况，不过现在将忽略他们并开始增加读取文件功能
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">读取文件</h2>
<div class="outline-text-2" id="text-2">
<p>
首先，需要一个用来测试的示例文件：用来确保 minigrep 正常工作的最好的文件是拥有多行少量文本且有一些重复单词的文件
</p>
<pre class="example">
  一首艾米莉·狄金森（Emily Dickinson）的诗，它正适合这个工作！
</pre>
<p>
在项目根目录创建一个文件 poem.txt：
</p>

<pre class="example">
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</pre>

<p>
创建完这个文件之后，修改 src/main.rs 并增加下面所示的打开文件的代码：
</p>
<div class="org-src-container">

<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::env;
<span style="color: #00bfff; font-weight: bold;">use</span> <span style="color: #ffd700;">std</span>::fs;

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"In file </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, filename);

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">contents</span> = <span style="color: #ffd700;">fs</span>::read_to_string(filename)
        .expect(<span style="color: #deb887;">"Something went wrong reading the file"</span>);

    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"With text:\n</span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, contents);
}
</pre>
</div>

<ol class="org-ol">
<li>增加了一个 use 语句来引入标准库中的相关部分：需要 <span class="underline">std::fs</span> 来处理文件
</li>
<li>在 main 中新增了一行语句：fs::read_to_string 接受 filename，打开文件，接着返回包含其内容的 Result&lt;String&gt;
</li>
<li>增加了临时的 println! 打印出读取文件之后 contents 的值，这样就可以检查目前为止的程序能否工作 
</li>
</ol>

<p>
尝试运行这些代码，随意指定一个字符串作为第一个命令行参数（因为还未实现搜索功能的部分）而将 poem.txt 文件将作为第二个参数：
</p>

<div class="org-src-container">

<pre class="src src-sh">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) <span style="color: #00bfff; font-weight: bold;">in</span> 0.0 secs
     Running <span style="color: #fa8072;">`target/debug/minigrep the poem.txt`</span>
Searching for the
In file poem.txt
With text:
I<span style="color: #deb887;">'m nobody! Who are you?</span>
<span style="color: #deb887;">Are you nobody, too?</span>
<span style="color: #deb887;">Then there'</span>s a pair of us &#8212; don<span style="color: #deb887;">'t tell!</span>
<span style="color: #deb887;">They'</span>d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</pre>
</div>

<pre class="example">
虽然它还有一些瑕疵：
1. main 函数有着多个职能，通常函数只负责一个功能的话会更简洁并易于维护
2. 没有尽可能的处理错误

虽然这个程序还很小，这些瑕疵并不是什么大问题，不过随着程序功能的丰富，将会越来越难以用简单的方法修复他们

在开发程序时，及早开始重构是一个最佳实践，因为重构少量代码时要容易的多，所以现在就开始吧
</pre>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">重构改进模块性和错误处理</h2>
<div class="outline-text-2" id="text-3">
<p>
我们的程序这里有四个问题需要修复，而且他们都与程序的 <span class="underline">组织方式</span> 和如何处理 <span class="underline">潜在错误</span> 有关：
</p>
<ul class="org-ul">
<li>main 现在进行了两个任务：它解析了参数并打开了文件
</li>
</ul>
<pre class="example">
  对于一个这样的小函数，这并不是一个大问题

  然而如果 main 中的功能持续增加，main 函数处理的独立任务也会增加

  当函数承担了更多责任，它就更难以推导，更难以测试，并且更难以在不破坏其他部分的情况下做出修改
</pre>
<p>
最好能分离出功能以便每个函数就负责一个任务
</p>

<ul class="org-ul">
<li>search 和 filename 是程序中的配置变量，而像 f 和 contents 则用来执行程序逻辑
</li>
</ul>
<pre class="example">
  随着 main 函数的增长，就需要引入更多的变量到作用域中，而当作用域中有更多的变量时，将更难以追踪每个变量的目的
</pre>
<p>
最好能将配置变量组织进一个结构，这样就能使他们的目的更明确了
</p>

<ul class="org-ul">
<li>如果打开文件失败使用 expect 来打印出错误信息，不过这个错误信息只是说 file not found
</li>
</ul>
<pre class="example">
  除了缺少文件之外还有很多可以导致打开文件失败的方式：例如，文件可能存在，不过可能没有打开它的权限

  如果出于这种情况，打印出的 file not found 错误信息就给了用户错误的建议！
</pre>
<ul class="org-ul">
<li>不停地使用 expect 来处理不同的错误
</li>
</ul>

<pre class="example">
  如果所有的错误处理都位于一处，这样将来的维护者在需要修改错误处理逻辑时就只需要考虑这一处代码
</pre>
<p>
将所有的错误处理都放在一处也有助于确保打印的错误信息对终端用户来说是有意义的
</p>
</div>
<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">二进制项目的关注分离</h3>
<div class="outline-text-3" id="text-3-1">
<p>
main 函数负责多个任务的组织问题在许多二进制项目中很常见。所以 Rust 社区总结出一类在 main 函数开始变得庞大时进行二进制程序的关注分离的指导性过程。这些过程有如下步骤：
</p>
<ul class="org-ul">
<li>将程序拆分成 main.rs 和 lib.rs 并将 <b>程序的逻辑</b> 放入 <span class="underline">lib.rs</span> 中
</li>
<li>当 <span class="underline">命令行解析逻辑</span> <b>比较小</b> 时，可以保留在 main.rs 中
</li>
<li>当 <span class="underline">命令行解析</span> 开始变得 <b>复杂</b> 时，也同样将其从 main.rs 提取到 lib.rs 中
</li>
</ul>

<pre class="example">
  这个模式的一切就是为了关注分离：main.rs 处理程序运行，而 lib.rs 处理所有的真正的任务逻辑

  因为不能直接测试 main 函数，这个结构通过将所有的程序逻辑移动到 lib.rs 的函数中使得可以测试他们

  仅仅保留在 main.rs 中的代码将足够小以便阅读就可以验证其正确性
</pre>

<p>
经过这些过程之后保留在 main 函数中的责任应该被限制为：
</p>
<ul class="org-ul">
<li>使用 <span class="underline">参数值</span> 调用 <span class="underline">命令行解析</span> 逻辑
</li>
<li><b>设置</b> 任何其他的 <span class="underline">配置</span> 
</li>
<li>调用 <span class="underline">lib.rs</span> 中的 <span class="underline">run</span> 函数
</li>
<li>如果 run 返回错误，则 <b>处理</b> 这个 <span class="underline">错误</span> 
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">提取参数解析器</h3>
<div class="outline-text-3" id="text-3-2">
<p>
首先，将 <span class="underline">解析参数</span> 的功能提取到一个 main 将会调用的函数中，为将命令行解析逻辑移动到 src/lib.rs 中做准备。下面展示了新 main 函数的开头，它调用了新函数 parse_config。目前它仍将定义在 src/main.rs 中：
</p>

<div class="org-src-container">

<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">args</span>: <span style="color: #98f5ff;">Vec</span>&lt;<span style="color: #98f5ff;">String</span>&gt; = <span style="color: #ffd700;">env</span>::args().collect();

    <span style="color: #00bfff; font-weight: bold;">let</span> (query, filename) = parse_config(&amp;args);

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">parse_config</span>(<span style="color: #4eee94;">args</span>: &amp;[<span style="color: #98f5ff;">String</span>]) -&gt; (&amp;<span style="color: #98f5ff;">str</span>, &amp;<span style="color: #98f5ff;">str</span>) {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">query</span> = &amp;args[1];
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">filename</span> = &amp;args[2];

    (query, filename)
}
</pre>
</div>
<ul class="org-ul">
<li>仍然将命令行参数收集进一个 vector
<ul class="org-ul">
<li>不同于在 main 函数中将索引 1 的参数值赋值给变量 query 和将索引 2 的值赋值给变量 filename，将整个 vector 传递给 parse_config 函数
</li>
</ul>
</li>
<li>parse_config 函数将包含决定哪个参数该放入哪个变量的逻辑，并将这些值返回到 main
</li>
<li>仍然在 main 中创建变量 query 和 filename，不过 main 不再负责处理命令行参数与变量如何对应
</li>
</ul>

<pre class="example">
  我们将采用小的、增量的步骤进行重构

  在做出这些改变之后，再次运行程序并验证参数解析是否仍然正常

  经常验证你的进展是一个好习惯，这样在遇到问题时能帮助你定位问题的成因
</pre>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">组合配置值</h3>
<div class="outline-text-3" id="text-3-3">
<pre class="example">
  现在函数返回一个元组，不过立刻又将元组拆成了独立的部分，这是一个可能没有进行正确抽象的信号

  另一个表明还有改进空间的迹象是 parse_config 名称的 config 部分，它暗示了返回的两个值是相关的并都是一个配置值的一部分

  目前除了将这两个值组合进元组之外并没有表达这个数据结构的意义
</pre>
<p>
可以将这两个值放入一个结构体并给每个字段一个有意义的名字。这会让未来的维护者更容易理解不同的值如何相互关联以及他们的目的
</p>

<div class="org-src-container">

<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">args</span>: <span style="color: #98f5ff;">Vec</span>&lt;<span style="color: #98f5ff;">String</span>&gt; = <span style="color: #ffd700;">env</span>::args().collect();

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">config</span> = parse_config(&amp;args);

    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"Searching for </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, config.query);
    <span style="color: #f08080;">println!</span>(<span style="color: #deb887;">"In file </span><span style="color: #deb887; font-style: italic;">{}</span><span style="color: #deb887;">"</span>, config.filename);

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">contents</span> = <span style="color: #ffd700;">fs</span>::read_to_string(config.filename)
        .expect(<span style="color: #deb887;">"Something went wrong reading the file"</span>);

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}

<span style="color: #00bfff; font-weight: bold;">struct</span> <span style="color: #98f5ff;">Config</span> {
    <span style="color: #4eee94;">query</span>: <span style="color: #98f5ff;">String</span>,
    <span style="color: #4eee94;">filename</span>: <span style="color: #98f5ff;">String</span>,
}

<span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">parse_config</span>(<span style="color: #4eee94;">args</span>: &amp;[<span style="color: #98f5ff;">String</span>]) -&gt; <span style="color: #98f5ff;">Config</span> {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">query</span> = args[1].clone();
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">filename</span> = args[2].clone();

    <span style="color: #98f5ff;">Config</span> { query, filename }
}
</pre>
</div>
<ul class="org-ul">
<li>新定义的结构体 <span class="underline">Config</span> 中包含字段 <span class="underline">query</span> 和 <span class="underline">filename</span> 
</li>
<li>parse_config 的签名表明它现在返回一个 Config 值
</li>
</ul>

<pre class="example">
  在之前的 parse_config 函数体中，返回了引用 args 中 String 值的字符串 slice

  但是现在定义 Config 来包含拥有所有权的 String 值，main 中的 args 变量是参数值的所有者并只允许 parse_config 函数借用他们

  这意味着如果 Config 尝试获取 args 中值的所有权将违反 Rust 的借用规则
</pre>

<p>
最简单但有些不太高效的方式是调用这些值的 clone 方法。这会生成 Config 实例可以拥有的 <b>数据的完整拷贝</b> ，不过会比储存字符串数据的引用消耗更多的时间和内存
</p>

<pre class="example">
  拷贝数据使得代码显得更加直白因为无需管理引用的生命周期，同时因为只会进行一次这样的拷贝，而且文件名和要搜索的字符串都比较短，在这种情况下牺牲一小部分性能来换取简洁性的取舍是值得的

  但是由于其运行时消耗，许多 Rustacean 之间有一个趋势是倾向于避免使用 clone 来解决所有权问题

  另外在第一轮编写时拥有一个可以工作但有点低效的程序要比尝试过度优化代码更好一些
</pre>

<p>
更新 main 将 parse_config 返回的 Config 实例放入变量 config 中，并将之前分别使用 search 和 filename 变量的代码更新为现在的使用 Config 结构体的字段的代码
</p>

<pre class="example">
  这么做会让未来的维护者更容易理解不同的值如何相互关联以及他们的目的

  注意：有一些人将这种在复杂类型更为合适的场景下使用基本类型的反模式称为“基本类型偏执”
</pre>
</div>

<div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1">创建一个 Config 的构造函数</h4>
<div class="outline-text-4" id="text-3-3-1">
<pre class="example">
  目前为止，将负责解析命令行参数的逻辑从 main 提取到了 parse_config 函数中，这有助于看清值 query 和 filename 是相互关联的并应该在代码中表现这种关系

  接着增加了 Config 结构体来描述 query 和 filename 的相关性，并能够从 parse_config 函数中将这些值的名称作为结构体字段名称返回
</pre>

<p>
现在 parse_config 函数的目的是创建一个 Config 实例，可以将 parse_config 从一个普通函数变为一个叫做 new 的与结构体关联的函数
</p>
<pre class="example">
  做出这个改变使得代码更符合习惯：

  可以像标准库中的 String 调用 String::new 来创建一个该类型的实例那样，将 parse_config 变为一个与 Config 关联的 new 函数
</pre>
<p>
下面展示了需要做出的修改：
</p>

<div class="org-src-container">

<pre class="src src-rust"><span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">main</span>() {
    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">args</span>: <span style="color: #98f5ff;">Vec</span>&lt;<span style="color: #98f5ff;">String</span>&gt; = <span style="color: #ffd700;">env</span>::args().collect();

    <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">config</span> = <span style="color: #98f5ff;">Config</span>::new(&amp;args);

    <span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>
}

<span style="color: #5f9ea0; font-style: italic;">// </span><span style="color: #5f9ea0; font-style: italic;">--snip--</span>

<span style="color: #00bfff; font-weight: bold;">impl</span> <span style="color: #98f5ff;">Config</span> {
    <span style="color: #00bfff; font-weight: bold;">fn</span> <span style="color: #daa520; font-weight: bold;">new</span>(<span style="color: #4eee94;">args</span>: &amp;[<span style="color: #98f5ff;">String</span>]) -&gt; <span style="color: #98f5ff;">Config</span> {
        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">query</span> = args[1].clone();
        <span style="color: #00bfff; font-weight: bold;">let</span> <span style="color: #4eee94;">filename</span> = args[2].clone();

        <span style="color: #98f5ff;">Config</span> { query, filename }
    }
}
</pre>
</div>
<ol class="org-ol">
<li>将 parse_config 的名字改为 new 并将其移动到 impl 块中，这使得 new 函数与 Config 相关联
</li>
<li>将 main 中调用 <span class="underline">parse_config</span> 的地方更新为调用 <span class="underline">Config::new</span> 
</li>
</ol>

<p>
再次尝试编译并确保它可以工作
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">修复错误处理</h3>
<div class="outline-text-3" id="text-3-4">
<p>
<a href="fp.html">Next：函数式范式</a>
</p>

<p>
<a href="test.html">Previous：测试</a>
</p>

<p>
<a href="rust.html">Home: 目录</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

		  <br/>
		  <div class='ds-thread'></div>
		  <script>
		  var duoshuoQuery = {short_name:'klose911'};
		  (function() {
					  var dsThread = document.getElementsByClassName('ds-thread')[0];
					  dsThread.setAttribute('data-thread-key', document.title);
					  dsThread.setAttribute('data-title', document.title);
					  dsThread.setAttribute('data-url', window.location.href);
					  var ds = document.createElement('script');
					  ds.type = 'text/javascript';ds.async = true;
					  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
					  ds.charset = 'UTF-8';
					  (document.getElementsByTagName('head')[0] 
						|| document.getElementsByTagName('body')[0]).appendChild(ds);
					  })();
		  </script>
		  <script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		  ga('create', 'UA-90850421-1', 'auto');
		  ga('send', 'pageview');
		  </script>
</div>
</body>
</html>

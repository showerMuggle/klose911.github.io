#+TITLE: 数据类型
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: basic.html   
#+HTML_LINK_HOME: elisp.html
#+OPTIONS: num:nil timestamp:nil ^:nil


* 数据类型
  elisp 里的对象都是有类型的，而且每一个对象它们知道自己是什么类型

  #+BEGIN_EXAMPLE
    得到一个变量名之后可以用一系列检测方法来测试这个变量是什么类型

    好像没有什么方法来让它说出自己是什么类型的
  #+END_EXAMPLE
  内建的 emacs 数据类型称为 primitive types，包括 _整数_ 、 _浮点数_ 、 _cons_ 、 _符号(symbol)_ 、 _字符串_ 、 _向量(vector)_ 、 _散列表(hash-table)_ 、subr（内建函数，比如 cons, if, and 之类）、 _byte-code function_ ，和其它特殊类型，例如 _缓冲区（buffer）_  


  在开始前有必要先了解一下读入语法和输出形式：
  +  _读入语法_ ：让 elisp 解释器明白输入字符所代表的对象，简单的来说，一种数据类型有（也可能没有，比如散列表）对应的规则来让解释器产生这种数据类型
  #+BEGIN_EXAMPLE
    比如 123 产生整数 123，(a . b) 产生一个 cons

    当然不可能让 elisp 读入 .#@!? 这样奇怪的东西还能好好工作吧（perl好像经常要受这样的折磨:)）
  #+END_EXAMPLE
  + _输出形式_ ：解释器用产生一个字符串来表示一个数据对象
  #+BEGIN_EXAMPLE
    比如整数 123 的输出形式就是 123，cons cell (a . b) 的输出形式是 (a . b) 
  #+END_EXAMPLE

  与读入语法不同的是，数据对象都有输出形式。比如散列表的输出可能是这样的：
  #+BEGIN_SRC lisp  
  #<hash-table 'eql nil 0/65 0xa7344c8>
  #+END_SRC

  通常一个对象的数据对象的输出形式和它的读入形式都是相同的 


* 数字
  现在就先从简单的数据类型：数字开始吧。emacs 的数字分为整数和浮点数

  #+BEGIN_EXAMPLE
  和 C 比没有双精度数 double
  #+END_EXAMPLE

** 整数
   1， 1.，+1, -1, 536870913, 0, -0 这些都是整数。整数的范围是和机器是有关的，一般来最小范围是在 -268435456 to 268435455（29位，-2**28 ~ 2**28-1）

   #+BEGIN_EXAMPLE
     可以从 most-positive-fixnum 和 most-negative-fixnum 两个变量得到整数的范围
   #+END_EXAMPLE

   可以用多种进制来输入一个整数。比如：
   #+BEGIN_SRC lisp 
  #b101100 ;; => 44      ; 二进制
  #o54 ;; => 44          ; 八进制
  #x2c ;; => 44          ; 十进制
   #+END_SRC
   最神奇的是可以用 2 到 36 之间任意一个数作为基数，比如：

   #+BEGIN_SRC lisp 
  #24r1k ;; => 44 二十四进制
   #+END_SRC

   #+BEGIN_EXAMPLE
     之所以最大是 36，是因为只有 0-9 和 a-z 36 个字符来表示数字

     但是基本上不会有人会用到 elisp 的这个特性
   #+END_EXAMPLE

** 浮点数
   1500.0, 15e2, 15.0e2, 1.5e3, 和 .15e4 都可以用来表示一个浮点数 1500.

   #+BEGIN_EXAMPLE
     遵循 IEEE 标准，elisp 也有一个特殊类型的值称为 NaN (not-a-number)

     可以用 (/ 0.0 0.0) 产生这个数
   #+END_EXAMPLE

** 测试
   整数类型测试函数是 integerp，浮点数类型测试函数是 floatp。数字类型测试用 numberp。可以分别运行这几个例子来试验一下：

   #+BEGIN_SRC lisp 
  (integerp 1.)                           ; => t
  (integerp 1.0)                          ; => nil
  (floatp 1.)                             ; => nil
  (floatp -0.0e+NaN)                      ; => t
  (numberp 1)                             ; => t
   #+END_SRC

   还提供一些特殊测试，比如测试是否是零的 zerop，还有非负整数测试的 wholenump 

   #+BEGIN_EXAMPLE
     elisp 测试函数一般都是用 p 来结尾，p 是 predicate 的第一个字母

     如果函数名是一个单词，通常只是在这个单词后加一个 p，如果是多个单词，一般是加 -p 
   #+END_EXAMPLE

** 比较
   常用的比较操作符号是在其它言中都很熟悉的，比如 <, >, >=, <=, = 
   #+BEGIN_EXAMPLE
     由于赋值是使用 set 函数，所以 = 不再是一个赋值运算符了，而是测试数字相等符号

     和其它语言类似，对于浮点数的相等测试都是不可靠的
   #+END_EXAMPLE

   比如：

   #+BEGIN_SRC lisp 
  (setq foo (- (+ 1.0 1.0e-3) 1.0))       ; => 0.0009999999999998899
  (setq bar 1.0e-3)                       ; => 0.001
  (= foo bar)                             ; => nil
   #+END_SRC

   所以一定要确定两个浮点数是否相同，是要在一定误差内进行比较。这里给出一个函数：

   #+BEGIN_SRC lisp 
  (defvar fuzz-factor 1.0e-6)

  (defun approx-equal (x y)
    (or (and (= x 0) (= y 0))
	(< (/ (abs (- x y))
	      (max (abs x) (abs y)))
	   fuzz-factor)))
  (approx-equal foo bar)                  ; => t
   #+END_SRC

   还有一个测试数字是否相等的函数 eql，这是函数不仅测试数字的值是否相等，还测试 *数字类型* 是否一致，比如：

   #+BEGIN_SRC lisp 
  (= 1.0 1)                               ; => t
  (eql 1.0 1)                             ; => nil
   #+END_SRC

   #+BEGIN_EXAMPLE
     elisp 没有 +=, -=, /=, *= 这样的命令式语言里常见符号

     如果想实现类似功能的语句，只能用赋值函数 setq 来实现了

     /= 符号被用来作为不等于的测试了 
   #+END_EXAMPLE

** 转换
   整数向浮点数转换是通过 float 函数进行的。而浮点数转换成整数有这样几个函数：
	+ truncate 转换成靠近 0 的整数
	+ floor 转换成最接近的不比本身大的整数
	+ ceiling 转换成最接近的不比本身小的整数
	+ round 四舍五入后的整数，换句话说和它的差绝对值最小的整数

	  #+BEGIN_EXAMPLE
	    可以用 1.2, 1.7, -1.2, -1.7 对这四个函数操作一遍就知道区别了

	    浮点数的范围是无穷大的，而整数是有范围的，如果用前面的函数转换 1e20 成一个整数会出现什么情况呢？
	  #+END_EXAMPLE

** 运算 
   四则运算没有什么好说的，就是 + - * /。值得注意的是

   #+BEGIN_EXAMPLE
     和 C 语言类似，如果参数都是整数，作除法时要记住 (/ 5 6) 是会等于 0 的

     如果参数中有浮点数，整数会自动转换成浮点数进行运算，所以 (/ 5 6.0) 的值才会是 5/6
   #+END_EXAMPLE

   没有++和--操作了，类似的两个函数是 _1+_ 和 _1-_ 。可以用 setq 赋值来代替++和--：

   #+BEGIN_SRC lisp 
  (setq foo 10)                           ; => 10
  (setq foo (1+ foo))                     ; => 11
  (setq foo (1- foo))                     ; => 10
   #+END_SRC

   #+BEGIN_EXAMPLE
     可能有人看过有 incf 和 decf 两个实现 ++ 和 -- 操作，这两个宏是可以用的

     这两个宏是 Common Lisp 里的，emacs 有模拟的 Common Lisp 的库 cl。但是 RMS 认为最好不要使用这个库
   #+END_EXAMPLE

   可以在的 elisp 包中使用这两个宏，只要在文件头写上：

   #+BEGIN_SRC lisp 
  (eval-when-compile
    (require 'cl))
   #+END_SRC

   #+BEGIN_EXAMPLE
     由于 incf 和 decf 是两个宏，所以这样写不会在运行里导入 cl 库
   #+END_EXAMPLE

	+ 取数的绝对值: abs 
	+ 取整的函数: 一个是符号 %，一个是函数 mod
	  #+BEGIN_EXAMPLE
	    这两个函数有什么差别呢？

	    一是 % 的第个参数必须是整数，而 mod 的第一个参数可以是整数也可以是浮点数

	    二是即使对相同的参数，两个函数也不一定有相同的返回值
	  #+END_EXAMPLE

	  + 三角运算有函数： sin, cos, tan, asin, acos, atan
	  + 开方函数： sqrt
	  + 指数函数：exp 是以 e 为底的指数运算，expt 可以指定底数的指数运算
	  + 对数函数：log 默认底数是 e
	    + 也可以指定底数。log10 就是以10为底数
	    + logb 是以 2 为底数运算，但是返回的是一个整数。这个函数是用来计算数的位
	  + 随机函数：random 可以产生随机数

	  #+BEGIN_EXAMPLE
	    当然还包含位运算
	  #+END_EXAMPLE

* 字符串
  在 emacs 里字符串是有序的字符数组，和 c 语言的字符串数组不同，emacs 的字符串可以容纳任何字符，包括 _\0_ ： 
  #+BEGIN_SRC lisp 
  (setq foo "abc\000abc")                 ; => "abc^@abc"
  #+END_SRC

  #+BEGIN_EXAMPLE
    关于字符串有很多高级的属性，例如字符串的表示有单字节和多字节类型，字符串可以有文本属性等等
  #+END_EXAMPLE

** 字符
   首先构成字符串的字符其实就是一个整数
   #+BEGIN_EXAMPLE
     一个字符 'A' 就是一个整数 65

     但是目前字符串中的字符被限制在 0-524287 之间
   #+END_EXAMPLE
   字符的读入语法是在字符前加上一个问号，比如 ?A 代表字符 'A'

   #+BEGIN_SRC lisp 
  ?A                                      ; => 65
  ?a                                      ; => 97
   #+END_SRC

   + 对于 _标点_ 来说，也可以用同样的语法，但是最好在前面加上转义字符 _\_ ，因为有些标点会有岐义，比如 ?\(
     + \ 必须用 ?\\ 表示
   + 控制字符，退格、制表符，换行符，垂直制表符，换页符，空格，回车，删除和 escape 表示为 ?\a, ?\b, ?\t, ?\n, ?\v, ?\f, ?\s, ?\r, ?\d, 和 ?\e

   #+BEGIN_SRC lisp 

  ?\a => 7                 ; control-g, `C-g'
  ?\b => 8                 ; backspace, <BS>, `C-h'
  ?\t => 9                 ; tab, <TAB>, `C-i'
  ?\n => 10                ; newline, `C-j'
  ?\v => 11                ; vertical tab, `C-k'
  ?\f => 12                ; formfeed character, `C-l'
  ?\r => 13                ; carriage return, <RET>, `C-m'
  ?\e => 27                ; escape character, <ESC>, `C-['
  ?\s => 32                ; space character, <SPC>
  ?\\ => 92                ; backslash character, `\'
  ?\d => 127               ; delete character, <DEL>
   #+END_SRC

   #+BEGIN_EXAMPLE
     没有特殊意义的字符，加上转义字符 \ 是没有副作用的，比如 ?\+ 和 ?+ 是完全一样的

     所以标点还是都用转义字符来表示吧 
   #+END_EXAMPLE

   _控制字符_ 可以有多种表示方式，比如 C-i，这些都是对的，它们都对应数字 9：

   #+BEGIN_SRC lisp 
  ?\^I
  ?\^i
  ?\C-I
  ?\C-i 
   #+END_SRC
   _meta 字符_ 是用 _修饰键_ （通常就是 Alt 键）输入的字符。之所以称为修饰键，是因为这样输入的字符就是在其修饰字符的第 *27* 位由 0 变成 1 而成，也就是如下操作：

   #+BEGIN_SRC lisp 
  (logior (lsh 1 27) ?A)                  ; => 134217793
  ?\M-A                                   ; => 134217793
   #+END_SRC
   可以用 _\M-_ 代表 meta 键，加上修饰的字符就是新生成的字符。比如：?\M-A, ?\M-\C-b. 后面这个也可以写成 ?\C-\M-b。

   #+BEGIN_EXAMPLE
     如果还记得前面说过字符串里的字符不能超过 524287 的话，这就可以看出字符串是不能放下一个 meta 字符的，所以按键序列在这时只能用 vector 来储存
   #+END_EXAMPLE

   其它的修饰键也是类似的，emacs 用 ：
   + 第 25 位来表示 shift 键
   + 第 24 对应 hyper
   + 第 23 对应 super
   + 第 22 对应 alt

** 测试
   + 字符串测试使用 _stringp_ ，没有 charp，因为字符就是整数
   + _string-or-null-p_ 当对象是一个字符或 nil 时返回 t
   + _char-or-string-p_ 测试是否是字符串或者字符类型

   #+BEGIN_EXAMPLE
   比较头疼的是 emacs 没有测试字符串是否为空的函数
   #+END_EXAMPLE
   这是我用的这个测试函数，使用前要测试字符串是否为 nil：

   #+BEGIN_SRC elisp 
  (defun string-emptyp (str)
    (not (string< "" str)))
   #+END_SRC

** 构造
   + 产生一个字符串可以用 _make-string_ 。这样生成的字符串包含的字符都是一样的
   + 要生成不同的字符串可以用 _string_ 函数 

   #+BEGIN_SRC lisp 
  (make-string 5 ?x)                      ; => "xxxxx"
  (string ?a ?b ?c)                       ; => "abc"
   #+END_SRC

   在已有的字符串生成新的字符串的方法有 _substring_ , _concat_ 
   + substring 的后两个参数是起点和终点的位置，如果终点越界或者终点比起点小都会产生一个错误。这个在使用 substring 时要特别小心 

   #+BEGIN_SRC lisp 
  (substring "0123456789" 3)              ; => "3456789"
  (substring "0123456789" 3 5)            ; => "34"
  (substring "0123456789" -3 -1)          ; => "78"
   #+END_SRC

   concat 函数相对简单，就是把几个字符串连接起来

** 比较
   + _char-equal_ 可以比较两个字符是否相等。与整数比较不同，这个函数还考虑了大小写
     + 如果 _case-fold-search_ 变量是 t 时，这个函数的字符比较是忽略大小写的
   #+BEGIN_EXAMPLE
     编程时要小心，因为通常 case-fold-search 都是 t，这样如果要考虑字符的大小写时就不能用 char-equal 函数了
   #+END_EXAMPLE
   + 字符串比较使用 _string=_ ，string-equal 是一个别名
   + _string<_ 是按 *字典序* 比较两个字符串，string-less 是它的别名
   #+BEGIN_EXAMPLE
     空字符串小于所有字符串，除了空字符串，前面 string-emptyp 就是用这个特性

     当然直接用 length 检测字符串长度应该也可以，还可以省去检测字符串是否为空
   #+END_EXAMPLE
   + 没有 string> 函数


** 转换
   + 字符转换成字符串可以用 _char-to-string_ 函数
   + 字符串转换成字符可以用 _string-to-char_
     + 当然只是返回字符串的第一个字符 
   + 数字和字符串之间的转换：
     + _string-to-number_ 可以设置字符串的进制，可以从 2 到 16
     + _number-to-string_ 只能转换成 10 进制的数字
   + 如果要输出八进制或者十六进制，可以用 _format_ 函数：

   #+BEGIN_SRC lisp 
  (string-to-number "256")                ; => 256
  (number-to-string 256)                  ; => "256"
  (format "%#o" 256)                      ; => "0400"
  (format "%#x" 256)                      ; => "0x100"
   #+END_SRC

   如果要输出成二进制，好像没有现成的函数了。calculator 库倒是可以，这是我写的函数：

   #+BEGIN_SRC lisp 
  (defun number-to-bin-string (number)
    (require 'calculator)
    (let ((calculator-output-radix 'bin)
	  (calculator-radix-grouping-mode nil))
      (calculator-number-to-string number)))
  (number-to-bin-string 256)              ; => "100000000"
   #+END_SRC

   + _concat_ 可以把一个 *字符构成* 的 _列表或者向量_ 转换成 _字符串_
   + _vconcat_ 可以把一个 _字符串_ 转换成一个 _向量_ 
   + _append_ 可以把一个 _字符串_ 转换成一个 _列表_ 

   #+BEGIN_SRC lisp 
  (concat '(?a ?b ?c ?d ?e))              ; => "abcde"
  (concat [?a ?b ?c ?d ?e])               ; => "abcde"
  (vconcat "abdef")                       ; => [97 98 100 101 102]
  (append "abcdef" nil)                   ; => (97 98 99 100 101 102)
   #+END_SRC

   + 大小写转换使用的是 _downcase_ 和 _upcase_ 两个函数
     + 这两个函数的参数既可以字符串，也可以是字符
   + _capitalize_ 可以使字符串中单词的 *第一个字符大写* ，其它字符小写
     + _upcase-initials_ 只使第一个单词的第一个字符大写，其它字符小写
     + 这两个函数的参数如果是一个字符，那么只让这个字符大写 

   #+BEGIN_SRC lisp 
  (downcase "The cat in the hat")         ; => "the cat in the hat"
  (downcase ?X)                           ; => 120
  (upcase "The cat in the hat")           ; => "THE CAT IN THE HAT"
  (upcase ?x)                             ; => 88
  (capitalize "The CAT in tHe hat")       ; => "The Cat In The Hat"
  (upcase-initials "The CAT in the hAt")  ; => "The CAT In The HAt"
   #+END_SRC

** 格式化
   format 类似于 C 语言里的 printf 可以实现对象的字符串化，数字的格式化和 printf 的参数差不多
   + 值得一提的是 _%S_ 这个格式化形式，它可以把 *对象的输出形式* 转换成 _字符串_ ，这在调试时是很有用的

** 查找和替换
   字符串查找的核心函数是 _string-match_ 。这个函数可以从 _指定的位置_ 对字符串进行 *正则表达式匹配* ，如果匹配成功，则返回 _匹配的起点_ ，如：

   #+BEGIN_SRC lisp 
  (string-match "34" "01234567890123456789")    ; => 3
  (string-match "34" "01234567890123456789" 10) ; => 13
   #+END_SRC

   #+BEGIN_EXAMPLE
   注意 string-match 的参数是一个 regexp
   #+END_EXAMPLE
   emacs 好象没有内建的查找子串的函数。如果想把 string-match 作为一个查找子串的函数，可以先用 _regexp-quote_ 函数先处理一下子串。比如：
   #+BEGIN_SRC lisp 
  (string-match "2*" "232*3=696")                ; => 0
  (string-match (regexp-quote "2*") "232*3=696") ; => 2
   #+END_SRC

   #+BEGIN_EXAMPLE
     事实上，string-match 不只是查找字符串，它更重要的功能是捕捉匹配的字符串

     如果你对正则表达式不了解，可能需要先找一本书，先了解一下什么是正则表达式
   #+END_EXAMPLE
   string-match 在查找的同时，还会 *记录* 下每个要 *捕捉* 的 _字符串的位置_ 。这个位置可以在匹配后用 _match-data_ 、 _match-beginning_ 和 _match-end_ 等函数来获得。先看一下例子：

   #+BEGIN_SRC elisp 
  (progn
    (string-match "3\\(4\\)" "01234567890123456789")
    (match-data))                         ; => (3 5 4 5)
   #+END_SRC

   正则表达式捕捉的字符串按 _括号的顺序_ 对应一个 _序号_ 
   + 整个模式对应序号 0
   + 第一个括号对应序号 1
   + 第二个括号对应序号 2
   + 。。。以此类推

   #+BEGIN_EXAMPLE
     所以 3\(4\) 这个正则表达式中有序号 0 和 1，最后 match-data 返回的一系列数字对应的分别是要捕捉字符串的起点和终点位置

     也就是说子串 "34" 起点从位置 3 开始，到位置 5 结束

     而捕捉的字符串 "4" 的起点是从 4 开始，到 5 结束

     这些位置可以用 match-beginning 和 match-end 函数用对应的序号得到
   #+END_EXAMPLE
   注意：
   + 起点位置：捕捉字符串的 _第一个字符的位置_
   + 终点位置：不是捕捉的字符串最后一个字符的位置，而是 *下一个字符的位置* 

   这个性质对于循环是很方便的。比如要查找上面这个字符串中所有 34 出现的位置：

   #+BEGIN_SRC lisp 
  (let ((start 0))
    (while (string-match "34" "01234567890123456789" start)
      (princ (format "find at %d\n" (match-beginning 0)))
      (setq start (match-end 0))))

  ;; find at 3
  ;; find at 13
  ;; nil
   #+END_SRC


   替换使用的函数是 _replace-match_ 。这个函数既可以用于 _字符串_ 的替换，也可以用于 _缓冲区的文本_ 替换
   + 对于字符串的替换，replace-match 只是按 _给定的序号_ 把字符串中的 _那一部分用提供的字符串_ 替换了而已：

   #+BEGIN_SRC elisp 
  (let ((str "01234567890123456789"))
    (string-match "34" str)
    (princ (replace-match "x" nil nil str 0))
    (princ "\n")
    (princ str))

  ;; 012x567890123456789
  ;; 01234567890123456789"01234567890123456789" 
   #+END_SRC

   可以看出 replace-match 返回的字符串是替换后的新字符串，原字符串被没有改变 

   #+BEGIN_EXAMPLE
     如果怎样把上面这个字符串中所有的 34 都替换掉？

     如果想就使用同一个字符串来存储，可能对于固定的字符串，这个还容易一些

     如果不是的话，就要花一些脑筋了，因为替换之后，新的字符串下一个搜索起点的位置就不能用 (match-end 0) 给出来的位置了，而是要扣除替换的字符串和被替换的字符串长度的差值
   #+END_EXAMPLE
   + 对 _字符串的替换_ 有一个函数 _replace-regexp-in-string_ ：把每次匹配部分之前的子串收集起来，最后再把所有字符串连接起来
   + _单字符的替换_ 有 _subst-char-in-string_ 函数

   #+BEGIN_EXAMPLE
     但是 emacs 没有类似 perl函数或者程序 tr 那样进行字符替换的函数，只能自己建表进行循环操作了
   #+END_EXAMPLE

* cons 和列表



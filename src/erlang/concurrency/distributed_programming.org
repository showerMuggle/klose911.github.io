#+TITLE: 分布式编程
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: error_handle.html   
#+HTML_LINK_HOME: concurrency.html
#+OPTIONS: num:nil timestamp:nil ^:nil 

#+BEGIN_EXAMPLE
  用Erlang编写分布式程序和编写并发程序只有一步之遥
#+END_EXAMPLE

在分布式Erlang里,可以在远程节点和机器上创建进程。创建出远程进程之后,会看到其他所有的基本函数( send 、 receive和 link 等)都能透明运作在网络中,就像在单个节点上一样

#+BEGIN_EXAMPLE
  在本章将介绍用于编写分布式Erlang程序的库与Erlang基本函数
#+END_EXAMPLE

_分布式_ 程序是那些被设计运行在 _计算机网络_ 上的程序,并且可以仅靠 _传递消息_ 来协调彼此的活动。下面是一些想要编写分布式应用程序的原因：
+ _性能_ ：可以通过安排程序的不同部分在不同的机器上并行运行来让程序跑得更快
+ _可靠性_ ：可以通过让系统运行在数台机器上来实现容错式系统。如果一台机器出了故障,可以在另一台机器上继续
+ _可扩展性_ ：随着把应用程序越做越大,即使机器的处理能力再强大也迟早会耗尽。到那时,就必须添加更多的机器来提升处理能力。添加一台新机器应当是一次简单的操作,不需要对应用程序的架构做出大的修改
+ _天生分布式_ ：许多应用程序天生就是分布式的。如果编写一个多用户游戏或聊天系统,就会有来自世界各地的分散用户。如果在某个地理位置上拥有大量的用户,就会希望把计算资源放置在接近这些用户的地方
+ fun：我想要编写的fun程序大部分都是分布式的。其中许多涉及与全世界各地的人与机器进行交互
* 分布式模型
  这里将讨论两种主要的分布式模型：
  1. 分布式Erlang：在分布式Erlang里,编写的程序会在Erlang的 *节点* ( _node_ )上运行
     + 节点：一个独立的Erlang系统,包含一个 _自带地址空间_ 和 _进程组_ 的 *完整虚拟机* 
       + 可以在任何节点上创建进程,所有消息传递和错误处理基本函数也都能像在单节点上那样工作
     + 分布式Erlang应用程序运行在一个 *可信环境* 中。因为任何节点都可以在其他Erlang节点上执行任意操作,所以这涉及高度的信任
       + 虽然分布式Erlang应用程序可以运行在开放式网络上,但它们通常是运行在属于同一个 _局域网的集群_ 上,并受 _防火墙_ 保护 
  2. 基于套接字：可以用TCP/IP套接字来编写运行在不可信环境中的分布式应用程序
     + 这个编程模型不如分布式Erlang那样强大,但是更安全 

  #+BEGIN_EXAMPLE
    如果回想一下前面的内容,就一定还记得构建程序的基本单位是进程。编写分布式Erlang程序是很容易的,要做的就是在正确的机器上创建出进程,然后一切就能像之前那样运作了

    人们都习惯了编写顺序程序,而编写分布式程序通常会困难得多。下面将介绍编写简单分布式程序的若干技巧。这些程序很简单,但是非常有用
  #+END_EXAMPLE

  接下来将从一些小范例起步。只需先学习两件事,就可以开始创建第一个分布式程序了：
  + 如何启动一个Erlang节点
  + 如何在远程Erlang节点上执行远程过程调用
* 编写分布式程序
  当开发一个分布式应用程序时,总是会按照特定的顺序来编写它：
  1. 在一个 _常规的非分布式_ 会话里编写和测试我的程序：这是我们到目前为止一直在做的,所以不会有什么新问题
  2. 在运行于 _同一台计算机_ 上的 _两个不同的Erlang节点_ 里测试程序
  3. 在运行于 _两台物理隔离计算机_ 上的 _两个不同的Erlang节点_ 里测试程序,这两台计算机或者属于同一个局域网,或者来自互联网的任何地方
  4. 如果所运行的机器属于 _相同的管理域_ ,就很少会出问题
     + 但当相关节点属于 _不同域上_ 的机器时,就可能会遇到 *连接性* 问题,而且必须确保系统 _防火墙_ 和 _安全设置_ 都已得到正确配置 

  #+BEGIN_EXAMPLE
    为了演示这些步骤,将制作一个简单的名称服务器(name server)
  #+END_EXAMPLE
  具体而言,将执行下列步骤：
  + 第1阶段：在一个常规的非分布式Erlang系统上编写和测试名称服务器
  + 第2阶段：在同一台机器的两个节点上测试名称服务器
  + 第3阶段：在同一局域网内分属两台不同机器的节点上测试名称服务器
  + 第4阶段：在分属两个不同国家和域的两台机器上测试名称服务器 
** 创建名称服务器
*** 一个简单的名称服务器
*** 客户端在一个节点,服务器在相同主机的另一个节点
*** 同一局域网内不同机器上的客户端和服务器
*** 跨互联网不同主机上的客户端和服务器
* 分布式编程的库和内置函数
* cookie 保护系统

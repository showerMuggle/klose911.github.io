#+TITLE: StatefulSet
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../../css/main.css" />
#+HTML_LINK_UP: deployment.html
#+HTML_LINK_HOME: controller.html
#+OPTIONS: num:nil timestamp:nil ^:nil

StatefulSet 作为 Controller 为 _Pod_ *提供* _唯一的标识_ 。它可以 *保证* _部署_ 和 _scale_ 的顺序

#+BEGIN_EXAMPLE
  使用案例参考：https://github.com/kubernetes-retired/contrib/tree/master/statefulsets

  其中包含zookeeper和kakfa的statefulset设置和使用说明
#+END_EXAMPLE


StatefulSet是为了解决 *有状态服务* 的问题（对应Deployments和ReplicaSets是为无状态服务而设计），其应用场景包括：
+ 稳定的 _持久化存储_ 
  #+BEGIN_EXAMPLE
    即Pod重新调度后还是能访问到相同的持久化数据，基于PVC来实现
  #+END_EXAMPLE
+ 稳定的 _网络标志_ 
  #+BEGIN_EXAMPLE
    即Pod重新调度后其PodName和HostName不变，基于Headless Service（即没有Cluster IP的Service）来实现
  #+END_EXAMPLE
+ 有序部署， _有序扩展_ 
  #+BEGIN_EXAMPLE
    即Pod是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行

    即从0到N-1，在下一个Pod运行之前所有之前的Pod必须都是Running和Ready状态，基于init containers来实现
  #+END_EXAMPLE
+ 有序收缩， _有序删除_ 
  #+BEGIN_EXAMPLE
    即从N-1到0
  #+END_EXAMPLE


从上面的应用场景可以发现，StatefulSet由以下几个部分组成：
+ 用于 _定义_  *网络标志* （DNS domain）的 _Headless Service_
+ 用于 _创建_ *PersistentVolumes* 的 _volumeClaimTemplates_
+ _定义_ *具体应用* 的 _StatefulSet_

StatefulSet中每个Pod的 _DNS格式_ 为 _statefulSetName-{0..N-1}.serviceName.namespace.svc.cluster.local_ ，其中
+ serviceName: Headless Service的名字
+ 0..N-1: Pod所在的序号，从0开始到N-1
+ statefulSetName: StatefulSet的名字
+ namespace: 服务所在的namespace
  #+BEGIN_EXAMPLE
    Headless Servic和StatefulSet必须在相同的namespace
  #+END_EXAMPLE
+ .cluster.local: Cluster Domain
* 使用
  StatefulSet 适用于有以下某个或多个需求的应用：
  + 稳定，唯一的网络标志
  + 稳定，持久化存储
  + 有序，优雅地部署和 scale
  + 有序，优雅地删除和终止
  + 有序，自动的滚动升级 

  #+BEGIN_EXAMPLE
    稳定是 Pod （重新）调度中持久性的代名词，如果应用程序不需要任何稳定的标识符、有序部署、删除和 scale，则应该使用提供一组无状态副本的 controller 来部署应用程序

    例如 Deployment 或 ReplicaSet 可能更适合您的无状态需求
  #+END_EXAMPLE
* 限制
  + 给定 Pod 的存储必须由 PersistentVolume Provisioner 根据请求的 storage class 进行配置，或由管理员预先配置
  + 删除或 scale StatefulSet 将不会删除与 StatefulSet 相关联的 volume
    #+BEGIN_EXAMPLE
      这样做是为了确保数据安全性，这通常比自动清除所有相关 StatefulSet 资源更有价值
    #+END_EXAMPLE
  + StatefulSets 目前要求 Headless Service 负责 Pod 的网络身份
    #+BEGIN_EXAMPLE
      使用者有责任创建此服务
    #+END_EXAMPLE
* 组件

  下面的示例中描述了 StatefulSet 中的组件：
  + 一个名为 _nginx_ 的 *headless service* ，用于 _控制网络域_
  + 一个名为 _web_ 的 *StatefulSet* ，它的 _Spec_ 中指定在有 _3_ 个运行 nginx 容器的 _Pod_
  + _volumeClaimTemplates_ 使用 _PersistentVolume Provisioner_ 提供的 _PersistentVolumes_ 作为 *稳定存储* 

  #+BEGIN_EXAMPLE
    apiVersion: v1
    kind: Service
    metadata:
      name: nginx
      labels:
	app: nginx
    spec:
      ports:
      - port: 80
	name: web
      clusterIP: None
      selector:
	app: nginx
    ---
    apiVersion: apps/v1beta1
    kind: StatefulSet
    metadata:
      name: web
    spec:
      serviceName: "nginx"
      replicas: 3
      template:
	metadata:
	  labels:
	    app: nginx
	spec:
	  terminationGracePeriodSeconds: 10
	  containers:
	  - name: nginx
	    image: gcr.io/google_containers/nginx-slim:0.8
	    ports:
	    - containerPort: 80
	      name: web
	    volumeMounts:
	    - name: www
	      mountPath: /usr/share/nginx/html
      volumeClaimTemplates:
      - metadata:
	  name: www
	  annotations:
	    volume.beta.kubernetes.io/storage-class: anything
	spec:
	  accessModes: [ "ReadWriteOnce" ]
	  resources:
	    requests:
	      storage: 1Gi
  #+END_EXAMPLE
* Pod 身份
  StatefulSet Pod 具有唯一的身份，包括 _序数_ ， _稳定的网络身份_ 和 _稳定的存储_ 

  #+BEGIN_EXAMPLE
    身份绑定到 Pod 上，不管它（重新）调度到哪个节点上
  #+END_EXAMPLE

** 序数
   对于一个有 N 个副本的 StatefulSet，每个副本都会被指定一个整数序数，在 _[0,N)_ 之间，且 *唯一* 

** 稳定的网络 ID
   + StatefulSet 中的每个 Pod 从 _StatefulSet 的名称_ 和 _Pod 的序数_ 派生其主机名。构造的主机名的模式是 _$(statefulset名称)-$(序数)_ 
     #+BEGIN_EXAMPLE
       上面的例子将创建三个名为web-0，web-1，web-2的 Pod
     #+END_EXAMPLE
   + StatefulSet 可以使用 Headless Service 来控制其 Pod 的域
     + 此服务管理的域的格式： _$(服务名称).$(namespace).svc.cluster.local_
       + “cluster.local” 是 *集群域* 
     + 在创建每个Pod时，它将获取一个匹配的 DNS 子域： _$(pod 名称).$(管理服务域)_
       + 其中管理服务由 StatefulSet 上的 _serviceName_ 字段定义。

   以下是 Cluster Domain，服务名称，StatefulSet 名称以及如何影响 StatefulSet 的 Pod 的 DNS 名称的一些示例: 
   #+ATTR_HTML: :border 1 :rules all :frame boader
   | Cluster Domain	 | Service (ns/name)	 | StatefulSet (ns/name)	 | StatefulSet Domain	              | Pod DNS                                              | 	Pod Hostname |
   | cluster.local	  | default/nginx	     | default/web	           | nginx.default.svc.cluster.local	 | web-{0..N-1}.nginx.default.svc.cluster.local	 | web-{0..N-1}         |
   | cluster.local	  | foo/nginx	         | foo/web	               | nginx.foo.svc.cluster.local	     | web-{0..N-1}.nginx.foo.svc.cluster.local	     | web-{0..N-1}         |
   | kube.local	     | foo/nginx	         | foo/web	               | nginx.foo.svc.kube.local	        | web-{0..N-1}.nginx.foo.svc.kube.local                |                      |

** 稳定存储
Kubernetes 为每个 VolumeClaimTemplate 创建一个 PersistentVolume

#+BEGIN_EXAMPLE
  上面的 nginx 的例子中，每个 Pod 将具有一个由 anything 存储类创建的 1 GB 存储的 PersistentVolume

  当该 Pod （重新）调度到节点上，volumeMounts 将挂载与 PersistentVolume Claim 相关联的 PersistentVolume
#+END_EXAMPLE

注意：PersistentVolume Claim 相关联的 PersistentVolume 在 产出 Pod 或 StatefulSet 的时候不会被删除。这必须 *手动* 完成

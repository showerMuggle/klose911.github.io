#+TITLE: Volume
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../../css/main.css" />
#+HTML_LINK_UP: config-map.html
#+HTML_LINK_HOME: storage.html
#+OPTIONS: num:nil timestamp:nil ^:nil

#+begin_example
  容器磁盘上的文件的生命周期是短暂的，这就使得在容器中运行重要应用时会出现一些问题

  首先，当容器崩溃时，kubelet 会重启它，但是容器中的文件将丢失——容器以干净的状态（镜像最初的状态）重新启动

  其次，在 Pod 中同时运行多个容器时，这些容器之间通常需要共享文件
#+end_example

Kubernetes 中的 Volume 抽象就很好的解决了这些问题
* 背景
  #+begin_example
    Docker 中也有一个 volume 的概念，尽管它稍微宽松一些，管理也很少

    在 Docker 中，卷就像是磁盘或是另一个容器中的一个目录

    它的生命周期不受管理，直到最近才有了 local-disk-backed 卷

    Docker 现在提供了卷驱动程序，但是功能还非常有限。例如 Docker1.7只允许每个容器使用一个卷驱动，并且无法给卷传递参数
  #+end_example
  + Kubernetes 中的卷有明确的寿命：与封装它的 Pod 相同。所以，卷的生命比 Pod 中的所有容器都长，当这个容器重启时数据仍然得以保存
    #+begin_example
      当然，当 Pod 不再存在时，卷也将不复存在
    #+end_example
  + 更重要的是，Kubernetes 支持多种类型的卷，Pod 可以同时使用任意数量的卷

  卷的核心是目录，可能还包含了一些数据，可以通过 pod 中的容器来访问
  #+begin_example
    该目录是如何形成的、支持该目录的介质以及其内容取决于所使用的特定卷类型
  #+end_example

  要使用卷，需要为 pod 指定为卷 _spec.volumes_ 字段 以及将它挂载到容器的位置 _spec.containers.volumeMounts_ 字段 

  #+begin_example
    容器中的进程看到的是由其 Docker 镜像和卷组成的文件系统视图

    Docker 镜像位于文件系统层次结构的根目录，任何卷都被挂载在镜像的指定路径中

    卷无法挂载到其他卷上或与其他卷有硬连接

    Pod 中的每个容器都必须独立指定每个卷的挂载位置
  #+end_example
* 类型
  Kubernetes 支持以下类型的卷：
  + awsElasticBlockStore
  + azureDisk
  + azureFile
  + cephfs
  + csi
  + downwardAPI
  + emptyDir
  + fc (fibre channel)
  + flocker
  + gcePersistentDisk
  + gitRepo
  + glusterfs
  + hostPath
  + iscsi
  + local
  + nfs
  + persistentVolumeClaim
  + projected
  + portworxVolume
  + quobyte
  + rbd
  + scaleIO
  + secret
  + storageos
  + vsphereVolume

** awsElasticBlockStore
awsElasticBlockStore 卷将 _AWS EBS Volume_ 挂载到容器中：
+ 与 emptyDir 类型会在删除 Pod 时被清除不同，EBS 卷的的内容会保留下来，仅仅是被 *卸载*
  #+begin_example
    这意味着 EBS 卷可以预先填充数据，并且可以在数据包之间“切换”数据 
  #+end_example

#+begin_example
  必须使用 aws ec2 create-volume 或 AWS API 创建 EBS 卷，才能使用它
#+end_example

使用 awsElasticBlockStore 卷时有一些限制：
+ 运行 Pod 的节点必须是 AWS EC2 实例
+ 这些实例需要与 EBS 卷位于相同的区域和可用区域
+ EBS 仅支持卷和 EC2 实例的一对一的挂载   

*** 创建 EBS 卷
在 pod 中使用的 EBS 卷之前，需要先创建它：

#+begin_src sh 
  $ aws ec2 create-volume --availability-zone=eu-west-1a --size=10 --volume-type=gp2
#+end_src

确保区域与您启动集群的区域相匹配（并且检查大小和 EBS 卷类型是否适合！）

*** 配置
    #+begin_example
      apiVersion: v1
      kind: Pod
      metadata:
	name: test-ebs
      spec:
	containers:
	- image: k8s.gcr.io/test-webserver
	  name: test-container
	  volumeMounts:
	  - mountPath: /test-ebs
	    name: test-volume
	volumes:
	- name: test-volume
	  # This AWS EBS volume must already exist.
	  awsElasticBlockStore:
	    volumeID: <volume-id>
	    fsType: ext4
    #+end_example
 
** azureDisk
AzureDisk 用于将 Microsoft Azure Data Disk 挂载到 Pod 中

** azureFile
azureFile 用于将 Microsoft Azure File Volume（SMB 2.1 和 3.0）挂载到 Pod 中 

** cephfs
cephfs 卷允许将现有的 CephFS 卷挂载到您的容器中：
+ 不像 emptyDir，当删除 Pod 时被删除，cephfs 卷的内容将被保留，卷仅仅是被卸载
  #+begin_example
    这意味着 CephFS 卷可以预先填充数据，并且可以在数据包之间“切换”数据
  #+end_example
+ CephFS 可以被多个写设备同时挂载

#+begin_example
必须先拥有自己的 Ceph 服务器，然后才能使用它
#+end_example

** csi
_CSI_ 代表 *容器存储接口*
#+begin_example
  CSI 试图建立一个行业标准接口的规范，借助 CSI 容器编排系统可以将任意存储系统暴露给自己的容器工作负载
#+end_example

csi 卷类型是一种 _in-tree_ 的 _CSI 卷插件_ ，用于 Pod 与在 _同一节点_ 上运行的 _外部 CSI 卷驱动程序_ 交互。部署 CSI 兼容卷驱动后，用户可以使用 csi 作为卷类型来挂载驱动提供的存储

#+begin_example
  CSI 持久化卷支持是在 Kubernetes v1.9 中引入的，作为一个 alpha 特性，必须由集群管理员明确启用

  换句话说，集群管理员需要在 apiserver、controller-manager 和 kubelet 组件的 “--feature-gates =” 标志中加上 “CSIPersistentVolume = true”
#+end_example
CSI 持久化卷具有以下字段可供用户指定：
+ driver：一个字符串值，指定要使用的卷驱动程序的名称
  + 必须少于 63 个字符，并以一个字符开头
  + 驱动程序名称可以包含 “.”、“- ”、“_” 或数字
+ volumeHandle：一个字符串值，唯一标识从 CSI 卷插件的 CreateVolume 调用返回的卷名。随后在卷驱动程序的所有后续调用中使用卷句柄来引用该卷
+ readOnly：一个可选的布尔值，指示卷是否被发布为只读
  + 默认是 false

** 

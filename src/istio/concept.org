#+TITLE: 概念
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: istio.html   
#+HTML_LINK_HOME: istio.html
#+OPTIONS: num:nil timestamp:nil ^:nil
* Istio 是什么？
  #+begin_example
    云平台令使用它们的公司受益匪浅，但不可否认的是，上云会给 DevOps 团队带来压力

    为了可移植性，开发人员必须使用微服务来构建应用，同时运维人员也正在管理着极端庞大的混合云和多云的部署环境
  #+end_example
  Istio 允许您 _连接_ 、 _保护_ 、 _控制_ 和 _观察_ 服务。从较高的层面来说，Istio 有助于降低这些部署的复杂性，并减轻开发团队的压力：
  + 它是一个完全开源的 _服务网格_ ，作为 _透明的一层_ 接入到现有的分布式应用程序里
  + 它也是一个 _平台_ ，拥有可以集成任何 _日志_ 、_ 遥测_ 和 _策略_ 系统的 _API 接口_ 

  Istio 多样化的特性使您能够成功且高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法
** 服务网格 
   _服务网格_ 用来描述组成这些应用程序的微服务网络以及它们之间的交互。随着服务网格的规模和复杂性不断的增长，它将会变得越来越难以理解和管理。它的需求包括 _服务发现_ 、 _负载均衡_ 、 _故障恢复_ 、 _度量_ 和 _监控_ 等。服务网格通常还有更复杂的运维需求，比如 _A/B 测试_ 、 _金丝雀发布_ 、 _速率限制_ 、 _访问控制_ 和 _端到端认证_ 

   #+begin_example
     Istio 提供了对整个服务网格的行为洞察和操作控制的能力，以及一个完整的满足微服务应用各种需求的解决方案
   #+end_example
** 为什么使用 Istio？
   通过负载均衡、服务间的身份验证、监控等方法，Istio 可以轻松地创建一个已经部署了服务的网络，而服务的代码只需很少更改甚至无需更改。通过在整个环境中部署一个特殊的 _sidecar 代理_ 为服务添加 Istio 的支持，而代理会 *拦截* _微服务之间_ 的所有 _网络通信_ ，然后使用其 _控制平面_ 的功能来 *配置* 和 *管理* Istio，这包括：
   + 为 HTTP、gRPC、WebSocket 和 TCP 流量自动 _负载均衡_ 
   + 通过丰富的 _路由规则_ 、 _重试_ 、 _故障转移_ 和 _故障注入_ 对 *流量行为* 进行 _细粒度控制_
   + 可插拔的策略层和配置 API，支持 _访问控制_ 、 _速率限制_ 和 _配额_
   + 集群内（包括集群的入口和出口）所有流量的 _自动化度量_ 、 _日志记录_ 和 _追踪_
   + 在具有强大的基于 _身份验证_ 和 _授权_ 的集群中实现 *安全的* 服务间通信 

   #+begin_example
   Istio 为可扩展性而设计，可以满足不同的部署需求
   #+end_example
** 核心特性
   Istio 以统一的方式提供了许多跨服务网络的关键功能
*** 流量管理
    Istio 简单的 _规则配置_ 和 _流量路由_ 允许您控制服务之间的流量和 API 调用过程。Istio 简化了 *服务级属性* （如 _熔断器_ 、 _超时_ 和 _重试_ ）的配置，并且让它轻而易举的执行重要的任务（如 _A/B 测试_ 、 _金丝雀发布_ 和 _按流量百分比_ 划分的分阶段发布） 

    #+begin_example
      有了更好的对流量的可视性和开箱即用的故障恢复特性，您就可以在问题产生之前捕获它们，无论面对什么情况都可以使调用更可靠，网络更健壮
    #+end_example
*** 安全
    Istio 的安全特性解放了开发人员，使其只需要专注于应用程序级别的安全。Istio 提供了 *底层的安全通信通道* ，并为大规模的服务通信管理 _认证_ 、 _授权_ 和 _加密_ 
    #+begin_example
      有了 Istio，服务通信在默认情况下就是受保护的，可以让您在跨不同协议和运行时的情况下实施一致的策略――而所有这些都只需要很少甚至不需要修改应用程序

      Istio 是独立于平台的，可以与 Kubernetes（或基础设施）的网络策略一起使用。但它更强大，能够在网络和应用层面保护pod到 pod 或者服务到服务之间的通信
    #+end_example
*** 可观察性
    Istio 健壮的 _追踪_ 、 _监控_ 和 _日志_ 特性让您能够深入的了解服务网格部署
    #+begin_example
      通过 Istio 的监控能力，可以真正的了解到服务的性能是如何影响上游和下游的

      而它的定制 Dashboard 提供了对所有服务性能的可视化能力，并让您看到它如何影响其他进程
    #+end_example
    Istio 的 _Mixer 组件_ 负责 *策略控制* 和 *遥测数据收集* 。它提供了后端抽象和中介，将一部分 Istio 与后端的基础设施实现细节隔离开来，并为运维人员提供了对网格与后端基础实施之间交互的细粒度控制

    #+begin_example
    所有这些特性都使您能够更有效地设置、监控和加强服务的 SLO。当然，底线是您可以快速有效地检测到并修复出现的问题
    #+end_example
*** 平台支持
    Istio 独立于平台，被设计为可以在各种环境中运行，包括跨云、内部环境、Kubernetes、Mesos 等等。可以在 Kubernetes 或是装有 Consul 的 Nomad 环境上部署 Istio。Istio 目前支持：
    + Kubernetes 上的服务部署
    + 基于 Consul 的服务注册
    + 服务运行在独立的虚拟机上
* 流量管理
  #+begin_example
    Istio 的 流量路由规则可以让您很容易的控制服务之间的流量和 API 调用

    Istio 简化了服务级别属性的配置，比如熔断器、超时和重试，并且能轻松的设置重要的任务，如 A/B 测试、金丝雀发布、基于流量百分比切分的概率发布等

    它还提供了开箱即用的故障恢复特性，有助于增强应用的健壮性，从而更好地应对被依赖的服务或网络发生故障的情况
  #+end_example
  Istio 的流量管理模型源于和 _服务一起部署_ 的 _Envoy 代理_ 。 _网格内服务_ *发送* 和 *接收* 的  _所有流量_ （data plane流量）都经由 _Envoy_ *代理* 

  #+begin_example
    这让控制网格内的流量变得异常简单，而且不需要对服务做任何的更改
  #+end_example
** 介绍
   为了在网格中导流，Istio 需要知道所有的 endpoint 在哪和属于哪个服务。为了定位到 _service registry_ (服务注册中心)，Istio 会连接到一个服务发现系统
   #+begin_example
     例如，如果您在 Kubernetes 集群上安装了 Istio，那么它将自动检测该集群中的服务和 endpoint
   #+end_example

   使用此服务注册中心，Envoy 代理可以将流量定向到相关服务。大多数基于微服务的应用程序，每个服务的工作负载都有多个实例来处理流量，称为 _负载均衡池_ 。默认情况下，Envoy 代理基于 _轮询调度_ 模型在服务的负载均衡池内分发流量，按顺序将请求发送给池中每个成员，一旦所有服务实例均接收过一次请求后，重新回到第一个池成员 

   #+begin_example
     Istio 基本的服务发现和负载均衡能力为您提供了一个可用的服务网格，但它能做到的远比这多的多

     在许多情况下，您可能希望对网格的流量情况进行更细粒度的控制

     作为 A/B 测试的一部分，您可能想将特定百分比的流量定向到新版本的服务，或者为特定的服务实例子集应用不同的负载均衡策略

     您可能还想对进出网格的流量应用特殊的规则，或者将网格的外部依赖项添加到服务注册中心
   #+end_example

   通过使用 Istio 的 _流量管理 API_ 将流量配置添加到 Istio，就可以完成所有这些甚至更多的工作 

   #+begin_example
     和其他 Istio 配置一样，这些 API 也使用 Kubernetes 的自定义资源定义（CRDs）来声明，可以像示例中看到的那样使用 YAML 进行配置
   #+end_example
** 虚拟服务
   _虚拟服务_ （Virtual Service） 和 _目标规则_ （Destination Rule） 是 Istio 流量路由功能的关键拼图。虚拟服务让您配置如何在服务网格内将请求路由到服务，这基于 Istio 和平台提供的基本的连通性和服务发现能力。每个虚拟服务包含一组 _路由规则_ ，Istio 按顺序评估它们，Istio 将每个给定的请求匹配到虚拟服务指定的实际目标地址

   #+begin_example
     您的网格可以有多个虚拟服务，也可以没有，取决于您的使用场景
   #+end_example

*** 为什么使用虚拟服务？
    虚拟服务在增强 Istio 流量管理的 _灵活性_ 和 _有效性_ 方面，发挥着至关重要的作用，通过对 _客户端请求的目标地址_ 与 _真实响应请求的目标工作负载_ 进行 *解耦* 来实现。虚拟服务同时提供了丰富的方式，为发送至这些工作负载的流量指定不同的路由规则。

    #+begin_example
      为什么这如此有用？就像在介绍中所说，如果没有虚拟服务，Envoy 会在所有的服务实例中使用轮询的负载均衡策略分发请求，您可以用您对工作负载的了解来改善这种行为

      例如，有些可能代表不同的版本。这在 A/B 测试中可能有用，您可能希望在其中配置基于不同服务版本的流量百分比路由，或指引从内部用户到特定实例集的流量
    #+end_example
    使用 _虚拟服务_ ，可以为 _一个或多个主机名_ 指定 _流量行为_ 。在虚拟服务中使用 _路由规则_ ，告诉 Envoy 如何 *发送* _虚拟服务的流量_ 到适当的 _目标_ 。 _路由目标地址_ 可以是 _同一服务的不同版本_ ，也可以是 _完全不同的服务_ 

    #+begin_example
      一个典型的用例是将流量发送到被指定为服务子集的服务的不同版本

      客户端将虚拟服务视为一个单一实体，将请求发送至虚拟服务主机，然后 Envoy 根据虚拟服务规则把流量路由到不同的版本。例如，“20% 的调用转到新版本”或“将这些用户的调用转到版本 2”

      这允许您创建一个金丝雀发布，逐步增加发送到新版本服务的流量百分比

      流量路由完全独立于实例部署，这意味着实现新版本服务的实例可以根据流量的负载来伸缩，完全不影响流量路由

      相比之下，像 Kubernetes 这样的容器编排平台只支持基于实例缩放的流量分发，这会让情况变得复杂
    #+end_example

    虚拟服务可以让您：
    + 通过单个虚拟服务处理多个应用程序服务。如果您的网格使用 Kubernetes，可以配置一个虚拟服务处理特定命名空间中的所有服务
    #+begin_example
      映射单一的虚拟服务到多个“真实”服务特别有用，可以在不需要客户适应转换的情况下，将单体应用转换为微服务构建的复合应用系统

      您的路由规则可以指定为“对这些 monolith.com 的 URI 调用转到microservice A”等等

      可以在下面的一个示例看到它是如何工作的
    #+end_example
    + 和网关整合并配置流量规则来控制出入流量 

    #+begin_example
      在某些情况下，您还需要配置目标规则来使用这些特性，因为这是指定服务子集的地方

      在一个单独的对象中指定服务子集和其它特定目标策略，有利于在虚拟服务之间更简洁地重用这些规则
    #+end_example

*** 虚拟服务示例
    下面的虚拟服务根据请求是否来自特定的用户，把它们路由到服务的不同版本

    #+begin_src yaml 
  apiVersion: networking.istio.io/v1alpha3
  kind: VirtualService
  metadata:
    name: reviews
  spec:
    hosts:
    - reviews
    http:
    - match:
      - headers:
	  end-user:
	    exact: jason
      route:
      - destination:
	  host: reviews
	  subset: v2
    - route:
      - destination:
	  host: reviews
	  subset: v3
    #+end_src

**** hosts 字段 
     使用 hosts 字段列举 _虚拟服务的主机_ ：即 _用户指定的目标_ 或是 _路由规则设定的目标_ 。这是客户端向服务发送请求时使用的一个或多个地址

     #+begin_src yaml
  hosts:
  - reviews
     #+end_src

     虚拟服务主机名可以是 _IP 地址_ 、 _DNS 名称_ ，或者依赖于平台的一个简称（例如 _Kubernetes 服务的短名称_ ），隐式或显式地指向一个 _完全限定域名_ （FQDN）。您也可以使用 _通配符_ （“*”）前缀，让您创建一组匹配所有服务的路由规则

     #+begin_example
       虚拟服务的 hosts 字段实际上不必是 Istio 服务注册的一部分，它只是虚拟的目标地址，这让您可以为没有路由到网格内部的虚拟主机建模
     #+end_example

**** 路由规则
     在 http 字段包含了虚拟服务的 _路由规则_ ，用来描述 _匹配条件_ 和 _路由行为_ ，它们把 HTTP/1.1、HTTP2 和 gRPC 等流量发送到 _hosts 字段指定的目标_ （您也可以用 tcp 和 tls 片段为 TCP 和未终止的 TLS 流量设置路由规则）。一个路由规则包含了指定的请求要流向哪个 _目标地址_ ，具有 _0 或多个匹配条件_ ，取决于您的使用场景 

***** 匹配条件
      示例中的第一个路由规则有一个条件，因此以 match 字段开始

      #+begin_src yaml 
  - match:
     - headers:
	 end-user:
	   exact: jason
      #+end_src

      在本例中，您希望此路由应用于来自 ”jason“ 用户的所有请求，所以使用 headers、end-user 和 exact 字段选择适当的请求

***** Destination 
      route 部分的 destination 字段指定了符合此条件的流量的 _实际目标地址_ 。与虚拟服务的 hosts 不同，destination 的 host 必须是 *存在于 Istio 服务注册中心* 的实际目标地址，否则 Envoy 不知道该将请求发送到哪里。可以是一个 _有代理的服务网格_ ，或者是一个通过 _服务入口_ 被添加进来的 _非网格服务_ 

      #+begin_src yaml 
  route:
  - destination:
      host: reviews
      subset: v2
      #+end_src

      #+begin_example
	本示例运行在 Kubernetes 环境中，host 名为一个 Kubernetes 服务名

	请注意，在该示例和本页其它示例中，为了简单，我们使用 Kubernetes 的短名称设置 destination 的 host

	在评估此规则时，Istio 会添加一个基于虚拟服务命名空间的域后缀，这个虚拟服务包含要获取主机的完全限定名的路由规则

	在我们的示例中使用短名称也意味着您可以复制并在任何喜欢的命名空间中尝试它们
      #+end_example

      destination 片段还指定了 _Kubernetes 服务的子集_ ，将符合此规则条件的请求转入其中

      #+begin_example
	在本例中子集名称是 v2，可以在目标规则章节中看到如何定义服务子集
      #+end_example

**** 路由规则优先级
     路由规则按从上到下的顺序选择，虚拟服务中定义的第一条规则有最高优先级

     #+begin_example
       本示例中，不满足第一个路由规则的流量均流向一个默认的目标

       该目标在第二条规则中指定。因此，第二条规则没有 match 条件，直接将流量导向 v3 子集
     #+end_example

     我们建议提供一个默认的“无条件”或基于权重的规则（见下文）作为每一个虚拟服务的最后一条规则，如案例所示，从而确保流经虚拟服务的流量至少能够匹配一条路由规则

*** 路由规则的更多内容
    正如上面所看到的，路由规则是将特定流量子集路由到指定目标地址的强大工具。您可以在流量端口、header 字段、URI 等内容上设置匹配条件

    #+begin_example
      例如，这个虚拟服务让用户发送请求到两个独立的服务：ratings 和 reviews，就好像它们是 http://bookinfo.com/ 这个更大的虚拟服务的一部分

      虚拟服务规则根据请求的 URI 和指向适当服务的请求匹配流量
    #+end_example

    #+begin_src yaml 
  apiVersion: networking.istio.io/v1alpha3
  kind: VirtualService
  metadata:
    name: bookinfo
  spec:
    hosts:
      - bookinfo.com
    http:
    - match:
      - uri:
	  prefix: /reviews
      route:
      - destination:
	  host: reviews
    - match:
      - uri:
	  prefix: /ratings
      route:
      - destination:
	  host: ratings
  ...

    http:
    - match:
	sourceLabels:
	  app: reviews
      route:
  ...
    #+end_src

    有些匹配条件可以使用精确的值，如前缀或正则。可以使用 AND 向同一个 match 块添加多个匹配条件，或者使用 OR 向同一个规则添加多个 match 块。对于任何给定的虚拟服务也可以有多个路由规则

    #+begin_example
      这可以在单个虚拟服务中使路由条件变得随您所愿的复杂或简单

      匹配条件字段和备选值的完整列表可以在 HTTPMatchRequest 参考中找到
    #+end_example

    另外，使用匹配条件您可以按百分比 _权重_ 分发请求。这在 A/B 测试和金丝雀发布中非常有用：

    #+begin_src yaml 
  spec:
    hosts:
    - reviews
    http:
    - route:
      - destination:
	  host: reviews
	  subset: v1
	weight: 75
      - destination:
	  host: reviews
	  subset: v2
	weight: 25
    #+end_src

    也可以使用路由规则在流量上执行一些操作，例如：
    + 添加或删除 header
    + 重写 URL
    + 为调用这一目标地址的请求设置重试策略。

    #+begin_example
      想了解如何利用这些操作，查看 HTTPRoute 参考
    #+end_example

** 目标规则
与虚拟服务一样， _目标规则_ 也是 Istio 流量路由功能的关键部分，可以将虚拟服务视为将流量如何路由到给定目标地址，然后使用目标规则来 *配置该目标的流量* 。在评估虚拟服务路由规则之后，目标规则将应用于流量的“真实”目标地址 
  + 可以使用目标规则来 _指定命名的服务子集_ 
#+BEGIN_EXAMPLE
  例如按版本为所有给定服务的实例分组，然后可以在虚拟服务的路由规则中使用这些服务子集来控制到服务不同实例的流量
#+END_EXAMPLE
  + 还允许在调用整个目的地服务或特定服务子集时 _定制 Envoy 的流量策略_ 
#+BEGIN_EXAMPLE
  比如您喜欢的负载均衡模型、TLS 安全模式或熔断器设置 
#+END_EXAMPLE

*** 负载均衡选项
默认情况下，Istio 使用 _轮询的负载均衡_ 策略，实例池中的每个实例依次获取请求。Istio 同时支持如下的负载均衡模型，可以在 DestinationRule 中为流向某个特定服务或服务子集的流量指定这些模型：
+ _随机_ ：请求以随机的方式转到池中的实例
+ _权重_ ：请求根据指定的百分比转到实例
+ _最少请求_ ：请求被转到最少被访问的实例 

*** 目标规则示例
在下面的示例中，目标规则为 my-svc 目标服务配置了 3 个具有不同负载均衡策略的子集：

#+BEGIN_SRC yaml 
  apiVersion: networking.istio.io/v1alpha3
  kind: DestinationRule
  metadata:
    name: my-destination-rule
  spec:
    host: my-svc
    trafficPolicy:
      loadBalancer:
	simple: RANDOM
    subsets:
    - name: v1
      labels:
	version: v1
    - name: v2
      labels:
	version: v2
      trafficPolicy:
	loadBalancer:
	  simple: ROUND_ROBIN
    - name: v3
      labels:
	version: v3
#+END_SRC

每个子集都是基于一个或多个 _labels_ 定义的

#+BEGIN_EXAMPLE
  在 Kubernetes 中它是附加到像 Pod 这种对象上的键/值对

  这些标签应用于 Kubernetes 服务的 Deployment 并作为 metadata 来识别不同的版本
#+END_EXAMPLE

除了定义子集之外，目标规则对于所有子集都有默认的流量策略，而对于该子集，则有特定于子集的策略覆盖它

#+BEGIN_EXAMPLE
  定义在 subsets 上的默认策略，为 v1 和 v3 子集设置了一个简单的随机负载均衡器

  在 v2 策略中，轮询负载均衡器被指定在相应的子集字段上
#+END_EXAMPLE

** 网关
使用网关为网格来管理入站和出站流量，可以让您指定要进入或离开网格的流量：
+ 网关配置被用于运行在 _网格边界_ 的 _独立 Envoy 代理_ 
+ 不是服务工作负载的 sidecar 代理 

#+BEGIN_EXAMPLE
  与 Kubernetes Ingress API 这种控制进入系统流量的其他机制不同，Istio 网关充分利用流量路由的强大能力和灵活性

  可以这么做的原因是 Istio 的网关资源可以配置 4-6 层的负载均衡属性，如对外暴露的端口、TLS 设置等

  作为替代应用层流量路由（L7）到相同的 API 资源，绑定了一个常规的 Istio 虚拟服务到网关，这可以像管理网格中其他数据平面的流量一样去管理网关流量
#+END_EXAMPLE
网关主要用于管理进入的流量，但也可以配置出口网关。出口网关让您为 _离开网格的流量_ *配置* 一个 _专用的出口节点_ ：
+ 可以限制哪些服务可以或应该访问外部网络
+ 启用出口流量安全控制为您的网格添加安全性
+ 可以使用网关配置一个纯粹的内部代理 

#+BEGIN_EXAMPLE
  Istio 提供了一些预先配置好的网关代理部署（istio-ingressgateway 和 istio-egressgateway）供使用

  如果使用演示安装它们都已经部署好了；如果使用默认或 sds 配置文件则只部署了入口网关

  可以将您自己的网关配置应用到这些部署或配置您自己的网关代理
#+END_EXAMPLE
*** Gateway 示例
下面的示例展示了一个外部 HTTPS 入口流量的网关配置：

#+BEGIN_SRC yaml 
  apiVersion: networking.istio.io/v1alpha3
  kind: Gateway
  metadata:
    name: ext-host-gwy
  spec:
    selector:
      app: my-gateway-controller
    servers:
    - port:
	number: 443
	name: https
	protocol: HTTPS
      hosts:
      - ext-host.example.com
      tls:
	mode: SIMPLE
	serverCertificate: /tmp/tls.crt
	privateKey: /tmp/tls.key
#+END_SRC

#+BEGIN_EXAMPLE
  这个网关配置让 HTTPS 流量从 ext-host.example.com 通过 443 端口流入网格，但没有为请求指定任何路由规则
#+END_EXAMPLE
为想要工作的网关指定路由，您必须把网关绑定到虚拟服务上。正如下面的示例所示，使用虚拟服务的 gateways 字段进行设置：

#+BEGIN_SRC yaml 
  apiVersion: networking.istio.io/v1alpha3
  kind: VirtualService
  metadata:
    name: virtual-svc
  spec:
    hosts:
    - ext-host.example.com
    gateways:
      - ext-host-gwy
#+END_SRC 

然后就可以为出口流量配置带有路由规则的虚拟服务 

** 服务入口
使用 _服务入口_ （Service Entry） 来添加一个 _入口_ 到 Istio 内部维护的 _服务注册中心_ 。添加了服务入口后，Envoy 代理可以向服务发送流量，就好像它是网格内部的服务一样。配置服务入口允许管理运行在 _网格外的服务的流量_ ，它包括以下几种能力：
+ 为外部目标 redirect 和转发请求，例如来自 web 端的 API 调用，或者流向遗留老系统的服务
+ 为外部目标定义重试、超时和故障注入策略
+ 添加一个运行在虚拟机的服务来扩展您的网格
+ 从逻辑上添加来自不同集群的服务到网格，在 Kubernetes 上实现一个多集群 Istio 网格 

#+BEGIN_EXAMPLE
  不需要为网格服务要使用的每个外部服务都添加服务入口，默认情况下，Istio 配置 Envoy 代理将请求传递给未知服务

  但是，您不能使用 Istio 的特性来控制没有在网格中注册的目标流量 
#+END_EXAMPLE

*** 服务入口实例
下面示例的 mesh-external 服务入口将 ext-resource 外部依赖项添加到 Istio 的服务注册中心：

#+BEGIN_SRC yaml 
  apiVersion: networking.istio.io/v1alpha3
  kind: ServiceEntry
  metadata:
    name: svc-entry
  spec:
    hosts:
    - ext-svc.example.com
    ports:
    - number: 443
      name: https
      protocol: HTTPS
    location: MESH_EXTERNAL
    resolution: DNS
#+END_SRC

#+BEGIN_EXAMPLE
  您指定的外部资源使用 hosts 字段，可以使用完全限定名或通配符作为前缀域名
#+END_EXAMPLE

可以配置虚拟服务和目标规则，以更细粒度的方式控制到服务入口的流量，这与网格中的任何其他服务配置流量的方式相同

#+BEGIN_SRC yaml 
  apiVersion: networking.istio.io/v1alpha3
  kind: DestinationRule
  metadata:
    name: ext-res-dr
  spec:
    host: ext-svc.example.com
    trafficPolicy:
      tls:
	mode: MUTUAL
	clientCertificate: /etc/certs/myclientcert.pem
	privateKey: /etc/certs/client_private_key.pem
	caCertificates: /etc/certs/rootcacerts.pem
#+END_SRC

#+BEGIN_EXAMPLE
  例如，目标规则配置流量路由以使用双向 TLS 来保护到 ext-svc.example.com 外部服务的连接，使用服务入口配置了该外部服务
#+END_EXAMPLE

** Sidecar 
默认情况下，Istio 让每个 Envoy 代理都可以访问来自和它关联的工作负载的所有端口的请求，然后转发到对应的工作负载。可以使用 sidecar 配置去做下面的事情：
+ *微调* Envoy 代理 *接受的* _端口_ 和 _协议集_ 
+ *限制* Envoy 代理 *可以访问* 的 _服务集合_ 

#+BEGIN_EXAMPLE
  可能希望在较庞大的应用程序中限制这样的 sidecar 可达性，配置每个代理能访问网格中的任意服务可能会因为高内存使用量而影响网格的性能
#+END_EXAMPLE

可以指定将 sidecar 配置应用于特定命名空间中的所有工作负载，或者使用 workloadSelector 选择特定的工作负载
#+BEGIN_SRC yaml 
  apiVersion: networking.istio.io/v1alpha3
  kind: Sidecar
  metadata:
    name: default
    namespace: bookinfo
  spec:
    egress:
    - hosts:
      - "./*"
      - "istio-system/*"
#+END_SRC

#+BEGIN_EXAMPLE
  sidecar 配置将 bookinfo 命名空间中的所有服务配置为仅能访问运行在相同命名空间和 Istio 控制平面中的服务（目前需要使用 Istio 的策略和遥测功能）
#+END_EXAMPLE

** 网络弹性和测试
除了网格导流之外，Istio 还提供了可选的 _故障恢复_ 和 _故障注入_ 功能

#+BEGIN_EXAMPLE
  可以在运行时动态配置这些功能

  使用这些特性可以让应用程序运行稳定，确保服务网格能够容忍故障节点，并防止局部故障级联影响到其他节点
#+END_EXAMPLE


*** 超时
超时是 Envoy 代理等待来自给定服务的答复的时间量，以确保服务不会因为等待答复而无限期的挂起，并在可预测的时间范围内调用成功或失败。HTTP 请求的默认超时时间是 _15 秒_ ，这意味着如果服务在 15 秒内没有响应，调用将失败。对于某些应用程序和服务，Istio 的缺省超时可能不合适：
+ 超时太长可能会由于等待失败服务的回复而导致过度的延迟
+ 而超时过短则可能在等待涉及多个服务返回的操作时触发不必要地失败

为了找到并使用最佳超时设置，Istio 允许您使用虚拟服务按服务轻松地动态调整超时，而不必修改您的业务代码：

#+BEGIN_SRC yaml 
  apiVersion: networking.istio.io/v1alpha3
  kind: VirtualService
  metadata:
    name: ratings
  spec:
    hosts:
    - ratings
    http:
    - route:
      - destination:
	  host: ratings
	  subset: v1
      timeout: 10s
#+END_SRC

#+BEGIN_EXAMPLE
  示例是一个虚拟服务，它对 ratings 服务的 v1 子集的调用指定 10 秒超时
#+END_EXAMPLE

*** 重试
重试设置指定如果初始调用失败，Envoy 代理尝试连接服务的最大次数。通过确保调用不会因为临时过载的服务或网络等问题而永久失败，重试可以  *提高* 服务 _可用性_ 和应用程序的性能。重试之间的间隔（ _25ms+_ ）是可变的，并由 Istio 自动确定，从而防止被调用服务被请求淹没。HTTP 请求的默认重试行为是在返回错误之前重试 _两次_  。与超时一样，Istio 默认的重试行为在延迟方面可能不适合您的应用程序需求（对失败的服务进行过多的重试会降低速度）或可用性。可以在虚拟服务中按服务调整重试设置，而不必修改业务代码。还可以通过添加每次重试的超时来进一步细化重试行为，并指定每次重试都试图成功连接到服务所等待的时间量

#+BEGIN_SRC yaml 
  apiVersion: networking.istio.io/v1alpha3
  kind: VirtualService
  metadata:
    name: ratings
  spec:
    hosts:
    - ratings
    http:
    - route:
      - destination:
	  host: ratings
	  subset: v1
      retries:
	attempts: 3
	perTryTimeout: 2s
#+END_SRC

#+BEGIN_EXAMPLE
  示例配置了在初始调用失败后最多重试 3 次来连接到服务子集，每个重试都有 2 秒的超时 
#+END_EXAMPLE

*** 熔断器
熔断器是 Istio 为创建具有弹性的微服务应用提供的另一个有用的机制。在熔断器中，设置一个对服务中的单个主机调用的限制，例如 _并发连接的数量_ 或对该主机 _调用失败的次数_ 。一旦限制被触发，熔断器就会“跳闸”并停止连接到该主机。使用熔断模式可以快速失败而不必让客户端尝试连接到过载或有故障的主机。 熔断适用于在负载均衡池中的 *真实* _网格目标地址_ ，您可以在 _目标规则_ 中配置熔断器阈值，让配置适用于服务中的每个主机

#+BEGIN_SRC yaml 
  apiVersion: networking.istio.io/v1alpha3
  kind: DestinationRule
  metadata:
    name: reviews
  spec:
    host: reviews
    subsets:
    - name: v1
      labels:
	version: v1
      trafficPolicy:
	connectionPool:
	  tcp:
	    maxConnections: 100
#+END_SRC

#+BEGIN_EXAMPLE
示例将 v1 子集的reviews服务工作负载的并发连接数限制为 100
#+END_EXAMPLE

*** 故障注入
在配置了网络，包括故障恢复策略之后，可以使用 Istio 的故障注入机制来为整个应用程序测试故障恢复能力

#+BEGIN_EXAMPLE
  故障注入是一种将错误引入系统以确保系统能够承受并从错误条件中恢复的测试方法

  使用故障注入特别有用，能确保故障恢复策略不至于不兼容或者太严格，这会导致关键服务不可用
#+END_EXAMPLE

与其他错误注入机制（如延迟数据包或在网络层杀掉 Pod）不同，Istio 允许在应用层注入错误

#+BEGIN_EXAMPLE
  这可以注入更多相关的故障，例如 HTTP 错误码，以获得更多相关的结果
#+END_EXAMPLE

可以注入两种故障，它们都使用 _虚拟服务_ 配置：
+ _延迟_ ：延迟是时间故障。它们模拟增加的网络延迟或一个超载的上游服务
+ _终止_ ：终止是崩溃失败。他们模仿上游服务的失败。终止通常以 HTTP 错误码或 TCP 连接失败的形式出现 

#+BEGIN_SRC yaml 
  apiVersion: networking.istio.io/v1alpha3
  kind: VirtualService
  metadata:
    name: ratings
  spec:
    hosts:
    - ratings
    http:
    - fault:
	delay:
	  percentage:
	    value: 0.1
	  fixedDelay: 5s
      route:
      - destination:
	  host: ratings
	  subset: v1
#+END_SRC

#+BEGIN_EXAMPLE
  虚拟服务为千分之一的访问 ratings 服务的请求配置了一个 5 秒的延迟
#+END_EXAMPLE

*** 和您的应用程序一起运行
Istio 故障恢复功能对应用程序来说是完全透明的。在返回响应之前，应用程序不知道 Envoy sidecar 代理是否正在处理被调用服务的故障

#+BEGIN_EXAMPLE
  这意味着，如果在应用程序代码中设置了故障恢复策略，那么需要记住这两个策略都是独立工作的，否则会发生冲突

  例如，假设设置了两个超时，一个在虚拟服务中配置，另一个在应用程序中配置

  应用程序为服务的 API 调用设置了 2 秒超时。而在虚拟服务中配置了一个 3 秒超时和重试

  在这种情况下，应用程序的超时会先生效，因此 Envoy 的超时和重试尝试会失效
#+END_EXAMPLE

虽然 Istio 故障恢复特性提高了网格中服务的可靠性和可用性，但 _应用程序_ 必须 _处理故障_ 或 _错误_ 并采取适当的 _回退操作_ 

#+BEGIN_EXAMPLE
  例如，当负载均衡中的所有实例都失败时，Envoy 返回一个HTTP 503代码。应用程序必须实现回退逻辑来处理HTTP 503错误代码
#+END_EXAMPLE


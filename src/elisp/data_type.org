#+TITLE: 数据类型
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: basic.html   
#+HTML_LINK_HOME: elisp.html
#+OPTIONS: num:nil timestamp:nil ^:nil


* 数据类型
  elisp 里的对象都是有类型的，而且每一个对象它们知道自己是什么类型

  #+BEGIN_EXAMPLE
    得到一个变量名之后可以用一系列检测方法来测试这个变量是什么类型

    好像没有什么方法来让它说出自己是什么类型的
  #+END_EXAMPLE
  内建的 emacs 数据类型称为 primitive types，包括 _整数_ 、 _浮点数_ 、 _cons_ 、 _符号(symbol)_ 、 _字符串_ 、 _向量(vector)_ 、 _散列表(hash-table)_ 、subr（内建函数，比如 cons, if, and 之类）、 _byte-code function_ ，和其它特殊类型，例如 _缓冲区（buffer）_  


  在开始前有必要先了解一下读入语法和输出形式：
  +  _读入语法_ ：让 elisp 解释器明白输入字符所代表的对象，简单的来说，一种数据类型有（也可能没有，比如散列表）对应的规则来让解释器产生这种数据类型
  #+BEGIN_EXAMPLE
    比如 123 产生整数 123，(a . b) 产生一个 cons

    当然不可能让 elisp 读入 .#@!? 这样奇怪的东西还能好好工作吧（perl好像经常要受这样的折磨:)）
  #+END_EXAMPLE
  + _输出形式_ ：解释器用产生一个字符串来表示一个数据对象
  #+BEGIN_EXAMPLE
    比如整数 123 的输出形式就是 123，cons cell (a . b) 的输出形式是 (a . b) 
  #+END_EXAMPLE

  与读入语法不同的是，数据对象都有输出形式。比如散列表的输出可能是这样的：
  #+BEGIN_SRC lisp  
  #<hash-table 'eql nil 0/65 0xa7344c8>
  #+END_SRC

  通常一个对象的数据对象的输出形式和它的读入形式都是相同的 


* 数字
  现在就先从简单的数据类型：数字开始吧。emacs 的数字分为整数和浮点数

  #+BEGIN_EXAMPLE
  和 C 比没有双精度数 double
  #+END_EXAMPLE

** 整数
   1， 1.，+1, -1, 536870913, 0, -0 这些都是整数。整数的范围是和机器是有关的，一般来最小范围是在 -268435456 to 268435455（29位，-2**28 ~ 2**28-1）

   #+BEGIN_EXAMPLE
     可以从 most-positive-fixnum 和 most-negative-fixnum 两个变量得到整数的范围
   #+END_EXAMPLE

   可以用多种进制来输入一个整数。比如：
   #+BEGIN_SRC lisp 
  #b101100 ;; => 44      ; 二进制
  #o54 ;; => 44          ; 八进制
  #x2c ;; => 44          ; 十进制
   #+END_SRC
   最神奇的是可以用 2 到 36 之间任意一个数作为基数，比如：

   #+BEGIN_SRC lisp 
  #24r1k ;; => 44 二十四进制
   #+END_SRC

   #+BEGIN_EXAMPLE
     之所以最大是 36，是因为只有 0-9 和 a-z 36 个字符来表示数字

     但是基本上不会有人会用到 elisp 的这个特性
   #+END_EXAMPLE

** 浮点数
   1500.0, 15e2, 15.0e2, 1.5e3, 和 .15e4 都可以用来表示一个浮点数 1500.

   #+BEGIN_EXAMPLE
     遵循 IEEE 标准，elisp 也有一个特殊类型的值称为 NaN (not-a-number)

     可以用 (/ 0.0 0.0) 产生这个数
   #+END_EXAMPLE

** 测试
    整数类型测试函数是 integerp，浮点数类型测试函数是 floatp。数字类型测试用 numberp。可以分别运行这几个例子来试验一下：

    #+BEGIN_SRC lisp 
  (integerp 1.)                           ; => t
  (integerp 1.0)                          ; => nil
  (floatp 1.)                             ; => nil
  (floatp -0.0e+NaN)                      ; => t
  (numberp 1)                             ; => t
    #+END_SRC

    还提供一些特殊测试，比如测试是否是零的 zerop，还有非负整数测试的 wholenump 

    #+BEGIN_EXAMPLE
      elisp 测试函数一般都是用 p 来结尾，p 是 predicate 的第一个字母

      如果函数名是一个单词，通常只是在这个单词后加一个 p，如果是多个单词，一般是加 -p 
    #+END_EXAMPLE

** 比较
    常用的比较操作符号是在其它言中都很熟悉的，比如 <, >, >=, <=, = 
    #+BEGIN_EXAMPLE
      由于赋值是使用 set 函数，所以 = 不再是一个赋值运算符了，而是测试数字相等符号

      和其它语言类似，对于浮点数的相等测试都是不可靠的
    #+END_EXAMPLE

    比如：

    #+BEGIN_SRC lisp 
  (setq foo (- (+ 1.0 1.0e-3) 1.0))       ; => 0.0009999999999998899
  (setq bar 1.0e-3)                       ; => 0.001
  (= foo bar)                             ; => nil
    #+END_SRC

    所以一定要确定两个浮点数是否相同，是要在一定误差内进行比较。这里给出一个函数：

    #+BEGIN_SRC lisp 
  (defvar fuzz-factor 1.0e-6)

  (defun approx-equal (x y)
    (or (and (= x 0) (= y 0))
	(< (/ (abs (- x y))
	      (max (abs x) (abs y)))
	   fuzz-factor)))
  (approx-equal foo bar)                  ; => t
    #+END_SRC

    还有一个测试数字是否相等的函数 eql，这是函数不仅测试数字的值是否相等，还测试 *数字类型* 是否一致，比如：

    #+BEGIN_SRC lisp 
  (= 1.0 1)                               ; => t
  (eql 1.0 1)                             ; => nil
    #+END_SRC

    #+BEGIN_EXAMPLE
      elisp 没有 +=, -=, /=, *= 这样的命令式语言里常见符号

      如果想实现类似功能的语句，只能用赋值函数 setq 来实现了

      /= 符号被用来作为不等于的测试了 
    #+END_EXAMPLE

** 转换
    整数向浮点数转换是通过 float 函数进行的。而浮点数转换成整数有这样几个函数：
    + truncate 转换成靠近 0 的整数
    + floor 转换成最接近的不比本身大的整数
    + ceiling 转换成最接近的不比本身小的整数
    + round 四舍五入后的整数，换句话说和它的差绝对值最小的整数

    #+BEGIN_EXAMPLE
      可以用 1.2, 1.7, -1.2, -1.7 对这四个函数操作一遍就知道区别了

      浮点数的范围是无穷大的，而整数是有范围的，如果用前面的函数转换 1e20 成一个整数会出现什么情况呢？
    #+END_EXAMPLE

** 运算 
    四则运算没有什么好说的，就是 + - * /。值得注意的是

    #+BEGIN_EXAMPLE
      和 C 语言类似，如果参数都是整数，作除法时要记住 (/ 5 6) 是会等于 0 的

      如果参数中有浮点数，整数会自动转换成浮点数进行运算，所以 (/ 5 6.0) 的值才会是 5/6
    #+END_EXAMPLE

    没有++和--操作了，类似的两个函数是 _1+_ 和 _1-_ 。可以用 setq 赋值来代替++和--：

    #+BEGIN_SRC lisp 
  (setq foo 10)                           ; => 10
  (setq foo (1+ foo))                     ; => 11
  (setq foo (1- foo))                     ; => 10
    #+END_SRC

    #+BEGIN_EXAMPLE
      可能有人看过有 incf 和 decf 两个实现 ++ 和 -- 操作，这两个宏是可以用的

      这两个宏是 Common Lisp 里的，emacs 有模拟的 Common Lisp 的库 cl。但是 RMS 认为最好不要使用这个库
    #+END_EXAMPLE

    可以在的 elisp 包中使用这两个宏，只要在文件头写上：

    #+BEGIN_SRC lisp 
  (eval-when-compile
    (require 'cl))
    #+END_SRC

    #+BEGIN_EXAMPLE
      由于 incf 和 decf 是两个宏，所以这样写不会在运行里导入 cl 库
    #+END_EXAMPLE

    + 取数的绝对值: abs 
    + 取整的函数: 一个是符号 %，一个是函数 mod
    #+BEGIN_EXAMPLE
      这两个函数有什么差别呢？

      一是 % 的第个参数必须是整数，而 mod 的第一个参数可以是整数也可以是浮点数

      二是即使对相同的参数，两个函数也不一定有相同的返回值
    #+END_EXAMPLE

    + 三角运算有函数： sin, cos, tan, asin, acos, atan
    + 开方函数： sqrt
    + 指数函数：exp 是以 e 为底的指数运算，expt 可以指定底数的指数运算
    + 对数函数：log 默认底数是 e
      + 也可以指定底数。log10 就是以10为底数
      + logb 是以 2 为底数运算，但是返回的是一个整数。这个函数是用来计算数的位
    + 随机函数：random 可以产生随机数

    #+BEGIN_EXAMPLE
      当然还包含位运算
    #+END_EXAMPLE

* 字符串
  在 emacs 里字符串是有序的字符数组，和 c 语言的字符串数组不同，emacs 的字符串可以容纳任何字符，包括 _\0_ ： 
  #+BEGIN_SRC lisp 
  (setq foo "abc\000abc")                 ; => "abc^@abc"
  #+END_SRC

  #+BEGIN_EXAMPLE
    关于字符串有很多高级的属性，例如字符串的表示有单字节和多字节类型，字符串可以有文本属性等等
  #+END_EXAMPLE

** 字符
   首先构成字符串的字符其实就是一个整数
   #+BEGIN_EXAMPLE
     一个字符 'A' 就是一个整数 65

     但是目前字符串中的字符被限制在 0-524287 之间
   #+END_EXAMPLE
   字符的读入语法是在字符前加上一个问号，比如 ?A 代表字符 'A'

   #+BEGIN_SRC lisp 
  ?A                                      ; => 65
  ?a                                      ; => 97
   #+END_SRC

   + 对于 _标点_ 来说，也可以用同样的语法，但是最好在前面加上转义字符 _\_ ，因为有些标点会有岐义，比如 ?\(
     + \ 必须用 ?\\ 表示
   + 控制字符，退格、制表符，换行符，垂直制表符，换页符，空格，回车，删除和 escape 表示为 ?\a, ?\b, ?\t, ?\n, ?\v, ?\f, ?\s, ?\r, ?\d, 和 ?\e

   #+BEGIN_SRC lisp 

  ?\a => 7                 ; control-g, `C-g'
  ?\b => 8                 ; backspace, <BS>, `C-h'
  ?\t => 9                 ; tab, <TAB>, `C-i'
  ?\n => 10                ; newline, `C-j'
  ?\v => 11                ; vertical tab, `C-k'
  ?\f => 12                ; formfeed character, `C-l'
  ?\r => 13                ; carriage return, <RET>, `C-m'
  ?\e => 27                ; escape character, <ESC>, `C-['
  ?\s => 32                ; space character, <SPC>
  ?\\ => 92                ; backslash character, `\'
  ?\d => 127               ; delete character, <DEL>
   #+END_SRC

   #+BEGIN_EXAMPLE
     没有特殊意义的字符，加上转义字符 \ 是没有副作用的，比如 ?\+ 和 ?+ 是完全一样的

     所以标点还是都用转义字符来表示吧 
   #+END_EXAMPLE

   _控制字符_ 可以有多种表示方式，比如 C-i，这些都是对的，它们都对应数字 9：

   #+BEGIN_SRC lisp 
  ?\^I
  ?\^i
  ?\C-I
  ?\C-i 
   #+END_SRC
   _meta 字符_ 是用 _修饰键_ （通常就是 Alt 键）输入的字符。之所以称为修饰键，是因为这样输入的字符就是在其修饰字符的第 *27* 位由 0 变成 1 而成，也就是如下操作：

   #+BEGIN_SRC lisp 
  (logior (lsh 1 27) ?A)                  ; => 134217793
  ?\M-A                                   ; => 134217793
   #+END_SRC
   可以用 _\M-_ 代表 meta 键，加上修饰的字符就是新生成的字符。比如：?\M-A, ?\M-\C-b. 后面这个也可以写成 ?\C-\M-b。

   #+BEGIN_EXAMPLE
     如果还记得前面说过字符串里的字符不能超过 524287 的话，这就可以看出字符串是不能放下一个 meta 字符的，所以按键序列在这时只能用 vector 来储存
   #+END_EXAMPLE

   其它的修饰键也是类似的，emacs 用 ：
   + 第 25 位来表示 shift 键
   + 第 24 对应 hyper
   + 第 23 对应 super
   + 第 22 对应 alt

** 测试
   + 字符串测试使用 _stringp_ ，没有 charp，因为字符就是整数
   + _string-or-null-p_ 当对象是一个字符或 nil 时返回 t
   + _char-or-string-p_ 测试是否是字符串或者字符类型

   #+BEGIN_EXAMPLE
   比较头疼的是 emacs 没有测试字符串是否为空的函数
   #+END_EXAMPLE
   这是我用的这个测试函数，使用前要测试字符串是否为 nil：

   #+BEGIN_SRC elisp 
  (defun string-emptyp (str)
    (not (string< "" str)))
   #+END_SRC

** 构造
   + 产生一个字符串可以用 _make-string_ 。这样生成的字符串包含的字符都是一样的
   + 要生成不同的字符串可以用 _string_ 函数 

   #+BEGIN_SRC lisp 
  (make-string 5 ?x)                      ; => "xxxxx"
  (string ?a ?b ?c)                       ; => "abc"
   #+END_SRC

   在已有的字符串生成新的字符串的方法有 _substring_ , _concat_ 
   + substring 的后两个参数是起点和终点的位置，如果终点越界或者终点比起点小都会产生一个错误。这个在使用 substring 时要特别小心 

   #+BEGIN_SRC lisp 
  (substring "0123456789" 3)              ; => "3456789"
  (substring "0123456789" 3 5)            ; => "34"
  (substring "0123456789" -3 -1)          ; => "78"
   #+END_SRC

   concat 函数相对简单，就是把几个字符串连接起来

** 比较
   + _char-equal_ 可以比较两个字符是否相等。与整数比较不同，这个函数还考虑了大小写
     + 如果 _case-fold-search_ 变量是 t 时，这个函数的字符比较是忽略大小写的
   #+BEGIN_EXAMPLE
     编程时要小心，因为通常 case-fold-search 都是 t，这样如果要考虑字符的大小写时就不能用 char-equal 函数了
   #+END_EXAMPLE
   + 字符串比较使用 _string=_ ，string-equal 是一个别名
   + _string<_ 是按 *字典序* 比较两个字符串，string-less 是它的别名
   #+BEGIN_EXAMPLE
     空字符串小于所有字符串，除了空字符串，前面 string-emptyp 就是用这个特性

     当然直接用 length 检测字符串长度应该也可以，还可以省去检测字符串是否为空
   #+END_EXAMPLE
   + 没有 string> 函数


** 转换


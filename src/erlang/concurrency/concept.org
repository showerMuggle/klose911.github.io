#+TITLE: 并发原语
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: concurrency.html   
#+HTML_LINK_HOME: concurrency.html
#+OPTIONS: num:nil timestamp:nil ^:nil *:nil 


#+begin_example
  可以联想一下房间里的人：

  人就是进程。房间里的人都有他们的私人记忆,进程也是如此

  要改变你的记忆,就需要我说给你听。这就是发送和接收消息

  我们有了小孩,这就是分裂(spawn)

  我们死了,就是进程退出
#+end_example

了解顺序Erlang后,编写并发程序就很简单了。只需要三个新的基本函数: _spawn+_ 、 _send_ 和 _receive_ 
+ spawn: *创建* 一个 *并行进程*
+ send: 向某个进程 *发送消息* 
+ receive: 则是 *接收消息*  

Erlang的并发是基于 *进程* ( _process_ )的。进程是一些独立的小型虚拟机,可以执行Erlang函数 
#+begin_example
  你肯定曾经接触过进程,但仅仅是在操作系统的上下文环境里

  在Erlang里,进程隶属于编程语言,而非操作系统

  这就意味着Erlang的进程在任何操作系统上都会具有相同的逻辑行为,这样就能编写可移植的并发代码,让它在任何支持Erlang的操作系统上运行 
#+end_example


在Erlang里：
+ 创建和销毁进程是非常快速的
+ 在进程间发送消息是非常快速的
+ 进程在所有操作系统上都具有相同的行为方式
+ 可以拥有大量进程
+ 进程不共享任何内存,是完全独立的
+ 进程唯一的交互方式就是消息传递。

出于这些原因,Erlang有时会被称为是一种 *纯消息传递式* 语言

#+begin_example
  如果你没有进程编程的经验,可能听说过它很有难度的传言。你多半听过一些恐怖故事,涉及内存冲突、竞争状况、共享内存破坏等等

  但在Erlang里,进程编程是很简单的
#+end_example
* 基本并发函数

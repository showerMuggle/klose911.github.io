#+TITLE: Volume
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../../css/main.css" />
#+HTML_LINK_UP: config-map.html
#+HTML_LINK_HOME: storage.html
#+OPTIONS: num:nil timestamp:nil ^:nil

#+begin_example
  容器磁盘上的文件的生命周期是短暂的，这就使得在容器中运行重要应用时会出现一些问题

  首先，当容器崩溃时，kubelet 会重启它，但是容器中的文件将丢失——容器以干净的状态（镜像最初的状态）重新启动

  其次，在 Pod 中同时运行多个容器时，这些容器之间通常需要共享文件
#+end_example

Kubernetes 中的 Volume 抽象就很好的解决了这些问题
* 背景
  #+begin_example
    Docker 中也有一个 volume 的概念，尽管它稍微宽松一些，管理也很少

    在 Docker 中，卷就像是磁盘或是另一个容器中的一个目录

    它的生命周期不受管理，直到最近才有了 local-disk-backed 卷

    Docker 现在提供了卷驱动程序，但是功能还非常有限。例如 Docker1.7只允许每个容器使用一个卷驱动，并且无法给卷传递参数
  #+end_example
  + Kubernetes 中的卷有明确的寿命：与封装它的 Pod 相同。所以，卷的生命比 Pod 中的所有容器都长，当这个容器重启时数据仍然得以保存
    #+begin_example
      当然，当 Pod 不再存在时，卷也将不复存在
    #+end_example
  + 更重要的是，Kubernetes 支持多种类型的卷，Pod 可以同时使用任意数量的卷

  卷的核心是目录，可能还包含了一些数据，可以通过 pod 中的容器来访问
  #+begin_example
    该目录是如何形成的、支持该目录的介质以及其内容取决于所使用的特定卷类型
  #+end_example

  要使用卷，需要为 pod 指定为卷 _spec.volumes_ 字段 以及将它挂载到容器的位置 _spec.containers.volumeMounts_ 字段 

  #+begin_example
    容器中的进程看到的是由其 Docker 镜像和卷组成的文件系统视图

    Docker 镜像位于文件系统层次结构的根目录，任何卷都被挂载在镜像的指定路径中

    卷无法挂载到其他卷上或与其他卷有硬连接

    Pod 中的每个容器都必须独立指定每个卷的挂载位置
  #+end_example
* 类型
  Kubernetes 支持以下类型的卷：
  + awsElasticBlockStore
  + azureDisk
  + azureFile
  + cephfs
  + csi
  + downwardAPI
  + emptyDir
  + fc (fibre channel)
  + flocker
  + gcePersistentDisk
  + gitRepo
  + glusterfs
  + hostPath
  + iscsi
  + local
  + nfs
  + persistentVolumeClaim
  + projected
  + portworxVolume
  + quobyte
  + rbd
  + scaleIO
  + secret
  + storageos
  + vsphereVolume

** awsElasticBlockStore
   awsElasticBlockStore 卷将 _AWS EBS Volume_ 挂载到容器中：
   + 与 emptyDir 类型会在删除 Pod 时被清除不同，EBS 卷的的内容会保留下来，仅仅是被 *卸载*
     #+begin_example
       这意味着 EBS 卷可以预先填充数据，并且可以在数据包之间“切换”数据 
     #+end_example

   #+begin_example
     必须使用 aws ec2 create-volume 或 AWS API 创建 EBS 卷，才能使用它
   #+end_example

   使用 awsElasticBlockStore 卷时有一些限制：
   + 运行 Pod 的节点必须是 AWS EC2 实例
   + 这些实例需要与 EBS 卷位于相同的区域和可用区域
   + EBS 仅支持卷和 EC2 实例的一对一的挂载   

*** 创建 EBS 卷
    在 pod 中使用的 EBS 卷之前，需要先创建它：

    #+begin_src sh 
      $ aws ec2 create-volume --availability-zone=eu-west-1a --size=10 --volume-type=gp2
    #+end_src

    确保区域与您启动集群的区域相匹配（并且检查大小和 EBS 卷类型是否适合！）

*** 配置
    #+begin_example
      apiVersion: v1
      kind: Pod
      metadata:
	name: test-ebs
      spec:
	containers:
	- image: k8s.gcr.io/test-webserver
	  name: test-container
	  volumeMounts:
	  - mountPath: /test-ebs
	    name: test-volume
	volumes:
	- name: test-volume
	  # This AWS EBS volume must already exist.
	  awsElasticBlockStore:
	    volumeID: <volume-id>
	    fsType: ext4
    #+end_example
 
** azureDisk
   AzureDisk 用于将 Microsoft Azure Data Disk 挂载到 Pod 中

** azureFile
   azureFile 用于将 Microsoft Azure File Volume（SMB 2.1 和 3.0）挂载到 Pod 中 

** cephfs
   cephfs 卷允许将现有的 CephFS 卷挂载到您的容器中：
   + 不像 emptyDir，当删除 Pod 时被删除，cephfs 卷的内容将被保留，卷仅仅是被卸载
     #+begin_example
       这意味着 CephFS 卷可以预先填充数据，并且可以在数据包之间“切换”数据
     #+end_example
   + CephFS 可以被多个写设备同时挂载

   #+begin_example
   必须先拥有自己的 Ceph 服务器，然后才能使用它
   #+end_example

** csi
   _CSI_ 代表 *容器存储接口*
   #+begin_example
     CSI 试图建立一个行业标准接口的规范，借助 CSI 容器编排系统可以将任意存储系统暴露给自己的容器工作负载
   #+end_example

   csi 卷类型是一种 _in-tree_ 的 _CSI 卷插件_ ，用于 Pod 与在 _同一节点_ 上运行的 _外部 CSI 卷驱动程序_ 交互。部署 CSI 兼容卷驱动后，用户可以使用 csi 作为卷类型来挂载驱动提供的存储

   #+begin_example
     CSI 持久化卷支持是在 Kubernetes v1.9 中引入的，作为一个 alpha 特性，必须由集群管理员明确启用

     换句话说，集群管理员需要在 apiserver、controller-manager 和 kubelet 组件的 “--feature-gates =” 标志中加上 “CSIPersistentVolume = true”
   #+end_example
   CSI 持久化卷具有以下字段可供用户指定：
   + driver：一个字符串值，指定要使用的卷驱动程序的名称
     + 必须少于 63 个字符，并以一个字符开头
     + 驱动程序名称可以包含 “.”、“- ”、“_” 或数字
   + volumeHandle：一个字符串值，唯一标识从 CSI 卷插件的 CreateVolume 调用返回的卷名。随后在卷驱动程序的所有后续调用中使用卷句柄来引用该卷
   + readOnly：一个可选的布尔值，指示卷是否被发布为只读
     + 默认是 false

** downwardAPI
   downwardAPI 卷用于使 _向下 API 数据_ 对应用程序可用。它挂载一个目录，并将请求的数据写入纯文本文件 

** emptyDir
   当 Pod 被分配给节点时，首先创建 emptyDir 卷，并且只要该 Pod 在该节点上运行，该卷就会存在：
   + 正如卷的名字所述，它最初是空的
   + Pod 中的容器可以读取和写入 emptyDir 卷中的相同文件，尽管该卷可以挂载到每个容器中的相同或不同路径上
   + 当出于任何原因从节点中删除 Pod 时，emptyDir 中的数据将被 *永久* 删除 

   #+begin_example
     注意：容器崩溃不会从节点中移除 pod，因此 emptyDir 卷中的数据在容器崩溃时是安全的
   #+end_example

   emptyDir 的用法有：
   + 暂存空间，例如用于基于磁盘的合并排序
   + 用作长时间计算崩溃恢复时的检查点
   + Web服务器容器提供数据时，保存内容管理器容器提取的文件

*** 示例
    #+begin_example
      apiVersion: v1
      kind: Pod
      metadata:
	name: test-pd
      spec:
	containers:
	- image: k8s.gcr.io/test-webserver
	  name: test-container
	  volumeMounts:
	  - mountPath: /cache
	    name: cache-volume
	volumes:
	- name: cache-volume
	  emptyDir: {}
    #+end_example
 
** fc
   fc 卷允许将现有的 fc 卷挂载到 pod 中。可以使用卷配置中的 targetWWN 参数指定单个或多个目标全球通用名称( World Wide Name )：
   + 如果指定了多个 WWN，则 targetWWN 期望这些 WWN 来自多路径连接 

   #+begin_example
     必须配置 FC SAN 区域划分，并预先将这些 LUN（卷）分配并屏蔽到目标 WWN，以便 Kubernetes 主机可以访问它们
   #+end_example

** flocker
   Flocker 是一款开源的 _集群容器数据卷管理器_ 。它提供了由各种存储后端支持的数据卷的管理和编排。flocker 允许将 Flocker 数据集挂载到 pod 中：
   + 如果数据集在 Flocker 中不存在，则需要先使用 Flocker CLI 或使用 Flocker API 创建数据集
   + 如果数据集已经存在，它将被 Flocker 重新连接到 pod 被调度的节点上
     #+begin_example
       这意味着数据可以根据需要在数据包之间“切换” 
     #+end_example

   #+begin_example
     重要提示：必须先运行自己的 Flocker 安装程序才能使用它
   #+end_example

** gcePersistentDisk
   gcePersistentDisk 卷将 _GCE Persistent Disk_ 挂载到容器中
   + 与删除 Pod 时删除的 emptyDir 不同，PD 的内容被保留，只是卸载了卷
     #+begin_example
       这意味着 PD 可以预先填充数据，并且数据可以在 Pod 之间“切换”
     #+end_example

   #+begin_example
     必须先使用 gcloud 或 GCE API 或 UI 创建一个 PD，然后才能使用它
   #+end_example

   使用 gcePersistentDisk 时有一些限制：
   + 运行 Pod 的节点必须是 GCE 虚拟机
   + 那些虚拟机需要在与 PD 一样在 GCE 项目和区域中

   PD 的一个特点是它们可以同时被多个用户以只读方式挂载。这意味着可以预先使用您的数据集填充 PD，然后根据需要给多个 Pod 中并行提供

   #+begin_example
     不幸的是，只能由单个消费者以读写模式挂载 PD，而不允许同时写入

     在由 ReplicationController 控制的 pod 上使用 PD 将会失败，除非 PD 是只读的或者副本数是 0 或 1
   #+end_example

*** 创建 PD
    在 pod 中使用 GCE PD 之前，需要先创建它：

    #+begin_src sh 
      $ gcloud compute disks create --size=500GB --zone=us-central1-a my-data-disk
    #+end_src

*** 示例

    #+begin_example
      apiVersion: v1
      kind: Pod
      metadata:
	name: test-pd
      spec:
	containers:
	- image: k8s.gcr.io/test-webserver
	  name: test-container
	  volumeMounts:
	  - mountPath: /test-pd
	    name: test-volume
	volumes:
	- name: test-volume
	  # This GCE PD must already exist.
	  gcePersistentDisk:
	    pdName: my-data-disk
	    fsType: ext4
    #+end_example

** gitRepo 

   gitRepo 卷是一个可以演示卷插件功能的示例。它会 *挂载* 一个 _空目录_ 并将 _git 存储库_ *克隆* 到容器中

   #+begin_example
     将来，这样的卷可能会转移到一个更加分离的模型，而不是为每个这样的用例扩展 Kubernetes API
   #+end_example

   下面是 gitRepo 卷示例：

   #+begin_example
     apiVersion: v1
     kind: Pod
     metadata:
       name: server
     spec:
       containers:
       - image: nginx
	 name: nginx
	 volumeMounts:
	 - mountPath: /mypath
	   name: git-volume
       volumes:
       - name: git-volume
	 gitRepo:
	   repository: "git@somewhere:me/my-git-repository.git"
	   revision: "22f1d8406d464b0c0874075539c1f2e96c253775"
   #+end_example

** glusterfs
   #+begin_example
     glusterfs 一个开放源代码的网络文件系统
   #+end_example

   glusterfs 卷允许将 _Glusterfs_ 卷挂载到的集群中：
   + 与删除 Pod 时删除的 emptyDir 不同，glusterfs 卷的内容将被保留，而卷仅仅被卸载
     #+begin_example
       这意味着 glusterfs 卷可以预先填充数据，并且可以在数据包之间“切换”数据
     #+end_example
   + GlusterFS 可以同时由多个写入挂载 

   #+begin_example
     必须先自行安装 GlusterFS，才能使用它
   #+end_example

** hostPath

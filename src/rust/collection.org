#+TITLE: 集合
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/main.css" />
#+HTML_LINK_UP: module.html   
#+HTML_LINK_HOME: rust.html
#+OPTIONS: num:nil timestamp:nil ^:nil

Rust 标准库中包含一系列被称为 _集合_ ，非常有用的 *数据结构* ：
+ 大部分其他数据类型都代表一个特定的值，不过集合可以 _包含多个值_
+ 不同于内建的数组和元组类型，这些集合指向的数据是 _储存在堆_ 上的，这意味着数据的数量不必在编译时就已知，并且还可以随着程序的运行增长或缩小
+ 每种集合都有着不同功能和成本，而根据当前情况选择合适的集合，这是一项始终成长的技能

这一章将详细的了解三个在 Rust 程序中被广泛使用的集合：
1. vector : 允许 _一个挨着一个_ 地储存一系列数量可变的值
2. String: 是一个 _字符_ 的集合
3. hashMap: 允许将 _值_ 与一个特定的 _键_ 相关联

#+BEGIN_EXAMPLE
  接下来将讨论如何创建和更新 vector、字符串和哈希 map，以及它们有什么特别之处
#+END_EXAMPLE
* vector  
  第一个类型是 _Vec<T>_ ，也被称为 vector。vector 允许在一个 *单独* 的数据结构中储存 *多于一个* 的值：
  + 在 *内存中彼此相邻* 地排列所有的值
  + 只能储存 *相同类型* 的值

  #+BEGIN_EXAMPLE
    在拥有一系列项的场景下非常实用，例如文件中的文本行或是购物车中商品的价格
  #+END_EXAMPLE
** 新建 vector
   为了创建一个新的空 vector，可以调用 _Vec::new_ 函数，如下所示：

   #+BEGIN_SRC rust 
  let v: Vec<i32> = Vec::new();
   #+END_SRC

   注意：这里增加了一个 _类型_ 注解。因为没有向这个 vector 中插入任何值，Rust 并不知道想要储存什么类型的元素

   #+BEGIN_EXAMPLE
     这是一个非常重要的点：vector 是用泛型实现的，它可以存放任何类型

     而当 Vec 存放某个特定类型时，那个类型位于尖括号中

     在示例中，v 这个 Vec 将存放 i32 类型的元素
   #+END_EXAMPLE

   在更实际的代码中，一旦插入值 Rust 就可以推断出想要存放的类型，所以你很少会需要这些类型注解。更常见的做法是使用 _初始值_ 来创建一个 Vec，而且为了方便 Rust 提供了 _vec!_ 宏。这个宏会根据 _提供的值_ 来创建一个新的 Vec。下面新建一个拥有值 1、2 和 3 的 Vec<i32>：

   #+BEGIN_SRC rust 
  let v = vec![1, 2, 3];
   #+END_SRC

   因为提供了 i32 类型的初始值，Rust 可以推断出 v 的类型是 _Vec<i32>_ ，因此类型注解就不是必须的。接下来让看看如何修改一个 vector
** 更改 vector
   对于新建一个 vector 并向其增加元素，可以使用 _push_ 方法：

   #+BEGIN_SRC rust 
  let mut v = Vec::new();

  v.push(5);
  v.push(6);
  v.push(7);
  v.push(8);
   #+END_SRC

   + 如果想要能够改变它的值，必须使用 _mut_ 关键字使其可变
   + 放入其中的所有值都是 _i32_ 类型的，而且 Rust 也根据数据做出如此判断，所以不需要 Vec<i32> 注解

   #+BEGIN_EXAMPLE
     另外除了 push 之外还有一个 pop 方法，它会移除并返回 vector 的最后一个元素
   #+END_EXAMPLE

** 丢弃 vector 时也会丢弃其所有元素 
   类似于任何其他的 struct，vector 在其 *离开作用域时会被释放* ，如下面注释： 

   #+BEGIN_SRC rust 
  {
      let v = vec![1, 2, 3, 4];

      // 处理变量 v

  } // <- 这里 v 离开作用域并被丢弃
   #+END_SRC

   #+BEGIN_EXAMPLE
     当 vector 被丢弃时，所有其内容也会被丢弃，这意味着这里它包含的整数将被清理

     这可能看起来非常直观，不过一旦开始使用 vector 元素的引用，情况就变得有些复杂了
   #+END_EXAMPLE

** 读取 vector 的元素

   访问 vector 中一个值的两种方式， _索引_ 语法或者 _get_ 方法：

   #+BEGIN_SRC rust 
  let v = vec![1, 2, 3, 4, 5];

  let third: &i32 = &v[2];
  println!("The third element is {}", third);

  match v.get(2) {
      Some(third) => println!("The third element is {}", third),
      None => println!("There is no third element."),
  }
   #+END_SRC

   这里有两个需要注意的地方：
   + 使用 _索引值 2_ 来获取 _第三个_ 元素，索引是从 _0_ 开始的
   + 两个不同的获取第三个元素的方式分别为：
     + 使用 _&_ 和 _[]_ 返回一个 *引用*
     + 使用 _get_ 方法以索引作为参数来返回一个 *Option<&T>* 

   #+BEGIN_EXAMPLE
     Rust 有两个引用元素的方法的原因：程序可以选择如何处理当索引值在 vector 中没有对应值的情况
   #+END_EXAMPLE

   如果有一个有五个元素的 vector 接着尝试访问索引为 100 的元素时程序会如何处理，如下所示： 

   #+BEGIN_SRC rust 
  let v = vec![1, 2, 3, 4, 5];

  let does_not_exist = &v[100];
  let does_not_exist = v.get(100);
   #+END_SRC

   当运行这段代码，对于第一个 [] 方法，当引用一个不存在的元素时 Rust 会 *造成 panic* 
   #+BEGIN_EXAMPLE
     这个方法更适合当程序认为尝试访问超过 vector 结尾的元素是一个严重错误的情况，这时应该使程序崩溃
   #+END_EXAMPLE

   当 get 方法被传递了一个数组外的索引时，它不会 panic 而是 *返回 None* 

   #+BEGIN_EXAMPLE
     当偶尔出现超过 vector 范围的访问属于正常情况的时候可以考虑使用它，接着代码可以有处理 Some(&element) 或 None 的逻辑

     例如 索引可能来源于用户输入的数字。如果它们不慎输入了一个过大的数字那么程序就会得到 None 值，可以告诉用户当前 vector 元素的数量并再请求它们输入一个有效的值

     这就比因为输入错误而使程序崩溃要友好的多！
   #+END_EXAMPLE

   一旦程序获取了一个有效的引用，借用检查器将会执行 _所有权_ 和 _借用规则_ 来确保 vector 内容的这个引用和任何其他引用保持有效。当获取了 vector 的 _第一个元素的不可变引用_ 并尝试在 vector _末尾增加一个元素_ 的时候，这是行不通的：

   #+BEGIN_SRC rust 
  let mut v = vec![1, 2, 3, 4, 5];

  let first = &v[0];

  v.push(6);

  println!("The first element is: {}", first);
   #+END_SRC

   这时候会有编译报错：
   #+BEGIN_SRC sh 
  error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
   --> src/main.rs:7:5
    |
  5 |     let first = &v[0];
    |                  - immutable borrow occurs here
  6 |
  7 |     v.push(6);
    |     ^^^^^^^^^ mutable borrow occurs here
  8 |
  9 |     println!("The first element is: {}", first);
    |                                          ----- immutable borrow later used here
   #+END_SRC

   #+BEGIN_EXAMPLE
     不能这么做的原因是由于 vector 的工作方式：

     在 vector 的结尾增加新元素时，在没有足够空间将所有所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中

     这时，第一个元素的引用就指向了被释放的内存

     借用规则阻止程序陷入这种状况
   #+END_EXAMPLE

** 遍历 vector 中的元素 
   如果想要依次访问 vector 中的每一个元素，可以遍历其所有的元素而无需通过索引一次一个的访问。下面展示了如何使用 _for_ 循环来获取 i32 值的 vector 中的每一个元素的 _不可变引用_ 并将其打印：

   #+BEGIN_SRC rust 
  let v = vec![100, 32, 57];
  for i in &v {
      println!("{}", i);
  }
   #+END_SRC 

   也可以遍历可变 vector 的每一个元素的 _可变引用_ 以便能改变他们。下面的 for 循环会给每一个元素加 50：

   #+BEGIN_SRC rust 
  let mut v = vec![100, 32, 57];
  for i in &mut v {
      ,*i += 50;
  }
   #+END_SRC

** 使用枚举来储存多种类型 
   #+BEGIN_EXAMPLE
     vector 只能储存相同类型的值。这是很不方便的；绝对会有需要储存一系列不同类型的值的用例
   #+END_EXAMPLE

   幸运的是， _枚举_ 的成员都被定义为相同的枚举类型，所以当需要在 vector 中储存不同类型值时，可以定义并使用一个枚举

   #+BEGIN_EXAMPLE
     假如想要从电子表格的一行中获取值，而这一行的有些列包含数字，有些包含浮点值，还有些是字符串

     1. 可以定义一个枚举，其成员会存放这些不同类型的值，同时所有这些枚举成员都会被当作相同类型，那个枚举的类型

     2. 接着可以创建一个储存枚举值的 vector，这样最终就能够储存不同类型的值了
   #+END_EXAMPLE

   #+BEGIN_SRC rust 
  enum SpreadsheetCell {
      Int(i32),
      Float(f64),
      Text(String),
  }

  let row = vec![
      SpreadsheetCell::Int(3),
      SpreadsheetCell::Text(String::from("blue")),
      SpreadsheetCell::Float(10.12),
  ];
   #+END_SRC

   Rust 在编译时就必须准确的知道 vector 中类型的原因：
   1. 它需要知道 *储存每个元素* 到底 *需要多少内存*
   2. 可以准确的知道这个 vector 中 *允许什么类型* 
      + 如果 Rust 允许 vector 存放任意类型，那么当对 vector 元素执行操作时一个或多个类型的值就有可能会造成错误
      + 用枚举外加 match 意味着 Rust 能在编译时就保证总是会处理所有可能的情况

   #+BEGIN_EXAMPLE
     如果在编写程序时不能确切无遗地知道运行时会储存进 vector 的所有类型，枚举技术就行不通了。相反，可以使用 trait 对象
   #+END_EXAMPLE

* String 
#+BEGIN_EXAMPLE
  字符串是新晋 Rustacean 们通常会被困住的领域，这是由于三方面理由的结合：
  1. Rust 倾向于确保暴露出可能的错误
  2. 字符串是比很多程序员所想象的要更为复杂的数据结构
  3. UTF-8

  所有这些要素结合起来对于来自其他语言背景的程序员就可能显得很困难了
#+END_EXAMPLE

字符串就是作为 _字节的集合_ 外加一些方法实现的，当这些字节被解释为文本时，这些方法提供了实用的功能：
+ 先会讲述 String 中那些任何集合类型都有的操作，比如 _创建_ 、 _更新_ 和 _读取_
+ 讨论 String 与其他集合不一样的地方，例如由于人和计算机理解 String 数据方式的不同， _索引_ String是很复杂的


** 什么是字符串
Rust 的核心语言中只有一种字符串类型： *str* ，而 _字符串 slice_ 通常以被 *借用* 的形式出现 _&str_ 

#+BEGIN_EXAMPLE
  字符串 slice 是一些储存在别处的 UTF-8 编码字符串数据的引用。比如：字符串字面值被储存在程序的二进制输出中
#+END_EXAMPLE

称作 _String_ 的类型是由 *标准库* 提供的，而没有写进核心语言部分，它是 _可增长的_ 、 _可变的_ 、 有 _所有权的_ 、 _UTF-8_ 编码的字符串类型

#+BEGIN_EXAMPLE
  当 Rustacean 们谈到 Rust 的 “字符串”时，它们通常指的是 String 和字符串 slice &str 类型，而不仅仅是其中之一

  虽然本部分内容大多是关于 String 的，不过这两个类型在 Rust 标准库中都被广泛使用，String 和字符串 slice 都是 UTF-8 编码的
#+END_EXAMPLE

#+BEGIN_EXAMPLE
  Rust 标准库中还包含一系列其他字符串类型，比如 OsString、OsStr、CString 和 CStr，相关库 crate 甚至会提供更多储存字符串数据的选择

  看到这些由 String 或是 Str 结尾的名字了吗？这对应着它们提供的所有权和可借用的字符串变体，就像是你之前看到的 String 和 str

  举例而言，这些字符串类型能够以不同的编码，或者内存表现形式上以不同的形式，来存储文本内容
#+END_EXAMPLE

** 新建字符串
很多 Vec 可用的操作在 String 中同样可用，从以 _new_ 函数创建字符串开始，如下所示：

#+BEGIN_SRC rust 
  let mut s = String::new();
#+END_SRC

这新建了一个叫做 s 的空的字符串，接着可以向其中装载数据

#+BEGIN_EXAMPLE
  通常字符串会有初始数据，因为希望一开始就有这个字符串
#+END_EXAMPLE

可以使用 _to_string_ 方法，它能用于任何实现了 _Display_ trait 的类型， _字符串字面值_ 也实现了它：

#+BEGIN_SRC rust 
  let data = "initial contents";

  let s = data.to_string();

  // 该方法也可直接用于字符串字面值：
  let s = "initial contents".to_string();
#+END_SRC

也可以使用 _String::from_ 函数来从字符串字面值创建 String。下面的代码等同于使用 to_string : 

#+BEGIN_SRC rust 
  let s = String::from("initial contents");
#+END_SRC 

#+BEGIN_EXAMPLE
  因为字符串应用广泛，这里有很多不同的用于字符串的通用 API 可供选择

  其中一些可能看起来多余，不过都有其用武之地！

  在这个例子中，String::from 和 .to_string 最终做了完全相同的工作，所以如何选择就是风格问题了
#+END_EXAMPLE

字符串是 _UTF-8_ 编码的，所以可以包含任何可以正确编码的数据：
#+BEGIN_SRC rust 
  let hello = String::from("السلام عليكم");
  let hello = String::from("Dobrý den");
  let hello = String::from("Hello");
  let hello = String::from("שָׁלוֹם");
  let hello = String::from("こんにちは");
  let hello = String::from("안녕하세요");
  let hello = String::from("你好");
  let hello = String::from("Olá");
  let hello = String::from("Здравствуйте");
  let hello = String::from("Hola");
#+END_SRC
所有这些都是有效的 String 值 
** 更改字符串
String 的 _大小_ 可以增加，其 _内容_ 也可以改变，就像可以放入更多数据来改变 Vec 的内容一样。另外，可以方便的使用 _+_ *运算符* 或 _format!_ *宏* 来拼接 String 值
*** 使用 push_str 和 push 附加字符串 
可以通过 _push_str_ 方法来附加字符串 slice，从而使 String 变长：

#+BEGIN_SRC rust 
  let mut s = String::from("foo");
  s.push_str("bar");
#+END_SRC

#+BEGIN_EXAMPLE
执行这两行代码之后，s 将会包含 foobar
#+END_EXAMPLE

push_str 方法采用 _字符串 slice_ ，因为并不需要获取参数的所有权。下面展示了如果将 s2 的内容附加到 s1 之后，自身不能被使用就糟糕了：

#+BEGIN_SRC rust 
  let mut s1 = String::from("foo");
  let s2 = "bar";
  s1.push_str(s2);
  println!("s2 is {}", s2);
#+END_SRC

#+BEGIN_EXAMPLE
  如果 push_str 方法获取了 s2 的所有权，就不能在最后一行打印出其值了

  好在代码如期望的那样工作！
#+END_EXAMPLE
push 方法被定义为获取一个 _单独的字符_ 作为参数，并 *附加* 到 String 中。下面展示了使用 push 方法将字母 l 加入 String 的代码：

#+BEGIN_SRC rust 
  let mut s = String::from("lo");
  s.push('l');
#+END_SRC

#+BEGIN_EXAMPLE
执行这些代码之后，s 将会包含 “lol”
#+END_EXAMPLE
*** 使用 + 运算符或 format! 宏拼接字符串 
通常会希望将两个已知的字符串合并在一起。一种办法是像这样使用 _+_ *运算符* ：
#+BEGIN_SRC rust 
  let s1 = String::from("Hello, ");
  let s2 = String::from("world!");
  let s3 = s1 + &s2; // 注意 s1 被移动了，不能继续使用
#+END_SRC

s1 在 *相加后不再有效* 的原因，和为啥要使用 _s2 的引用_ ，都与使用 + 运算符使用了 _add_ 函数有关，这个函数签名看起来像这样：

#+BEGIN_SRC rust 
  fn add(self, s: &str) -> String {
#+END_SRC

#+BEGIN_EXAMPLE
  这并不是标准库中实际的签名；标准库中的 add 使用泛型定义

  这里看到的 add 的签名使用具体类型代替了泛型，这也正是当使用 String 值调用这个方法会发生的
#+END_EXAMPLE

+ s2 使用了 &: 使用 _第二个字符串的引用_ 与第一个字符串相加。这是因为 add 函数的 s 参数：只能将 &str 和 String 相加，不能将两个 String 值相加
#+BEGIN_EXAMPLE
  正如 add 的第二个参数所指定的，&s2 的类型是 &String 而不是 &str。那么为什么还能编译呢？ 这是因为 &String 可以被 强转成 &str

  当add函数被调用时，Rust 使用了一个被称为”解引用强制多态“的技术，可以将其理解为它把 &s2 变成了 &s2[..]

  因为 add 没有获取参数的所有权，所以 s2 在这个操作后仍然是有效的 String
#+END_EXAMPLE

+ 接着发现签名中 _add_ *获取* 了 _self 的所有权_ ，因为 self 没有使用 &
#+BEGIN_EXAMPLE
  这意味着示例中的 s1 的所有权将被移动到 add 调用中，之后就不再有效

  虽然 let s3 = s1 + &s2; 看起来就像它会复制两个字符串并创建一个新的字符串，而实际上这个语句会获取 s1 的所有权，附加上从 s2 中拷贝的内容，并返回结果的所有权

  换句话说，它看起来好像生成了很多拷贝，不过实际上并没有，因此这个实现比拷贝要更高效
#+END_EXAMPLE

如果想要级联多个字符串，+ 的行为就显得笨重了：
#+BEGIN_SRC rust 
  let s1 = String::from("tic");
  let s2 = String::from("tac");
  let s3 = String::from("toe");

  let s = s1 + "-" + &s2 + "-" + &s3;
#+END_SRC

#+BEGIN_EXAMPLE
  这时 s 的内容会是 “tic-tac-toe”

  可是在有这么多 + 和 " 字符的情况下，很难理解具体发生了什么
#+END_EXAMPLE

对于更为复杂的字符串链接，可以使用 _format! 宏_ ：

#+BEGIN_SRC rust 
  let s1 = String::from("tic");
  let s2 = String::from("tac");
  let s3 = String::from("toe");

  let s = format!("{}-{}-{}", s1, s2, s3);
#+END_SRC

#+BEGIN_EXAMPLE
  这些代码也会将 s 设置为 “tic-tac-toe”

  format! 与 println! 的工作原理相同，不过不同于将输出打印到屏幕上，它返回一个带有结果内容的 String
#+END_EXAMPLE

这个版本就好理解的多，并且 *不会获取任何参数的所有权* 
** 索引字符串
* hashMap 

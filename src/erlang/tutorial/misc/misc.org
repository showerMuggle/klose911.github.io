#+TITLE: 杂项
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/main.css" />
#+HTML_LINK_UP: ../fault-tolerance/fault-tolerance.html   
#+HTML_LINK_HOME: ../tutorial.html
#+OPTIONS: num:nil timestamp:nil

大型程序通常会把代码拆分成一组文件，各个文件之间通过良好定义的接口来连接 

* 拆分源码
  现在将前面几节中 messager 程序分布到多个文件中 
** 服务器配置头文件 

   #+begin_src erlang 
     %%%----FILE mess_config.hrl----

     %%% Configure the location of the server node,
     -define(server_node, messenger@gentoo).

     %%%----END FILE----
   #+end_src
** 客户端与 messager 之间的接口定义：
   #+begin_src erlang 
     %%%----FILE mess_interface.hrl----

     %%%Message interface between client and server and client shell for
     %%% messenger program 

     %%%Messages from Client to server received in server/1 function.
     -record(logon,{client_pid, username}).
     -record(message,{client_pid, to_name, message}).
     %%% {'EXIT', ClientPid, Reason}  (client terminated or unreachable.

     %%% Messages from Server to Client, received in await_result/0 function 
     -record(abort_client,{message}).
     %%% Messages are: user_exists_at_other_node, 
     %%%               you_are_not_logged_on
     -record(server_reply,{message}).
     %%% Messages are: logged_on
     %%%               receiver_not_found
     %%%               sent  (Message has been sent (no guarantee)
     %%% Messages from Server to Client received in client/1 function
     -record(message_from,{from_name, message}).

     %%% Messages from shell to Client received in client/1 function
     %%% spawn(mess_client, client, [server_node(), Name])
     -record(message_to,{to_name, message}).
     %%% logoff

     %%%----END FILE----
   #+end_src
** 用户接口函数

   #+begin_src erlang 
  %%%----FILE user_interface.erl----

  %%% User interface to the messenger program
  %%% login(Name)
  %%%     One user at a time can log in from each Erlang node in the
  %%%     system messenger: and choose a suitable Name. If the Name
  %%%     is already logged in at another node or if someone else is
  %%%     already logged in at the same node, login will be rejected
  %%%     with a suitable error message.

  %%% logoff()
  %%%     Logs off anybody at that node

  %%% message(ToName, Message)
  %%%     sends Message to ToName. Error messages if the user of this 
  %%%     function is not logged on or if ToName is not logged on at
  %%%     any node.

  -module(user_interface).
  -export([logon/1, logoff/0, message/2]).
  -include("mess_interface.hrl").
  -include("mess_config.hrl").

  logon(Name) ->
      case whereis(mess_client) of 
	  undefined ->
	      register(mess_client, 
		       spawn(mess_client, client, [?server_node, Name]));
	  _ -> already_logged_on
      end.

  logoff() ->
      mess_client ! logoff.

  message(ToName, Message) ->
      case whereis(mess_client) of % Test if the client is running
	  undefined ->
	      not_logged_on;
	  _ -> mess_client ! #message_to{to_name=ToName, message=Message},
	       ok
      end.
  %%%----END FILE----
   #+end_src
** messager 系统客户端的函数

   #+begin_src erlang 
     %%%----FILE mess_client.erl----

     %%% The client process which runs on each user node

     -module(mess_client).
     -export([client/2]).
     -include("mess_interface.hrl").

     client(Server_Node, Name) ->
	 {messenger, Server_Node} ! #logon{client_pid=self(), username=Name},
	 await_result(),
	 client(Server_Node).

     client(Server_Node) ->
	 receive
	     logoff ->
		 exit(normal);
	     #message_to{to_name=ToName, message=Message} ->
		 {messenger, Server_Node} ! 
		     #message{client_pid=self(), to_name=ToName, message=Message},
		 await_result();
	     {message_from, FromName, Message} ->
		 io:format("Message from ~p: ~p~n", [FromName, Message])
	 end,
	 client(Server_Node).

     %%% wait for a response from the server
     await_result() ->
	 receive
	     #abort_client{message=Why} ->
		 io:format("~p~n", [Why]),
		 exit(normal);
	     #server_reply{message=What} ->
		 io:format("~p~n", [What])
	 after 5000 ->
		 io:format("No response from server~n", []),
		 exit(timeout)
	 end.

     %%%----END FILE---
   #+end_src
** messager 服务端的函数
   #+begin_src erlang 
     %%%----FILE mess_server.erl----

     %%% This is the server process of the messenger service

     -module(mess_server).
     -export([start_server/0, server/0]).
     -include("mess_interface.hrl").

     server() ->
	 process_flag(trap_exit, true),
	 server([]).

     %%% the user list has the format [{ClientPid1, Name1},{ClientPid22, Name2},...]
     server(User_List) ->
	 io:format("User list = ~p~n", [User_List]),
	 receive
	     #logon{client_pid=From, username=Name} ->
		 New_User_List = server_logon(From, Name, User_List),
		 server(New_User_List);
	     {'EXIT', From, _} ->
		 New_User_List = server_logoff(From, User_List),
		 server(New_User_List);
	     #message{client_pid=From, to_name=To, message=Message} ->
		 server_transfer(From, To, Message, User_List),
		 server(User_List)
	 end.

     %%% Start the server
     start_server() ->
	 register(messenger, spawn(?MODULE, server, [])).

     %%% Server adds a new user to the user list
     server_logon(From, Name, User_List) ->
	 %% check if logged on anywhere else
	 case lists:keymember(Name, 2, User_List) of
	     true ->
		 From ! #abort_client{message=user_exists_at_other_node},
		 User_List;
	     false ->
		 From ! #server_reply{message=logged_on},
		 link(From),
		 [{From, Name} | User_List]        %add user to the list
	 end.

     %%% Server deletes a user from the user list
     server_logoff(From, User_List) ->
	 lists:keydelete(From, 1, User_List).

     %%% Server transfers a message between user
     server_transfer(From, To, Message, User_List) ->
	 %% check that the user is logged on and who he is
	 case lists:keysearch(From, 1, User_List) of
	     false ->
		 From ! #abort_client{message=you_are_not_logged_on};
	     {value, {_, Name}} ->
		 server_transfer(From, Name, To, Message, User_List)
	 end.
     %%% If the user exists, send the message
     server_transfer(From, Name, To, Message, User_List) ->
	 %% Find the receiver and send the message
	 case lists:keysearch(To, 2, User_List) of
	     false ->
		 From ! #server_reply{message=receiver_not_found};
	     {value, {ToPid, To}} ->
		 ToPid ! #message_from{from_name=Name, message=Message}, 
		 From !  #server_reply{message=sent} 
	 end.

     %%%----END FILE---
   #+end_src

** 测试

   在服务器节点messenger@gentoo编译并启动服务器：

   #+begin_src sh 
  $ erl -sname messenger

  Erlang/OTP 23 [erts-11.1.5] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

  Eshell V11.1.5  (abort with ^G)
  (messenger@gentoo)1> c (mess_server) .
  {ok,mess_server}
  (messenger@gentoo)2>
  (messenger@gentoo)2> mess_server:start_server() .
  User list = []
  true
   #+end_src 

   编译客户端后，peter在c1@raspberrypi登录：

   #+begin_src sh 
  $ erl -sname c1

  Erlang/OTP 21 [erts-10.2.4] [source] [smp:4:4] [ds:4:4:10] [async-threads:1]

  Eshell V10.2.4  (abort with ^G)
  (c1@raspberrypi)1> c (user_interface) .
  {ok,user_interface}
  (c1@raspberrypi)2>
  (c1@raspberrypi)2> user_interface:logon(peter) .
  true
  (c1@raspberrypi)3>
  (c1@raspberrypi)3> =ERROR REPORT==== 18-Feb-2021::12:44:02.314766 ===
  Error in process <0.92.0> on node c1@raspberrypi with exit value:
  {undef,[{mess_client,client,[messenger@gentoo,peter],[]}]}


  (c1@raspberrypi)3> c (mess_client) .
  {ok,mess_client}
  (c1@raspberrypi)4>
  (c1@raspberrypi)4> user_interface:logon(peter) .
  true
  (c1@raspberrypi)5>
  logged_on
   #+end_src

   #+begin_example
     注意：这里不仅要编译 user_interface.erl，还需要编译 mess_client.erl

     否则就会报错：

     =ERROR REPORT==== 18-Feb-2021::12:44:02.314766 ===
       Error in process <0.92.0> on node c1@raspberrypi with exit value:
       {undef,[{mess_client,client,[messenger@gentoo,peter],[]}]}
   #+end_example

   peter登录后，服务器端也会打印出新的用户列表：

   #+begin_src sh 
(messenger@gentoo)3>
User list = [{<12948.100.0>,peter}] 
   #+end_src

   fred在节点 c2@gentoo 登录：

   #+begin_src sh 
  erl -sname c2
  Erlang/OTP 23 [erts-11.1.5] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [hipe]

  Eshell V11.1.5  (abort with ^G)
  (c2@gentoo)1> c (user_interface) .
  {ok,user_interface}
  (c2@gentoo)2>
  (c2@gentoo)2> c (mess_client) .
  {ok,mess_client}
  (c2@gentoo)3>
  (c2@gentoo)3> user_interface:logon(fred) .
  true
  (c2@gentoo)4>
  logged_on
   #+end_src

   peter登录后，服务器端也会再次打印出用户列表： 
   #+begin_src sh  
  User list = [{<12950.102.0>,fred},{<12948.100.0>,peter}]
   #+end_src

   peter 尝试向 fred 发送消息： 

   #+begin_src sh 
  (c1@raspberrypi)5> user_interface:message(fred, 'hello') .
  ok
  (c1@raspberrypi)6>
  sent
   #+end_src 

   fred 收到消息后，shell 会打印出：

   #+begin_src sh 
  Message from peter: hello
   #+end_src

   同样的服务器在转发消息的时候会再次打印用户列表：

   #+begin_src sh 
  User list = [{<12950.102.0>,fred},{<12948.100.0>,peter}]
   #+end_src 

   基本测试到此已经成功
   #+begin_example
     除了完成上述工作外：
     1. 编写了头文件
     2. 使用记录重新定义了 shell 、客户端以及服务端的消息格式
     3. 引入了宏

     下面会具体解释这些新知识
   #+end_example

* 头文件

* 记录

* 宏

